<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="uCore、Lab8、操作系统、OS,漏洞挖掘, 调试, 代码, 计算机科学, Kiprey, Blog, 二进制，信息安全" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    uCore实验 - Lab8 |  Kiprey&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?acff2772e1f74a625e1e26c280afa6c2";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="Kiprey's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-uCore-8"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  uCore实验 - Lab8
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/uCore-8/" class="article-date">
  <time datetime="2020-09-27T09:35:38.000Z" itemprop="datePublished">2020-09-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF/">天问之路</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">16.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">71 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="简介">简介</h2>
<ul>
<li>这里是笔者在完成<code>uCore</code> Lab 8时写下的一些笔记</li>
<li>内容涉及文件系统与I/O子系统的一些相关实现。</li>
<li>内容巨多，建议使用右侧导航栏</li>
</ul>
<a id="more"></a>
<h2 id="知识点">知识点</h2>
<h3 id="1-文件系统和文件">1. 文件系统和文件</h3>
<ul>
<li>
<p><strong>文件系统是操作系统中管理持久性数据的子系统，提供数据存储和访问功能</strong></p>
<ul>
<li>组织、检索、读写访问数据</li>
<li>大多数计算机系统都有文件系统</li>
<li>Google也是一个文件系统</li>
</ul>
</li>
<li>
<p><strong>文件是具有符号名，由字节序列构成的数据项集合</strong></p>
<ul>
<li>文件系统的基本数据单位</li>
<li>文件名是文件的标识符号</li>
</ul>
</li>
<li>
<p>文件系统的功能</p>
<ul>
<li><strong>分配文件磁盘空间</strong>
<ul>
<li>管理文件块（位置和顺序）</li>
<li>管理空闲空间（位置）</li>
<li>分配算法（策略）</li>
</ul>
</li>
<li><strong>管理文件集合</strong>
<ul>
<li>定位：文件及其内容</li>
<li>命名：通过名字找到文件</li>
<li>文件系统结构：文件组织方式</li>
</ul>
</li>
<li><strong>数据可靠和安全</strong>
<ul>
<li>安全：多层次保护数据</li>
<li>可靠
<ul>
<li>持久保存文件</li>
<li>避免系统崩溃、媒体错误、攻击等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件属性</p>
<ul>
<li>
<p>名称、类型、大小、位置、保护、创建者、创建时间、最近修改时间</p>
</li>
<li>
<p>文件头：文件系统元数据中的文件信息</p>
<ul>
<li>文件属性</li>
<li>文件存储位置和顺序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-文件描述符">2. 文件描述符</h3>
<ul>
<li>
<p>打开文件和文件描述符</p>
<ul>
<li>
<p><strong>文件访问模式</strong>：进程访问文件数据前必须先“打开”文件</p>
</li>
<li>
<p><strong>内核跟踪</strong>进程打开的所有文件</p>
<ul>
<li>操作系统为每个进程维护一个打开文件表</li>
<li>文件描述符是打开文件的标识</li>
</ul>
</li>
</ul>
</li>
<li>
<p>操作系统在打开文件表中维护的打开文件状态和信息</p>
<ul>
<li><strong>文件指针</strong>
<ul>
<li>记录最近一次读写位置</li>
<li>每个进程分别维护自己已打开的文件指针</li>
</ul>
</li>
<li><strong>文件打开次数</strong>
<ul>
<li>当前打开文件的次数</li>
<li>最后一个进程关闭文件时，将其从打开文件表中移除</li>
</ul>
</li>
<li><strong>文件的磁盘信息</strong>：缓存数据访问信息</li>
<li><strong>访问权限</strong>：每个进程的文件访问模式信息</li>
</ul>
</li>
<li>
<p>文件的<strong>用户视图</strong>和<strong>系统视图</strong></p>
<ul>
<li>
<p>文件的<strong>用户视图</strong>：持久的<strong>数据结构</strong></p>
</li>
<li>
<p>系统访问接口</p>
<ul>
<li>字节序列的集合（Unix)</li>
<li>系统不关心存储在磁盘上的数据结构</li>
</ul>
</li>
<li>
<p>操作系统的<strong>文件视图</strong></p>
<ul>
<li>数据块的集合</li>
<li>数据块是逻辑运算单位，而扇区是物理存储单位</li>
<li>块大小通常来说<strong>不等于</strong>扇区大小</li>
</ul>
</li>
<li>
<p>用户视图到系统视图的转换</p>
<ul>
<li>进程读文件：获取字节所在的数据块，返回数据块对应部分</li>
<li>进程写文件：获取数据块，修改数据块中对应部分，写回数据块</li>
</ul>
<blockquote>
<p><strong>文件系统中的基本操作单位是数据块</strong>。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>访问模式</strong></p>
<ul>
<li>操作系统需要了解进程如何访问文件</li>
<li><strong>顺序</strong>访问：按字节依次读取。大多数的文件访问都是顺序读取。</li>
<li><strong>随机</strong>访问：从中间读写。不常用但仍然重要，例如虚拟内存中把内存页存储在文件上</li>
<li><strong>索引</strong>访问：依据数据库特征索引。
<ul>
<li>通常操作系统不完整提供索引访问</li>
<li>数据库是建立在索引内容的磁盘访问上</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>文件内部结构</strong></p>
<ul>
<li>无结构：单词、字节序列</li>
<li>简单记录结构：分列、固定长度、可变长度</li>
<li>复杂结构：格式化的文档、可执行文件、…</li>
</ul>
</li>
<li>
<p><strong>文件共享和访问控制</strong></p>
<ul>
<li><strong>多用户</strong>系统中的文件共享相当重要</li>
<li>访问控制
<ul>
<li>每个用户能够获得哪些文件的哪些访问权限</li>
<li>访问模式：读、写、执行、删除、列表等</li>
</ul>
</li>
<li>文件访问控制列表（ACL）： &lt;文件实体，权限&gt;</li>
<li>Unix模式
<ul>
<li>&lt;用户|组|所有人，读|写|可执行&gt;</li>
<li>用户标识ID：识别用户，表明每个用户所允许的权限及保护模式</li>
<li>组标识ID：允许用户组成组，并指定组访问权限</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>语义一致性</strong></p>
<ul>
<li><strong>规定多进程如何同时访问共享文件</strong>
<ul>
<li>与同步算法类似</li>
<li>因磁盘I/O和网络延迟而设计简单</li>
</ul>
</li>
<li>Unix文件系统（UFS）语义
<ul>
<li>对所打开文件的写入内容立即对其他打开同一文件的其他用户可见</li>
<li>共享文件指针允许多用户同时读取和写入文件</li>
</ul>
</li>
<li>会话语义：写入内容只有当文件关闭时可见</li>
<li>读写锁：一些操作系统和文件系统提供该功能</li>
</ul>
</li>
</ul>
<h3 id="3-目录、文件别名和文件系统种类">3. 目录、文件别名和文件系统种类</h3>
<ul>
<li>
<p><strong>分层文件系统</strong></p>
<ul>
<li>
<p>文件以目录的方式组织起来</p>
</li>
<li>
<p><strong>目录是一类特殊的文件</strong>：目录的内容是文件索引表 <strong>&lt;文件|指向文件的指针&gt;</strong></p>
</li>
<li>
<p>目录和文件的<strong>树形结构</strong>（早期的文件系统是扁平的）</p>
<p><img src="/2020/09/uCore-8/directoryTree.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p><strong>目录操作</strong></p>
<ul>
<li>典型目录操作
<ul>
<li>搜索、创建、删除文件</li>
<li>列目录、重命名、遍历路径</li>
</ul>
</li>
<li>操作系统应该只允许内核修改目录
<ul>
<li>确保映射的完整性</li>
<li>应用程序通过系统调用访问目录</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>目录实现</strong></p>
<ul>
<li>文件名的线性列表，包含了指向数据块的指针。
<ul>
<li>编程简单</li>
<li>执行耗时。</li>
</ul>
</li>
<li>哈希表——哈希数据结构的线性表
<ul>
<li>减少目录搜索时间</li>
<li>碰撞——两个文件名的哈希值相同</li>
<li>固定大小</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>文件别名</strong></p>
<blockquote>
<p>两个或多个文件名关联同一个文件</p>
</blockquote>
<ul>
<li>
<p>硬链接：多个文件项指向一个文件</p>
</li>
<li>
<p>软链接：以“快捷方式”指向其他文件</p>
<blockquote>
<p>通过存储其真实文件的逻辑名称来实现。</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/09/uCore-8/file_rename.png" alt="img"></p>
</li>
<li>
<p><strong>文件目录中的循环</strong></p>
<ul>
<li>如何保证没有循环
<ul>
<li>只允许到文件的链接，不允许在子目录的链接</li>
<li>增加链接时，用循环检测算法确定是否合理</li>
</ul>
</li>
<li>更多实践：<strong>限制路径可遍历文件目录的数量</strong></li>
</ul>
<p><img src="/2020/09/uCore-8/directoryLoop.png" alt="img"></p>
</li>
<li>
<p><strong>名字解析（路径遍历）</strong></p>
<ul>
<li>名字解析：把逻辑名字转换成物理资源（如文件）
<ul>
<li>依据路径名，在文件系统中找到实际文件位置</li>
<li>遍历文件目录直到找到目标文件</li>
</ul>
</li>
<li>举例：解析<code>/bin/sh</code>
<ul>
<li>读取根目录的文件头（在磁盘固定位置）</li>
<li>读取根目录的数据快，搜索<code>bin</code>项</li>
<li>读取<code>bin</code>的文件头</li>
<li>读取<code>bin</code>的数据块，搜索<code>ls</code>项</li>
<li>读取<code>ls</code>的文件头</li>
</ul>
</li>
<li>当前工作目录（PWD）
<ul>
<li>每个进程都会指向一个文件目录用于解析文件名</li>
<li>允许用户指定相对路径来代替绝对路径</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件系统挂载</p>
<ul>
<li>文件系统需要先挂载才能被访问</li>
<li>未挂载的文件系统被挂载在挂载点上</li>
</ul>
</li>
<li>
<p><strong>文件系统种类</strong></p>
<ul>
<li>磁盘文件系统：文件存储在数据存储设备上，如磁盘。例如：FAT, NTFS， ext2/3, ISO9660等等</li>
<li>数据库文件系统：文件特征是可被寻址的，例如WinFS</li>
<li>日志文件系统：记录文件系统的修改事件</li>
<li>特殊/虚拟文件系统</li>
<li>网络/分布式文件系统
<ul>
<li>文件可以通过网络被共享
<ul>
<li>文件位于远程服务器</li>
<li>客户端远程挂载服务器文件系统</li>
<li>标准系统文件访问被转换为成远程访问</li>
<li>标准文件共享协议：NFS for Unix, CIFS for Windows。</li>
</ul>
</li>
<li>分布式文件系统的挑战
<ul>
<li>客户端和客户端上的用户辨别起来很复杂</li>
<li><strong>一致性</strong>问题</li>
<li><strong>错误处理模式</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-虚拟文件系统">4. 虚拟文件系统</h3>
<ul>
<li>
<p>文件系统的实现：<strong>分层结构</strong></p>
<ul>
<li>虚拟（逻辑）文件系统（VFS， Virtual File System）</li>
<li>特定文件系统模块</li>
</ul>
</li>
<li>
<p><strong>虚拟文件系统（VFS）</strong></p>
<ul>
<li>目的：对所有不同文件系统的抽象</li>
<li>功能：
<ul>
<li>提供相同的文件和文件系统<strong>接口</strong></li>
<li>管理所有文件和文件系统关联的<strong>数据结构</strong></li>
<li>高效查询<strong>例程</strong>，遍历文件系统</li>
<li>与特定文件系统模块的<strong>交互</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>文件系统基本数据结构</strong></p>
<ul>
<li>文件卷控制块（Unix： <code>superblock</code>)
<ul>
<li>每个文件系统一个</li>
<li>文件系统详细信息</li>
<li>块、块大小、空余块、计数/指针等</li>
</ul>
</li>
<li>文件控制块（Unix: <code>vnode</code> or <code>inode</code>)
<ul>
<li>每个文件一个</li>
<li>文件详细信息</li>
<li>访问权限、拥有者、大小、数据块位置等</li>
</ul>
</li>
<li>目录项（Linux: <code>dentry</code>）
<ul>
<li>每个目录项一个（目录和文件）</li>
<li>将目录项数据结构及树型布局编码成树型数据结构</li>
<li>指向文件控制块、父目录、子目录等</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>文件系统的存储结构</strong></p>
<ul>
<li>文件系统数据结构：<strong>卷控制块、文件控制块、目录节点</strong></li>
<li>持久存储在外存中：存储设备的数据块中</li>
<li>当需要时加载进内存
<ul>
<li>卷控制模块：当文件系统挂载时进入内存</li>
<li>文件控制块：当文件被访问时进入内存</li>
<li>目录节点：在遍历一个文件路径时进入内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-文件缓存和打开文件">5. 文件缓存和打开文件</h3>
<ul>
<li>
<p>数据块缓存</p>
<ul>
<li>数据块按需读入内存
<ul>
<li>提供read()操作</li>
<li>预读：预先读取后面的数据块</li>
</ul>
</li>
<li>数据块使用后被缓存
<ul>
<li>假设数据将会再次用到</li>
<li>写操作可能被缓存和延迟写入</li>
</ul>
</li>
<li>两种数据块缓存方式
<ul>
<li>数据块缓存</li>
<li>页缓存：统一缓存数据块和内存页</li>
</ul>
</li>
</ul>
</li>
<li>
<p>页缓存</p>
<ul>
<li><strong>虚拟页式存储</strong>：在虚拟地址空间中虚拟页面可映射到本地外存文件中</li>
<li><strong>文件数据块的页缓存</strong>
<ul>
<li>在虚拟内存中文件数据块被映射成页</li>
<li>文件的读写操作被转换成对内存的访问</li>
<li>可能导致缺页或设置为脏页</li>
<li><strong>存在的问题：页置换算法需要协调虚拟存储和页缓存间的页面数</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件系统中打开文件的数据结构</p>
<ul>
<li>文件描述符
<ul>
<li>每个被打开的文件都有一个文件描述符</li>
<li>文件状态信息：目录项、当前文件指针、文件操作设置等</li>
</ul>
</li>
<li>打开文件表
<ul>
<li>每个进程都有一个<strong>进程打开文件表</strong></li>
<li>一个系统级的打开文件表</li>
<li>有文件被打开时，文件卷就不能被卸载</li>
</ul>
</li>
</ul>
</li>
<li>
<p>打开文件锁</p>
<blockquote>
<p>一些文件系统提供文件锁，用于协调多进程的文件访问</p>
</blockquote>
<ul>
<li><strong>强制</strong>——根据锁保持情况和访问需求确定是否拒绝访问</li>
<li><strong>劝告</strong>——进程可以查找锁的状态来决定怎么处理</li>
</ul>
</li>
</ul>
<h3 id="6-文件分配">6. 文件分配</h3>
<ul>
<li>文件大小
<ul>
<li>大多数文件都很小
<ul>
<li>需要对小文件提供很好的支持</li>
<li>块空间不能太大</li>
</ul>
</li>
<li>一些文件非常大
<ul>
<li>必须支持大文件（64位文件偏移）</li>
<li>大文件访问需要高效</li>
</ul>
</li>
</ul>
</li>
<li>文件分配
<ul>
<li>如何表示分配给一个文件数据块的位置和顺序</li>
<li>分配方式：连续分配、链式分配、索引分配</li>
<li>指标：存储效率（外部碎片等）、读写性能（访问速度等）</li>
</ul>
</li>
</ul>
<h4 id="a-连续分配">a. 连续分配</h4>
<ul>
<li>文件头指定起始块和长度</li>
<li>分配策略：<strong>最先匹配、最佳匹配</strong></li>
<li>优点：文件读取表现好；<strong>高效的顺序和随机访问</strong></li>
<li>缺点：
<ul>
<li><strong>碎片严重！</strong></li>
<li><strong>文件大小如何增长？</strong> 预分配 ？ / 按需分配？</li>
</ul>
</li>
</ul>
<h4 id="b-链式分配">b. 链式分配</h4>
<ul>
<li>文件以数据块链表方式存储</li>
<li>文件头包含了到第一块和最后一块的指针</li>
<li>优点
<ul>
<li>创建、增大、缩小很容易</li>
<li>没有碎片</li>
</ul>
</li>
<li>缺点
<ul>
<li>无法实现真正的随机访问</li>
<li>可靠性差：破坏一个链，后面的数据块全部丢失</li>
</ul>
</li>
</ul>
<h4 id="c-索引分配">c. 索引分配</h4>
<ul>
<li>为每个文件创建一个<strong>索引数据块</strong>，该索引数据块是指向文件数据块的指针列表</li>
<li>文件头包含了索引数据块指针列表</li>
<li>优点
<ul>
<li>创建、增大、缩小很容易</li>
<li>没有碎片</li>
<li>支持直接访问</li>
</ul>
</li>
<li>缺点
<ul>
<li>当文件很小时，存储索引的开销大</li>
<li>不便于处理大文件</li>
</ul>
</li>
</ul>
<h5 id="大文件的索引分配">大文件的索引分配</h5>
<ul>
<li>使用链式索引块：将多个索引块以链表的方式串联起来</li>
<li>多级索引块：一个一级索引块指向多个二级索引块等等</li>
</ul>
<h4 id="d-UFS多级索引分配">d. UFS多级索引分配</h4>
<p><img src="/2020/09/uCore-8/UFS_indexSearch.png" alt="img"></p>
<ul>
<li>文件头包含13个指针
<ul>
<li>前10个指针指向数据块</li>
<li>第11个指针指向索引块</li>
<li>第12个指针指向二级索引块</li>
<li>第13个指针指向三级索引块</li>
</ul>
</li>
<li>效果
<ul>
<li>提高了文件大小限制阈值</li>
<li>动态分配数据块，文件扩展很容易</li>
<li>小文件开销小</li>
<li>只为大文件分配间接数据块，大文件在访问数据块时需要大量查询</li>
</ul>
</li>
</ul>
<h3 id="7-空闲空间管理">7. 空闲空间管理</h3>
<p>跟踪记录文件卷中未分配的数据块</p>
<blockquote>
<p>采用什么数据结构表示空闲空间列表？</p>
</blockquote>
<ul>
<li>位图
<ul>
<li>用位图代表空闲数据块列表
<ul>
<li><code>11111110011001001010010101</code></li>
<li>$D_i = 0$表示数据块$i$是空闲，否则表示已分配</li>
</ul>
</li>
<li>使用简单但可能会是一个大的向量表
<ul>
<li>160GB磁盘 -&gt; 40MB数据块 -&gt; 5MB位图</li>
<li>假定空闲空间在磁盘中均匀分布，则找到<code>0</code>前需要扫描<strong>磁盘数据块总数/空闲块数目</strong></li>
</ul>
</li>
</ul>
</li>
<li>链表</li>
<li>链式索引</li>
</ul>
<h3 id="8-冗余磁盘矩阵RAID">8. 冗余磁盘矩阵RAID</h3>
<h4 id="a-基本概念">a. 基本概念</h4>
<ul>
<li>
<p>磁盘分区</p>
<blockquote>
<p>通常磁盘通过分区来最大限度减小寻道时间</p>
</blockquote>
<ul>
<li>分区是一组柱面的集合</li>
<li>每个分区都可视为逻辑上独立的磁盘</li>
</ul>
<p><img src="/2020/09/uCore-8/divideArea.png" alt="img"></p>
</li>
<li>
<p>一个典型的磁盘文件系统组织</p>
<ul>
<li>
<p>文件卷：一个拥有完整文件系统实例的外存空间，通常常驻在磁盘的单个分区上</p>
</li>
<li>
<p><img src="/2020/09/uCore-8/diskFileSystem.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p>多磁盘管理</p>
<ul>
<li>使用多磁盘可改善
<ul>
<li>吞吐量（通过并行）</li>
<li>可靠性和可用性（通过冗余）</li>
</ul>
</li>
<li>冗余磁盘阵列（RAID，Redundant Array of Inexpensive disks）
<ul>
<li>多种磁盘管理技术</li>
<li>RAID分类：RAID-0、RAID-1、RAID-5</li>
</ul>
</li>
<li>冗余磁盘阵列的实现
<ul>
<li>软件：操作系统内核的文件卷管理</li>
<li>硬件：RAID硬件控制器（I/O）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="b-RAID-0：磁盘条带化">b. RAID-0：磁盘条带化</h4>
<blockquote>
<p>基于数据块的条带化</p>
</blockquote>
<p>把数据块分成多个子块，存储在独立的磁盘中</p>
<blockquote>
<p>通过独立磁盘上并行数据块访问提供更大的磁盘带宽</p>
</blockquote>
<p><img src="/2020/09/uCore-8/raid0.png" alt="img"></p>
<h4 id="c-RAID-1：磁盘镜像">c. RAID-1：磁盘镜像</h4>
<p>向两个磁盘写入，从任何一个读取</p>
<ul>
<li>可靠性成倍增加</li>
<li>读取性能线性增加</li>
</ul>
<p><img src="/2020/09/uCore-8/raid1.png" alt="img"></p>
<h4 id="d-RAID-4：带校验的磁盘条带化">d. RAID-4：带校验的磁盘条带化</h4>
<blockquote>
<p>基于数据块的条带化</p>
</blockquote>
<p>数据块级的磁盘条带化加专用奇偶校验磁盘</p>
<blockquote>
<p>允许从任意一个故障磁盘中恢复</p>
</blockquote>
<p><img src="/2020/09/uCore-8/raid4.png" alt="img"></p>
<h4 id="e-RAID-5：带分布式校验的磁盘条带化">e. RAID-5：带分布式校验的磁盘条带化</h4>
<blockquote>
<p>基于数据块的条带化</p>
</blockquote>
<p><img src="/2020/09/uCore-8/raid5.png" alt="img"></p>
<h4 id="f-可纠正多个磁盘错误的冗余磁盘阵列">f. 可纠正多个磁盘错误的冗余磁盘阵列</h4>
<ul>
<li>RAID-5：每组条带块有一个奇偶校验块，允许一个磁盘错误</li>
<li>RAID-6：每组条带块有两个冗余块，允许两个磁盘错误</li>
</ul>
<h4 id="g-RAID嵌套">g. RAID嵌套</h4>
<ul>
<li>
<p>RAID 0+1</p>
<p><img src="/2020/09/uCore-8/raid01.png" alt="img"></p>
</li>
<li>
<p>RAID 1+0</p>
<p><img src="/2020/09/uCore-8/raid10.png" alt="img"></p>
</li>
</ul>
<h3 id="9-uCore文件系统实现">9. uCore文件系统实现</h3>
<h4 id="a-uCore文件系统概述">a. uCore文件系统概述</h4>
<p>操作系统中负责管理和存储可长期保存数据的软件功能模块称为文件系统。在本次试验中，主要侧重文件系统的设计实现和对文件系统执行流程的分析与理解。</p>
<p>ucore的文件系统模型源于Havard的OS161的文件系统和Linux文件系统。但其实这二者都是源于传统的UNIX文件系统设计。UNIX提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)和安装点(mount point)。</p>
<ul>
<li><strong>文件</strong>：UNIX文件中的内容可理解为是一有序字节buffer，文件都有一个方便应用程序识别的文件名称（也称文件路径名）。典型的文件操作有读、写、创建和删除等。</li>
<li><strong>目录项</strong>：目录项不是目录（又称文件路径），而是目录的组成部分。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：根目录“/”，目录“test”和文件“testfile”，这三个都是目录项。一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点（见下面的描述）位置。</li>
<li><strong>索引节点</strong>：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</li>
<li><strong>安装点</strong>：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为根文件系统树中的叶子出现在系统中。</li>
</ul>
<p>上述抽象概念形成了UNIX文件系统的逻辑数据结构，并需要通过一个具体文件系统的架构设计与实现把上述信息映射并储存到磁盘介质上，从而在具体文件系统的磁盘布局（即数据在磁盘上的物理组织）上具体体现出上述抽象概念。</p>
<blockquote>
<p>比如文件元数据信息存储在磁盘块中的索引节点上。当文件被载入内存时，内核需要使用磁盘块中的索引点来构造内存中的索引节点。</p>
</blockquote>
<p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p>
<ul>
<li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li>
<li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li>
<li><strong>Simple FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li>
<li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li>
</ul>
<p>对照上面的层次我们再大致介绍一下文件系统的访问处理过程，加深对文件系统的总体理解。假如应用程序操作文件（打开/创建/删除/读写），首先需要通过文件系统的通用文件系统访问接口层给用户空间提供的访问接口进入文件系统内部，接着由文件系统抽象层把访问请求转发给某一具体文件系统（比如SFS文件系统），具体文件系统（Simple FS文件系统层）把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。结合用户态写文件函数write的整个执行过程，我们可以比较清楚地看出ucore文件系统架构的层次和依赖关系。</p>
<p><img src="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab8_figs/image001.png" alt="image"></p>
<p><strong>ucore文件系统总体结构</strong></p>
<p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构, 它们分别是：</p>
<ul>
<li><strong>超级块（SuperBlock）</strong>，它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li><strong>索引节点（inode）</strong>：它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li><strong>目录项（dentry）</strong>：它主要从文件系统的文件路径的角度描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。对于SFS而言，inode(具体为struct sfs_disk_inode)对应于物理磁盘上的具体对象，dentry（具体为struct sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode number，另外一个成员是file name(文件名).</li>
<li><strong>文件（file）</strong>，它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
<p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构（其中相关数据结构将在下面各个小节中展开叙述）和关系如下图所示：</p>
<p><img src="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab8_figs/image002.png" alt="image"></p>
<p>先上一张相关数据结构的关联图</p>
<blockquote>
<p>自己画的太丑了T_T，该图来源<a href="http://www.resery.top/" target="_blank" rel="noopener">resery</a></p>
</blockquote>
<p><img src="/2020/09/uCore-8/fsStruct.png" alt="img"></p>
<p>文件系统整体结构</p>
<p><img src="/2020/09/uCore-8/total_struct.png" alt="img"></p>
<p>我们先从上到下分析一下结构</p>
<h4 id="b-文件系统结构">b. 文件系统结构</h4>
<h5 id="1-通用文件系统访问接口层">1) 通用文件系统访问接口层</h5>
<p>在内核中，通用的文件相关的函数分别是以下这些函数，同时也是我们在uCore中最常使用的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span></span>;        <span class="comment">// Open or create a file. FLAGS/MODE per the syscall.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;                                      <span class="comment">// Close a vnode opened  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span></span>;               <span class="comment">// Read file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span></span>;              <span class="comment">// Write file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span></span>;                <span class="comment">// Seek file  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *stat)</span></span>;                   <span class="comment">// Stat file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;                                      <span class="comment">// Sync file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                            <span class="comment">// change DIR  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                            <span class="comment">// create DIR</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path1, <span class="keyword">const</span> <span class="keyword">char</span> *path2)</span></span>;         <span class="comment">// set a path1's link as path2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path1, <span class="keyword">const</span> <span class="keyword">char</span> *path2)</span></span>;       <span class="comment">// rename file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                           <span class="comment">// unlink a path</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;                      <span class="comment">// get current working directory</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *direntp)</span></span>;        <span class="comment">// get the file entry in DIR</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span></span>;                              <span class="comment">// duplicate file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_pipe</span><span class="params">(<span class="keyword">int</span> *fd_store)</span></span>;                                <span class="comment">// build PIPE</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> open_flags)</span></span>;      <span class="comment">// build named PIPE</span></span><br></pre></td></tr></table></figure>
<p>在这些<code>sysfile_xx</code>函数中，调用的下一层函数分别是封装好的各个<code>file_xx</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *stat)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *dirent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_pipe</span><span class="params">(<span class="keyword">int</span> fd[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> open_flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通常来讲，这些函数都会操作当前进程访问文件的数据接口，即<code>current-&gt;filesp</code>。该<code>struct files_struct</code>结构如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * process's file related informaction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// inode of present working directory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// opened files array</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// the number of opened files</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// lock protect sem</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构中包含了当前进程的工作路径、所打开的文件数组集合以及信号量等。</p>
<p>在<code>fd_array</code>数组中，每个进程打开的文件所对应的索引，就是该文件在该进程所对应的文件描述符。</p>
<blockquote>
<p>即不同进程打开文件时，返回的文件描述符可能时是不一样的。</p>
</blockquote>
<h5 id="2-文件系统抽象层-VFS">2) 文件系统抽象层(VFS)</h5>
<h6 id="VFS接口与数据结构">VFS接口与数据结构</h6>
<blockquote>
<p>文件系统抽象层是把不同文件系统的对外共性接口提取出来，形成一个函数指针数组，这样，通用文件系统访问接口层只需访问文件系统抽象层，而不需关心具体文件系统的实现细节和接口。</p>
</blockquote>
<p>系统接口再下一层就到了<code>VFS</code>虚拟文件系统。VFS函数涉及到了文件结构<code>struct file</code>。该结构体指定了文件的相关类型，包括读写权限，文件描述符<code>fd</code>，当前读取到的位置<code>pos</code>，文件系统中与硬盘特定区域所对应的结点<code>node</code>，以及打开的引用次数<code>open_count</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;</span><br><span class="line">    <span class="keyword">bool</span> readable;</span><br><span class="line">    <span class="keyword">bool</span> writable;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">off_t</span> pos; <span class="comment">// 下一次写入的起始位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虚拟文件系统中，所使用的相关函数接口分别是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Virtual File System layer functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The VFS layer translates operations on abstract on-disk files or</span></span><br><span class="line"><span class="comment"> * pathnames to operations on specific files on specific filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_devlist_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer low-level operations.</span></span><br><span class="line"><span class="comment"> * See inode.h for direct operations on inodes.</span></span><br><span class="line"><span class="comment"> * See fs.h for direct operations on filesystems/devices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_set_curdir   - change current directory of current thread by inode</span></span><br><span class="line"><span class="comment"> *    vfs_get_curdir   - retrieve inode of current directory of current thread</span></span><br><span class="line"><span class="comment"> *    vfs_get_root     - get root inode for the filesystem named DEVNAME</span></span><br><span class="line"><span class="comment"> *    vfs_get_devname  - get mounted device name for the filesystem passed in</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_set_curdir</span><span class="params">(struct inode *dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_curdir</span><span class="params">(struct inode **dir_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_root</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct inode **root_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">vfs_get_devname</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer high-level operations on pathnames</span></span><br><span class="line"><span class="comment"> * Because namei may destroy pathnames, these all may too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_open         - Open or create a file. FLAGS/MODE per the syscall.</span></span><br><span class="line"><span class="comment"> *    vfs_close  - Close a inode opened with vfs_open. Does not fail.</span></span><br><span class="line"><span class="comment"> *                 (See vfspath.c for a discussion of why.)</span></span><br><span class="line"><span class="comment"> *    vfs_link         - Create a hard link to a file.</span></span><br><span class="line"><span class="comment"> *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.</span></span><br><span class="line"><span class="comment"> *    vfs_readlink     - Read contents of a symlink into a uio.</span></span><br><span class="line"><span class="comment"> *    vfs_mkdir        - Create a directory. MODE per the syscall.</span></span><br><span class="line"><span class="comment"> *    vfs_unlink       - Delete a file/directory.</span></span><br><span class="line"><span class="comment"> *    vfs_rename       - rename a file.</span></span><br><span class="line"><span class="comment"> *    vfs_chdir  - Change current directory of current thread by name.</span></span><br><span class="line"><span class="comment"> *    vfs_getcwd - Retrieve name of current directory of current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **inode_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_close</span><span class="params">(struct inode *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_link</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_symlink</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_readlink</span><span class="params">(<span class="keyword">char</span> *path, struct iobuf *iob)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_mkdir</span><span class="params">(<span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unlink</span><span class="params">(<span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_rename</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_chdir</span><span class="params">(<span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_getcwd</span><span class="params">(struct iobuf *iob)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer mid-level operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_lookup     - Like VOP_LOOKUP, but takes a full device:path name,</span></span><br><span class="line"><span class="comment"> *                     or a name relative to the current directory, and</span></span><br><span class="line"><span class="comment"> *                     goes to the correct filesystem.</span></span><br><span class="line"><span class="comment"> *    vfs_lookparent - Likewise, for VOP_LOOKPARENT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Both of these may destroy the path passed in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_lookup</span><span class="params">(<span class="keyword">char</span> *path, struct inode **node_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_lookup_parent</span><span class="params">(<span class="keyword">char</span> *path, struct inode **node_store, <span class="keyword">char</span> **endp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Misc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_set_bootfs - Set the filesystem that paths beginning with a</span></span><br><span class="line"><span class="comment"> *                    slash are sent to. If not set, these paths fail</span></span><br><span class="line"><span class="comment"> *                    with ENOENT. The argument should be the device</span></span><br><span class="line"><span class="comment"> *                    name or volume name for the filesystem (such as</span></span><br><span class="line"><span class="comment"> *                    "lhd0:") but need not have the trailing colon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_get_bootfs - return the inode of the bootfs filesystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_add_fs     - Add a hardwired filesystem to the VFS named device</span></span><br><span class="line"><span class="comment"> *                    list. It will be accessible as "devname:". This is</span></span><br><span class="line"><span class="comment"> *                    intended for filesystem-devices like emufs, and</span></span><br><span class="line"><span class="comment"> *                    gizmos like Linux procfs or BSD kernfs, not for</span></span><br><span class="line"><span class="comment"> *                    mounting filesystems on disk devices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_add_dev    - Add a device to the VFS named device list. If</span></span><br><span class="line"><span class="comment"> *                    MOUNTABLE is zero, the device will be accessible</span></span><br><span class="line"><span class="comment"> *                    as "DEVNAME:". If the mountable flag is set, the</span></span><br><span class="line"><span class="comment"> *                    device will be accessible as "DEVNAMEraw:" and</span></span><br><span class="line"><span class="comment"> *                    mountable under the name "DEVNAME". Thus, the</span></span><br><span class="line"><span class="comment"> *                    console, added with MOUNTABLE not set, would be</span></span><br><span class="line"><span class="comment"> *                    accessed by pathname as "con:", and lhd0, added</span></span><br><span class="line"><span class="comment"> *                    with mountable set, would be accessed by</span></span><br><span class="line"><span class="comment"> *                    pathname as "lhd0raw:" and mounted by passing</span></span><br><span class="line"><span class="comment"> *                    "lhd0" to vfs_mount.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_mount      - Attempt to mount a filesystem on a device. The</span></span><br><span class="line"><span class="comment"> *                    device named by DEVNAME will be looked up and</span></span><br><span class="line"><span class="comment"> *                    passed, along with DATA, to the supplied function</span></span><br><span class="line"><span class="comment"> *                    MOUNTFUNC, which should create a struct fs and</span></span><br><span class="line"><span class="comment"> *                    return it in RESULT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_unmount    - Unmount the filesystem presently mounted on the</span></span><br><span class="line"><span class="comment"> *                    specified device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_unmountall - Unmount all mounted filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_set_bootfs</span><span class="params">(<span class="keyword">char</span> *fsname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_bootfs</span><span class="params">(struct inode **node_store)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_add_fs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_add_dev</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct inode *devnode, <span class="keyword">bool</span> mountable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">int</span> (*mountfunc)(struct device *dev, struct fs **fs_store))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unmount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unmount_all</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vfs中更为底层的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="inode接口">inode接口</h6>
<p><code>vfs</code>会涉及到<code>inode</code>结构的操作，该结构是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A struct inode is an abstract representation of a file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is an interface that allows the kernel's filesystem-independent</span></span><br><span class="line"><span class="comment"> * code to interact usefully with multiple sets of filesystem code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Abstract low-level file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: in_info is Filesystem-specific data, in_type is the inode type</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * open_count is managed using VOP_INCOPEN and VOP_DECOPEN by</span></span><br><span class="line"><span class="comment"> * vfs_open() and vfs_close(). Code above the VFS layer should not</span></span><br><span class="line"><span class="comment"> * need to worry about it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 设备结点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="comment">// 对应文件系统中，文件/目录的实际节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;</span><br><span class="line">    <span class="keyword">int</span> ref_count;</span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct inode</code>中存放了<code>info</code>、类型<code>type</code>、引用次数<code>ref_count</code>、打开次数<code>open_count</code>、相关联的文件系统<code>in_fs</code>以及当前结构所对应的操作集合<code>in_ops</code>。该结构与硬盘上对应区域相关联，从而便于对硬盘进行操作。</p>
<p><code>inode_ops</code>成员是对常规文件、目录、设备文件所有操作的一个抽象函数表示。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。可选实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function table for device inodes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// The sfs specific DIR operations correspond to the abstract operations on a inode.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> = &#123;</span></span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_namefile                   = sfs_namefile,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/// The sfs specific FILE operations correspond to the abstract operations on a inode.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> = &#123;</span></span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_tryseek                    = sfs_tryseek,</span><br><span class="line">    .vop_truncate                   = sfs_truncfile,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">dev_node_ops</span> = &#123;</span></span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = dev_open,</span><br><span class="line">    .vop_close                      = dev_close,</span><br><span class="line">    .vop_read                       = dev_read,</span><br><span class="line">    .vop_write                      = dev_write,</span><br><span class="line">    .vop_fstat                      = dev_fstat,</span><br><span class="line">    .vop_ioctl                      = dev_ioctl,</span><br><span class="line">    .vop_gettype                    = dev_gettype,</span><br><span class="line">    .vop_tryseek                    = dev_tryseek,</span><br><span class="line">    .vop_lookup                     = dev_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>inode</code>结构是与文件系统相关的，不同文件系统所实现的<code>inode</code>结构是不同的，它的存在可以让VFS忽略更下一级的文件系统差异，使之注重于提供一个统一的文件系统接口。<code>inode</code>根据其<code>in_info</code>的不同而实现其不同的功能。</p>
<blockquote>
<p>文件系统抽象层VFS提供了file接口、dir接口、inode接口、fs接口以及外设接口。而这些接口在<code>sfs</code>中被具体实现。</p>
</blockquote>
<h5 id="3-Simple-FS-文件系统层-SFS">3) Simple FS 文件系统层(SFS)</h5>
<h6 id="概述">概述</h6>
<p>从<code>VFS</code>向下一层，就是<code>SFS</code>。</p>
<p>ucore内核把所有文件都看作是字节流，任何内部逻辑结构都是专用的，由应用程序负责解释。但是ucore区分文件的物理结构。ucore目前支持如下几种类型的文件：</p>
<ul>
<li>常规文件：文件中包括的内容信息是由应用程序输入。SFS文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节。</li>
<li>目录：包含一系列的entry，每个entry包含文件名和指向与之相关联的索引节点（index node）的指针。目录是按层次结构组织的。</li>
<li>链接文件：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名。</li>
<li>设备文件：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制。可通过设备文件访问外围设备。</li>
<li>管道：管道是进程间通讯的一个基础设施。管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据。</li>
</ul>
<p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。可以有多个文件名可指向一个索引节点。</p>
<h6 id="函数接口与数据结构">函数接口与数据结构</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_sfs_fs</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_sfs_io</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_sfs_fs</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_sfs_io</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_rblock</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_wblock</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_rbuf</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_wbuf</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_sync_super</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_sync_freemap</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_clear_block</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_load_inode</span><span class="params">(struct sfs_fs *sfs, struct inode **node_store, <span class="keyword">uint32_t</span> ino)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_sync</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode* <span class="title">sfs_get_root</span><span class="params">(struct fs *fs)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_unmount</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sfs_cleanup</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_init_read</span><span class="params">(struct device *dev, <span class="keyword">uint32_t</span> blkno, <span class="keyword">void</span> *blk_buffer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_do_mount</span><span class="params">(struct device *dev, struct fs **fs_store)</span></span>;</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>
<p>在<code>SFS</code>中涉及到了两种文件系统结构，分别是<code>fs</code>和<code>sfs_fs</code>。<code>fs</code>结构是我们在上层函数调用中所直接操作的抽象文件系统，而<code>sfs_fs</code>则是在下层函数中所使用的。在原先<code>sfs_fs</code>上抽象出一层<code>fs</code>结构有助于忽略不同文件系统的差异。其实现如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Abstract filesystem. (Or device accessible as a file.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Information:</span></span><br><span class="line"><span class="comment"> *      fs_info   : filesystem-specific data (sfs_fs)</span></span><br><span class="line"><span class="comment"> *      fs_type   : filesystem type</span></span><br><span class="line"><span class="comment"> * Operations:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      fs_sync       - Flush all dirty buffers to disk.</span></span><br><span class="line"><span class="comment"> *      fs_get_root   - Return root inode of filesystem.</span></span><br><span class="line"><span class="comment"> *      fs_unmount    - Attempt unmount of filesystem.</span></span><br><span class="line"><span class="comment"> *      fs_cleanup    - Cleanup of filesystem.???</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * fs_get_root should increment the refcount of the inode returned.</span></span><br><span class="line"><span class="comment"> * It should not ever return NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If fs_unmount returns an error, the filesystem stays mounted, and</span></span><br><span class="line"><span class="comment"> * consequently the struct fs instance should remain valid. On success,</span></span><br><span class="line"><span class="comment"> * however, the filesystem object and all storage associated with the</span></span><br><span class="line"><span class="comment"> * filesystem should have been discarded/released.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span></span><br><span class="line">    &#125; fs_info;                                     <span class="comment">// filesystem-specific data</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                                     <span class="comment">// filesystem type</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);                 <span class="comment">// Flush all dirty buffers to disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="title">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   <span class="comment">// Return root inode of filesystem.</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              <span class="comment">// Attempt unmount of filesystem.</span></span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);             <span class="comment">// Cleanup of filesystem.???</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* filesystem for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>                         <span class="comment">/* on-disk superblock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                             <span class="comment">/* device mounted on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>                         <span class="comment">/* blocks in use are mared 0 */</span></span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                               <span class="comment">/* true if super/freemap modified */</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                               <span class="comment">/* buffer for non-block aligned io */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                             <span class="comment">/* semaphore for fs */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             <span class="comment">/* semaphore for io */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          <span class="comment">/* semaphore for link/unlink and rename */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;                        <span class="comment">/* inode linked-list */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;                        <span class="comment">/* inode hash linked-list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sfs_fs</code>结构中包含了底层设备的超级块<code>superblock</code>、所挂载的设备<code>dev</code>、以及底层设备中用于表示空间分配情况的<code>freemap</code>等。</p>
<h6 id="文件系统布局">文件系统布局</h6>
<p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是 ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 block （4K，与内存 page 大小相等）为基本单位。</p>
<p>SFS文件系统的布局如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+---------+-------------------------------------+</span><br><span class="line">| superblock | root-dir | freemap | Inode / File Data / Dir Data blocks |</span><br><span class="line">+------------+----------+---------+-------------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>第0个块（4K）是超级块（superblock），它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On-disk superblock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> &#123;</span></span><br><span class="line">    <span class="comment">// 超级块结构中包含成员变量魔数magic，内核通过它来检查磁盘镜像是否是合法的 SFS img</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                                 <span class="comment">/* magic number, should be SFS_MAGIC */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* # of blocks in fs */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused_blocks;                         <span class="comment">/* # of unused blocks in fs */</span></span><br><span class="line">    <span class="keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">/* infomation for sfs  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第1个块放了一个root-dir的inode，用来记录根目录的相关信息。root-dir是SFS文件系统的根结点，通过这个root-dir的inode信息就可以定位并查找到根目录下的所有文件信息。</p>
</li>
<li>
<p>从第2个块开始，根据SFS中所有块的数量，用1个bit来表示一个块的占用和未被占用的情况。这个区域称为SFS的freemap区域，这将占用若干个块空间。为了更好地记录和管理freemap区域</p>
</li>
<li>
<p>最后在剩余的磁盘空间中，存放了所有其他目录和文件的inode信息和内容数据信息。需要注意的是虽然inode的大小小于一个块的大小（4096B），但为了实现简单，每个 inode 都占用一个完整的 block。</p>
</li>
</ul>
<h6 id="索引结点">索引结点</h6>
<ul>
<li>
<p>在<code>sfs</code>层面上，<code>inode</code>结构既可表示文件<code>file</code>、目录<code>dir</code>，也可表示设备<code>device</code>。而区分<code>inode</code>结构的操作有两种，一种是其<code>in_info</code>成员变量，另一种是该结构的成员指针<code>in_ops</code>。以下是函数<code>sfs_get_ops</code>的源码，该函数返回某个属性（文件/目录）所对应的<code>inode</code>操作：</p>
<blockquote>
<p>注意，设置inode_ops的操作不止一处，以下代码只作为示例。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_get_ops - return function addr of fs_node_dirops/sfs_node_fileops</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *</span></span><br><span class="line"><span class="class"><span class="title">sfs_get_ops</span>(<span class="title">uint16_t</span> <span class="title">type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SFS_TYPE_DIR:</span><br><span class="line">        <span class="keyword">return</span> &amp;sfs_node_dirops;</span><br><span class="line">    <span class="keyword">case</span> SFS_TYPE_FILE:</span><br><span class="line">        <span class="keyword">return</span> &amp;sfs_node_fileops;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">"invalid file type %d.\n"</span>, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当uCore创建一个<strong>用于存储文件/目录</strong>的<code>inode</code>结构（即该<code>inode</code>结构的<code>in_info</code>成员变量为<code>sfs_inode</code>类型）时，程序会执行函数<code>sfs_create_inode</code>。该函数会将<code>inode</code>结构中的<code>sfs_inode</code>成员与磁盘对应结点<code>sfs_disk_inode</code>相关联，从而使得只凭<code>inode</code>即可操作该结点。</p>
<blockquote>
<p>用于描述设备<code>device</code>的<code>inode</code>会在其他函数中被初始化，不会执行函数<code>sfs_create_inode</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_create_inode - alloc a inode in memroy, and init din/ino/dirty/reclian_count/sem fields in sfs_inode in inode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_create_inode(struct sfs_fs *sfs, struct sfs_disk_inode *din, <span class="keyword">uint32_t</span> ino, struct inode **node_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = alloc_inode(sfs_inode)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        vop_init(node, sfs_get_ops(din-&gt;type), info2fs(sfs, sfs));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> = <span class="title">vop_info</span>(<span class="title">node</span>, <span class="title">sfs_inode</span>);</span></span><br><span class="line">        <span class="built_in">sin</span>-&gt;din = din, <span class="built_in">sin</span>-&gt;ino = ino, <span class="built_in">sin</span>-&gt;dirty = <span class="number">0</span>, <span class="built_in">sin</span>-&gt;reclaim_count = <span class="number">1</span>;</span><br><span class="line">        sem_init(&amp;(<span class="built_in">sin</span>-&gt;sem), <span class="number">1</span>);</span><br><span class="line">        *node_store = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>磁盘索引结点</strong>——保存在硬盘中的索引结点</p>
<p><code>sfs_disk_inode</code>结构记录了文件或目录的内容存储的索引信息，该数据结构在硬盘里储存，需要时读入内存。<code>type</code>成员表明该结构是目录类型还是文件类型，又或者是链接<code>link</code>类型。如果<code>inode</code>表示的是文件，则成员变量<code>direct[]</code>直接指向了保存文件内容数据的数据块索引值。<code>indirect</code>指向的是间接数据块，此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFS_TYPE_INVAL                              0       <span class="comment">/* Should not appear on disk */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFS_TYPE_FILE                               1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFS_TYPE_DIR                                2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFS_TYPE_LINK                               3</span></span><br><span class="line"><span class="comment">/* inode (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                  <span class="comment">/* size of the file (in bytes) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                  <span class="comment">/* one of SYS_TYPE_* above */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                                <span class="comment">/* # of hard links to this file */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* # of blocks */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="comment">/* direct blocks */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                              <span class="comment">/* indirect blocks */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于普通文件，索引值指向的 block 中保存的是文件中的数据。而对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* file name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>内存索引结点</strong>——保存在内存中的索引结点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SFS中的内存<code>sfs_inode</code>除了包含SFS的硬盘<code>sfs_disk_inode</code>信息，而且还增加了其他一些信息。这些信息用于判断相关硬盘位置是否改写、互斥操作、回收和快速地定位等作用。</p>
<blockquote>
<p>需要注意的是，一个内存<code>sfs_inode</code>是在打开一个文件后才创建的，如果关机则相关信息都会消失。而硬盘<code>sfs_disk_inode</code>的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p>
</blockquote>
</li>
<li>
<p><strong>文件结点</strong>——用于<strong>指向磁盘索引结点</strong>的结点，其结构如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* file name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>文件结点中的<code>name</code>表示当前文件的文件名，而其<code>ino</code>成员则指向了<code>sfs_disk_inode</code>磁盘索引结点。上一层的目录索引结点则会指向各个下层的文件结点。</p>
<blockquote>
<p>将文件结点和磁盘索引结点分开，有助于<strong>硬链接</strong>的实现。</p>
</blockquote>
</li>
<li>
<p>同时，为了方便实现上面提到的多级数据的访问以及目录中 entry 的操作，对于<code>inode</code>，SFS实现了一些辅助的函数，它们分别是</p>
<blockquote>
<p>备注：这些函数的功能最好在阅读源码时详细了解。</p>
</blockquote>
<ul>
<li>
<p><code>sfs_bmap_load_nolock</code></p>
<blockquote>
<p>将对应<code>sfs_inode</code>的第 <code>index</code> 个索引指向的 block 的索引值取出，并存到相应的指针指向的单元（<code>ino_store</code>）。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果<code>index == din-&gt;blocks</code>, 则将会为<code>inode</code>增长一个 block。并标记 <code>inode</code> 为 dirty</p>
</blockquote>
<ul>
<li>
<p><code>sfs_bmap_truncate_nolock</code></p>
<blockquote>
<p>将多级数据索引表的最后一个 entry 释放掉。该函数可以认为是<code>sfs_bmap_load_nolock</code>中，<code>index == inode-&gt;blocks</code>的逆操作。</p>
</blockquote>
</li>
<li>
<p><code>sfs_dirent_read_nolock</code></p>
<blockquote>
<p>将目录的第 slot 个 entry 读取到指定的内存空间。</p>
</blockquote>
</li>
<li>
<p><code>sfs_dirent_search_nolock</code></p>
<blockquote>
<p>该函数是常用的查找函数，函数会在目录下查找 name，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号（也是磁盘编号），和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>需要注意的是，这些后缀为<code>nolock</code>的函数，只能在已经获得相应<code>inode</code>的<code>semaphore</code>才能调用。</p>
</blockquote>
</li>
</ul>
<h5 id="4-外设接口层-I-O设备">4) 外设接口层(I/O设备)</h5>
<ul>
<li>
<p>在底层一点就是I/O设备的相关实现，例如结构体<code>device</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dop_open(dev, open_flags)           ((dev)-&gt;d_open(dev, open_flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dop_close(dev)                      ((dev)-&gt;d_close(dev))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dop_io(dev, iob, write)             ((dev)-&gt;d_io(dev, iob, write))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dop_ioctl(dev, op, data)            ((dev)-&gt;d_ioctl(dev, op, data))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;</span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;</span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体支持对块设备、字符设备的表示，完成对设备的基本操作。</p>
<p>不同底层设备所调用的函数方法是不同的，例如以下两个函数就是对不同设备<code>device</code>结构体的初始化</p>
<blockquote>
<p>需要注意的是，常用的<code>stdin</code>和<code>stdout</code>在uCore中是作为输入输出设备，与<code>disk0</code>处于同一个层次。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stdin_device_init(struct device *dev) &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdin_open;</span><br><span class="line">    dev-&gt;d_close = stdin_close;</span><br><span class="line">    dev-&gt;d_io = stdin_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdin_ioctl;</span><br><span class="line"></span><br><span class="line">    p_rpos = p_wpos = <span class="number">0</span>;</span><br><span class="line">    wait_queue_init(wait_queue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">disk0_device_init(struct device *dev) &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(DISK0_BLKSIZE % SECTSIZE == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ide_device_valid(DISK0_DEV_NO)) &#123;</span><br><span class="line">        panic(<span class="string">"disk0 device isn't available.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;d_blocks = ide_device_size(DISK0_DEV_NO) / DISK0_BLK_NSECT;</span><br><span class="line">    dev-&gt;d_blocksize = DISK0_BLKSIZE;</span><br><span class="line">    dev-&gt;d_open = disk0_open;</span><br><span class="line">    dev-&gt;d_close = disk0_close;</span><br><span class="line">    dev-&gt;d_io = disk0_io;</span><br><span class="line">    dev-&gt;d_ioctl = disk0_ioctl;</span><br><span class="line">    sem_init(&amp;(disk0_sem), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static_assert</span>(DISK0_BUFSIZE % DISK0_BLKSIZE == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((disk0_buffer = kmalloc(DISK0_BUFSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">"disk0 alloc buffer failed.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结构体<code>device</code>只表示了一个设备所能使用的功能，我们需要一个数据结构用于将<code>device</code>和<code>fs</code>关联。同时，为了将连接的所有设备连接在一起，uCore定义了一个链表，通过该链表即可访问到所有设备。而这就是定义<code>vfs_dev_t</code>结构体的目的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// device info entry in vdev_list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;</span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2vdev(le, member)                         \</span></span><br><span class="line">  to_struct((le), <span class="keyword">vfs_dev_t</span>, member)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> vdev_list;     <span class="comment">// device info list in vfs layer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> vdev_list_sem;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>stdin</code>和<code>stdout</code>在uCore中被视为标准输入输出<strong>设备</strong>，与<code>disk0</code>一样，共同被VFS所管理。</p>
<p>在内核中，uCore并不会主动让每个进程<strong>打开</strong><code>stdin</code>和<code>stdout</code>，但用户程序仍然可以使用诸如<code>write(1, buf, size)</code>这样的语句。这是因为生成用户可执行文件时，<code>umain</code>函数将会被链接入用户的主程序，而该函数中就有针对<code>stdin</code>和<code>stdout</code>相关文件描述符的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = initfd(<span class="number">0</span>, <span class="string">"stdin:"</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        warn(<span class="string">"open &lt;stdin&gt; failed: %e.\n"</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fd = initfd(<span class="number">1</span>, <span class="string">"stdout:"</span>, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        warn(<span class="string">"open &lt;stdout&gt; failed: %e.\n"</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = main(argc, argv);</span><br><span class="line">    <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>再低一个层次就涉及到了硬盘驱动，驱动直接和硬盘I/O接口打交道。例如以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">ide_read_secs(<span class="keyword">unsigned</span> short ideno, <span class="keyword">uint32_t</span> secno, <span class="keyword">void</span> *dst, <span class="keyword">size_t</span> nsecs) &#123;</span><br><span class="line">    assert(nsecs &lt;= MAX_NSECS &amp;&amp; VALID_IDE(ideno));</span><br><span class="line">    assert(secno &lt; MAX_DISK_NSECS &amp;&amp; secno + nsecs &lt;= MAX_DISK_NSECS);</span><br><span class="line">    <span class="keyword">unsigned</span> short iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);</span><br><span class="line"></span><br><span class="line">    ide_wait_ready(iobase, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate interrupt</span></span><br><span class="line">    outb(ioctrl + ISA_CTRL, <span class="number">0</span>);</span><br><span class="line">    outb(iobase + ISA_SECCNT, nsecs);</span><br><span class="line">    outb(iobase + ISA_SECTOR, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_CYL_LO, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_CYL_HI, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_SDH, <span class="number">0xE0</span> | ((ideno &amp; <span class="number">1</span>) &lt;&lt; <span class="number">4</span>) | ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>));</span><br><span class="line">    outb(iobase + ISA_COMMAND, IDE_CMD_READ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; nsecs &gt; <span class="number">0</span>; nsecs --, dst += SECTSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = ide_wait_ready(iobase, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        insl(iobase, dst, SECTSIZE / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="c-文件系统挂载流程">c. 文件系统挂载流程</h4>
<p>一个文件系统在使用前，需要将其挂载至内核中。在uCore里，硬盘<code>disk0</code>的挂载流程如下：</p>
<ul>
<li>
<p>首先，在<code>fs_init</code>函数中执行<code>init_device(disk0)</code>，初始化对应<code>device</code>结构并将其连接至<code>vdev_list</code>链表中：</p>
</li>
<li>
<p>之后，在<code>fs_init</code>函数中执行<code>sfs_init() -&gt; sfs_mount(&quot;disk0&quot;)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vfs_mount(devname, sfs_do_mount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，<code>sfs_mount</code>会调用<code>vfs_mount</code>，在<code>vfs</code>的挂载接口中调用<code>sfs</code>自己的<code>sfs_do_mount</code>挂载函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfs_mount - Mount a filesystem. Once we've found the device, call MOUNTFUNC to</span></span><br><span class="line"><span class="comment"> *             set up the filesystem and hand back a struct fs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The DATA argument is passed through unchanged to MOUNTFUNC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">vfs_mount(<span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">int</span> (*mountfunc)(struct device *dev, struct fs **fs_store)) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_vdev_list();</span><br><span class="line">    <span class="comment">// 在设备链表中获取当前待挂载的设备</span></span><br><span class="line">    <span class="keyword">vfs_dev_t</span> *vdev;</span><br><span class="line">    <span class="keyword">if</span> ((ret = find_mount(devname, &amp;vdev)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vdev-&gt;fs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -E_BUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(vdev-&gt;devname != <span class="literal">NULL</span> &amp;&amp; vdev-&gt;mountable);</span><br><span class="line">   <span class="comment">// 执行特定文件系统的挂载程序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = <span class="title">vop_info</span>(<span class="title">vdev</span>-&gt;<span class="title">devnode</span>, <span class="title">device</span>);</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = mountfunc(dev, &amp;(vdev-&gt;fs))) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(vdev-&gt;fs != <span class="literal">NULL</span>);</span><br><span class="line">        cprintf(<span class="string">"vfs: mount %s.\n"</span>, vdev-&gt;devname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    unlock_vdev_list();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>sfs_do_mount</code>挂载函数会执行以下几个操作</p>
<ul>
<li>从待挂载设备中读取超级块，并验证超级块中，魔数与总块数是否存在错误</li>
<li>初始化哈希链表</li>
<li>从待挂载设备中读入<code>freemap</code>并测试其正确性</li>
<li>设置<code>fs</code>结构的相关信息，并在函数最后将该信息设置为传入的<code>device</code>结构体中的<code>fs</code>成员变量</li>
</ul>
</li>
</ul>
<h4 id="d-文件打开流程">d. 文件打开流程</h4>
<ul>
<li>
<p>用户进程调用<code>open</code>函数时，通过系统中断调用内核中的<code>sysfile_open</code>函数，并进一步调用<code>file_open</code>函数。在<code>file_open</code>函数中，程序主要做了以下几个操作：</p>
<ul>
<li>在当前进程的文件管理结构<code>filesp</code>中，获取一个空闲的<code>file</code>对象。</li>
<li>调用<code>vfs_open</code>函数，并存储该函数返回的<code>inode</code>结构</li>
<li>根据上一步返回的<code>inode</code>，设置<code>file</code>对象的属性。如果打开方式是<code>append</code>，则还会设置<code>file</code>的<code>pos</code>成员为当前文件的大小。</li>
<li>最后返回<code>file-&gt;fd</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open file</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">file_open(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">bool</span> readable = <span class="number">0</span>, writable = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY: readable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY: writable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        readable = writable = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = fd_array_alloc(NO_FD, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_open(path, open_flags, &amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">        fd_array_free(file);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_APPEND) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">stat</span>, *<span class="title">stat</span> = &amp;__<span class="title">stat</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_fstat(node, stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vfs_close(node);</span><br><span class="line">            fd_array_free(file);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        file-&gt;pos = stat-&gt;st_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;node = node;</span><br><span class="line">    file-&gt;readable = readable;</span><br><span class="line">    file-&gt;writable = writable;</span><br><span class="line">    fd_array_open(file);</span><br><span class="line">    <span class="keyword">return</span> file-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>vfs_open</code>函数主要完成以下操作：</p>
<ul>
<li>
<p>调用<code>vfs_lookup</code>搜索给出的路径，判断是否存在该文件。如果存在，则<code>vfs_lookup</code>函数返回该文件所对应的<code>inode</code>节点至当前函数<code>vfs_open</code>中的局部变量<code>node</code>。</p>
</li>
<li>
<p>如果给出的路径不存在，即文件不存在，则根据传入的flag，选择调用<code>vop_create</code>创建新文件或直接返回错误信息。</p>
<blockquote>
<p><code>vop_creat</code>所对应的<code>SFS</code>创建文件函数似乎没实现？</p>
</blockquote>
</li>
<li>
<p>执行到此步时，当前函数中的局部变量<code>node</code>一定非空，此时进一步调用<code>vop_open</code>函数打开文件。</p>
<blockquote>
<p>SFS中，<code>vop_open</code>所对应的<code>sfs_openfile</code>不执行任何操作，但该接口仍然需要保留。</p>
</blockquote>
</li>
<li>
<p>如果文件打开正常，则根据当前函数传入的<code>open_flags</code>参数来判断是否需要将当前文件截断（truncate）至0（即<strong>清空</strong>）。如果需要截断，则执行<code>vop_truncate</code>函数。最后函数返回。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open file in vfs, get/create inode for file with filename path.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">vfs_open(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">bool</span> can_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        can_write = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!can_write) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> excl = (open_flags &amp; O_EXCL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> create = (open_flags &amp; O_CREAT) != <span class="number">0</span>;</span><br><span class="line">    ret = vfs_lookup(path, &amp;node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-16</span> &amp;&amp; (create)) &#123;</span><br><span class="line">            <span class="keyword">char</span> *name;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = vfs_lookup_parent(path, &amp;dir, &amp;name)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = vop_create(dir, name, excl, &amp;node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (excl &amp;&amp; create) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(node != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = vop_open(node, open_flags)) != <span class="number">0</span>) &#123;</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vop_open_inc(node);</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC || create) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_truncate(node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vop_open_dec(node);</span><br><span class="line">            vop_ref_dec(node);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>文件打开操作到这里就差不多结束了，不过我们可以探讨一下文件是如何进行路径查找以及清空当前文件的。</p>
<ul>
<li>
<p><code>vfs_lookup</code>用于查找传入的路径，并返回其对应的<code>inode</code>结点。</p>
<ul>
<li>
<p>该函数首先调用<code>get_device</code>函数获取设备的<code>inode</code>结点。在<code>get_device</code>函数中，程序会分析传入的<code>path</code>结构并执行不同的函数。传入的<code>path</code>与对应的操作有以下三种，分别是</p>
<ul>
<li>
<p><code>directory/filename</code>： 相对路径。此时会进一步调用<code>vfs_get_curdir</code>，并最终获取到当前进程的工作路径并返回对应的<code>inode</code>。</p>
</li>
<li>
<p><code>/directory/filename</code>或者<code>:directory/filename</code>：无设备指定的绝对路径。</p>
<ul>
<li>
<p>若路径为<code>/directory/filename</code>，此时返回<code>bootfs</code>根目录所对应的<code>inode</code>。</p>
<blockquote>
<p><code>bootfs</code>是内核启动盘所对应的文件系统。</p>
</blockquote>
</li>
<li>
<p>若路径为<code>:/directory/filename</code>，则获取当前进程工作目录所对应的文件系统根目录，并返回其<code>inode</code>数据。</p>
</li>
</ul>
</li>
<li>
<p><code>device:directory/filename</code>或者<code>device:/directory/filename</code>： 指定设备的绝对路径。返回所指定设备根目录的对应<code>inode</code>。</p>
</li>
</ul>
<blockquote>
<p>总的来说，<code>get_device</code>返回的是一个目录<code>inode</code>结点。</p>
</blockquote>
<p><code>get_device</code>函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_device- Common code to pull the device name, if any, off the front of a</span></span><br><span class="line"><span class="comment"> *             path and choose the inode to begin the name lookup relative to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_device(<span class="keyword">char</span> *path, <span class="keyword">char</span> **subpath, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">int</span> i, slash = <span class="number">-1</span>, colon = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; path[i] != <span class="string">'\0'</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">':'</span>) &#123; colon = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">'/'</span>) &#123; slash = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (colon &lt; <span class="number">0</span> &amp;&amp; slash != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* *</span></span><br><span class="line"><span class="comment">         * No colon before a slash, so no device name specified, and the slash isn't leading</span></span><br><span class="line"><span class="comment">         * or is also absent, so this is a relative path or just a bare filename. Start from</span></span><br><span class="line"><span class="comment">         * the current directory, and use the whole thing as the subpath.</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        *subpath = path;</span><br><span class="line">        <span class="keyword">return</span> vfs_get_curdir(node_store);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (colon &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* device:path - get root of device's filesystem */</span></span><br><span class="line">        path[colon] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* device:/path - skip slash, treat as device:path */</span></span><br><span class="line">        <span class="keyword">while</span> (path[++ colon] == <span class="string">'/'</span>);</span><br><span class="line">          *subpath = path + colon;</span><br><span class="line">        <span class="keyword">return</span> vfs_get_root(path, node_store);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * we have either /path or :path</span></span><br><span class="line"><span class="comment">     * /path is a path relative to the root of the "boot filesystem"</span></span><br><span class="line"><span class="comment">     * :path is a path relative to the root of the current filesystem</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (*path == <span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">if</span> ((ret = vfs_get_bootfs(node_store)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(*path == <span class="string">':'</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = vfs_get_curdir(&amp;node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="comment">/* The current directory may not be a device, so it must have a fs. */</span></span><br><span class="line">        assert(node-&gt;in_fs != <span class="literal">NULL</span>);</span><br><span class="line">        *node_store = fsop_get_root(node-&gt;in_fs);</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ///... or :/... */</span></span><br><span class="line">    <span class="keyword">while</span> (*(++ path) == <span class="string">'/'</span>);</span><br><span class="line">    *subpath = path;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后，该函数调用<code>vop_lookup</code>(实际是<code>sfs_lookup</code>)来获取目的结点。</p>
</li>
</ul>
</li>
<li>
<p><code>vop_truncate</code>函数（即<code>sfs_truncfile</code>函数）主要完成以下操作</p>
<ul>
<li>
<p>获取该文件原先占用磁盘的块数<code>nblks</code>，以及”截断“后占用的块数<code>tblks</code>。</p>
<blockquote>
<p>注意这个截断操作可以向后截断（即缩小文件大小），也可向前截断（即增大文件大小）。这里的”截断“实质上是调整文件尺寸的操作。</p>
</blockquote>
</li>
<li>
<p>如果原先占用的磁盘块数比目的块数大，则循环调用<code>sfs_bmap_load_nolock</code>函数，单次添加一个块</p>
</li>
<li>
<p>如果原先占用的磁盘块数比目的块数小，则循环调用<code>sfs_bmap_truncate_nolock</code>函数，单次销毁一个块。</p>
</li>
</ul>
<blockquote>
<p>以上两种操作都需要设置<code>dirtybit</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="e-文件读取流程">e. 文件读取流程</h4>
<ul>
<li>
<p>用户进程调用<code>read</code>函数时，通过系统中断最终调用<code>sysfile_read</code>。在该函数中，程序主要完成以下几个操作</p>
<ul>
<li>测试当前待读取的文件是否存在<strong>读权限</strong></li>
<li>在内核中创建一块缓冲区。</li>
<li>循环执行<code>file_read</code>函数读取数据至缓冲区中，并将该缓冲区中的数据复制至用户内存（即传入<code>sysfile_read</code>的base指针所指向的内存）</li>
</ul>
</li>
<li>
<p><code>file_read</code>函数是内核提供的一项文件读取函数。在这个函数中会涉及到IO缓冲区的数据结构<code>iobuf</code>，其结构如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * iobuf is a buffer Rd/Wr status record</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *io_base;     <span class="comment">// IO缓冲区的内存地址</span></span><br><span class="line">    <span class="keyword">off_t</span> io_offset;   <span class="comment">// 当前读取/写入的地址</span></span><br><span class="line">    <span class="keyword">size_t</span> io_len;     <span class="comment">// 缓冲区的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> io_resid;   <span class="comment">// 剩余尚未读取/写入的内存空间.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，程序会先初始化一个IO缓冲区，并执行<code>vop_read</code>函数将数据读取至缓冲区中。而<code>vop_read</code>函数会进一步调用<code>sfs_io</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    *copied_store = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ret = fd2file(fd, &amp;file)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;readable)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    fd_array_acquire(file);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> __<span class="title">iob</span>, *<span class="title">iob</span> = <span class="title">iobuf_init</span>(&amp;__<span class="title">iob</span>, <span class="title">base</span>, <span class="title">len</span>, <span class="title">file</span>-&gt;<span class="title">pos</span>);</span></span><br><span class="line">    ret = vop_read(file-&gt;node, iob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> copied = iobuf_used(iob);</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;status == FD_OPENED)</span><br><span class="line">        file-&gt;pos += copied;</span><br><span class="line">    *copied_store = copied;</span><br><span class="line">    fd_array_release(file);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>sfs_io</code>函数是<code>sfs_io_nolock</code>函数的<code>wrapper</code>，该函数将进一步调用<code>sfs_io_nolock</code>。</p>
<p>这里存在对缓冲区数据的一个跳过，如果当前缓冲区中存在一些数据尚未被读取或写入，则在下一次写入和读取时则会跳过该部分的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_io - Rd/Wr file. the wrapper of sfs_io_nolock</span></span><br><span class="line"><span class="comment">            with lock protect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">sfs_io(struct inode *node, struct iobuf *iob, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> = <span class="title">fsop_info</span>(<span class="title">vop_fs</span>(<span class="title">node</span>), <span class="title">sfs</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> = <span class="title">vop_info</span>(<span class="title">node</span>, <span class="title">sfs_inode</span>);</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> alen = iob-&gt;io_resid;</span><br><span class="line">        ret = sfs_io_nolock(sfs, <span class="built_in">sin</span>, iob-&gt;io_base, iob-&gt;io_offset, &amp;alen, write);</span><br><span class="line">        <span class="comment">// 如果当前缓冲区中存在尚未读取/写入的数据</span></span><br><span class="line">        <span class="comment">// 则跳过该部分数据，写入/读取至该块数据的下一个地址处</span></span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            iobuf_skip(iob, alen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_io_nolock</code>函数将在练习1中详细讲解。</p>
</li>
</ul>
<h4 id="f-文件写入流程">f. 文件写入流程</h4>
<p>文件写入流程与文件读取几乎一模一样。文件写入的执行流程是</p>
<p><code>sysfile_write -&gt; file_write -&gt; vop_write -&gt; sfs_io -&gt; ...</code></p>
<p>故再此不再赘述</p>
<h4 id="g-文件关闭流程">g. 文件关闭流程</h4>
<ul>
<li>
<p>首先<code>sysfile_close</code>函数直接调用<code>file_close</code>函数，并在内部调用<code>fd_array_close</code>函数，使得当前<code>file</code>在<code>files_struct</code>中被关闭。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// close file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_close</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = fd2file(fd, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_array_close(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>fd_array_close</code>函数中，如果该文件的打开次数为0，则调用<code>fd_array_free</code>将该文件所占用的资源释放</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd_array_close - file's open_count--; if file's open_count-- == 0 , then call fd_array_free to free this file item</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fd_array_close(struct file *file) &#123;</span><br><span class="line">    assert(file-&gt;status == FD_OPENED);</span><br><span class="line">    assert(fopen_count(file) &gt; <span class="number">0</span>);</span><br><span class="line">    file-&gt;status = FD_CLOSED;</span><br><span class="line">    <span class="keyword">if</span> (fopen_count_dec(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        fd_array_free(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>而<code>fd_array_free</code>函数会进一步调用<code>vfs_close</code>。并在内部调用<code>inode_ref_dec</code>和<code>inode_open_dec</code>以递减该文件的引用次数和打开次数。</p>
<ul>
<li>当<strong>引用次数</strong>递减为0时，<code>inode_ref_dec</code>内部会调用<code>vop_reclaim</code>（即<code>sfs_reclaim</code>）来释放对应<code>inode</code>结构所涉及的所有数据。</li>
<li>当<strong>打开次数</strong>递减为0时，<code>inode_open_dec</code>内部会调用<code>vop_close</code>（即<code>sfs_close</code>）来将相关<code>inode</code>写入至磁盘中，并释放结构。</li>
</ul>
<blockquote>
<p>这两个函数对inode的操作稍微有一点点差别，请结合源代码详细理解。</p>
</blockquote>
<blockquote>
<p>不再详细向下写了，内容太多实在写不完了。。。。</p>
</blockquote>
</li>
</ul>
<h2 id="练习解答">练习解答</h2>
<h3 id="0-练习0">0) 练习0</h3>
<blockquote>
<p>填写已有实验</p>
</blockquote>
<p>本次的练习0无需修改其他代码，只要把原先的地方填入lab8代码中即可。</p>
<h3 id="1-练习1">1) 练习1</h3>
<blockquote>
<p><strong>完成读文件操作的实现</strong></p>
<p>首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolock读文件中数据的实现代码。</p>
</blockquote>
<p>文件的处理流程请阅读上文<a href="#9-uCore%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">uCore文件系统实现</a></p>
<p>当进行文件读取/写入操作时，最终uCore都会执行到<code>sfs_io_nolock</code>函数。在该函数中，我们要完成对设备上基础块数据的读取与写入。</p>
<p>在进行读取/写入前，我们需要先将数据与基础块对齐，以便于使用<code>sfs_block_op</code>函数来操作基础块，提高读取/写入效率。</p>
<p>但一旦将数据对齐后会存在一个问题：</p>
<ul>
<li>
<p>待操作数据的前一小部分有可能在最前的一个基础块的末尾位置</p>
</li>
<li>
<p>待操作数据的后一小部分有可能在最后的一个基础块的起始位置</p>
</li>
</ul>
<p>我们需要分别对这<strong>第一</strong>和<strong>最后</strong>这两个位置的基础块进行读写/写入，因为<strong>这两个位置的基础块所涉及到的数据都是部分的</strong>。而中间的数据由于已经对齐好基础块了，所以可以直接调用<code>sfs_block_op</code>来读取/写入数据。以下是相关操作的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * sfs_io_nolock - Rd/Wr a file contentfrom offset position to offset+ length  disk blocks&lt;--&gt;buffer (in memroy)</span></span><br><span class="line"><span class="comment"> * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @buf:      the buffer Rd/Wr</span></span><br><span class="line"><span class="comment"> * @offset:   the offset of file</span></span><br><span class="line"><span class="comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span></span><br><span class="line"><span class="comment"> * @write:    BOOL, 0 read, 1 write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_io_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> = <span class="title">sin</span>-&gt;<span class="title">din</span>;</span></span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line">  <span class="comment">// calculate the Rd/Wr end position</span></span><br><span class="line">    <span class="comment">// 计算缓冲区读取/写入的终止位置</span></span><br><span class="line">    <span class="keyword">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="comment">// 如果偏移与终止位置相同，及欲读取/写入0字节的数据</span></span><br><span class="line">    <span class="keyword">if</span> (offset == endpos) &#123;</span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE)</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="comment">// 如果是读取数据，并冲区中剩余的数据超出一个硬盘节点的数据大小</span></span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size) &#123;</span><br><span class="line">            <span class="comment">// 直接返回，读取失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size)</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据不同的执行函数，设置对应的函数指针</span></span><br><span class="line">    <span class="keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="comment">// The NO. of Rd/Wr begin block</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="comment">// The size of Rd/Wr blocks</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * (1) If offset isn't aligned with the first block, Rd/Wr some content from offset to the end of the first block</span></span><br><span class="line"><span class="comment">   *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">   *               Rd/Wr size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset)</span></span><br><span class="line"><span class="comment">   * (2) Rd/Wr aligned blocks</span></span><br><span class="line"><span class="comment">   *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_block_op</span></span><br><span class="line"><span class="comment">     * (3) If end position isn't aligned with the last block, Rd/Wr some content from begin to the (endpos % SFS_BLKSIZE) of the last block</span></span><br><span class="line"><span class="comment">   *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="comment">// 对齐偏移。如果偏移没有对齐第一个基础块，则多读取/写入第一个基础块的末尾数据</span></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="comment">// 获取第一个基础块所对应的block的编号`ino`</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">// 通过上一步取出的`ino`，读取/写入一部分第一个基础块的末尾数据</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环读取/写入对齐好的数据</span></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取inode对应的基础块编号</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">// 单次读取/写入一基础块的数据</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        alen += size, buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果末尾位置没有与最后一个基础块对齐，则多读取/写入一点末尾基础块的数据</span></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给出设计实现”UNIX的PIPE机制“的概要设方案</p>
</blockquote>
<ul>
<li>PIPE管道机制是进程间通信的较为重要的一种方式。在VFS中，最简单的做法就是在磁盘上建立一块pipe缓冲文件<code>pipe_tmp</code>。之后，当打开了<code>pipe_tmp</code>文件的某进程fork出子进程后，父子进程就可以通过读写同一文件来实现进程间通信。</li>
<li>但实际上，上述的进程间通信是十分低效的，因为需要调用多个函数来完成文件读写，同时硬盘的读写速率也远远小于内存。由于用户与实际的文件系统间由虚拟文件系统VFS调控，因此我们可以在内存中根据文件系统规范，建立虚拟pipe缓冲区域文件来代替磁盘上的缓冲文件，这样便可大大提高通信速率。</li>
</ul>
<h3 id="2-练习2">2) 练习2</h3>
<blockquote>
<p><strong>完成基于文件系统的执行程序机制的实现</strong></p>
</blockquote>
<p>基于文件系统的执行程序机制，有几部分地方需要添加代码，分别是<code>alloc_proc</code>、<code>do_fork</code>、<code>load_icode</code>三个函数。</p>
<ul>
<li>
<p><code>alloc_proc</code></p>
<ul>
<li>
<p>这个函数需要添加的内容最少，只需多补充一个<code>struct files_struct *filesp</code>的初始化即可</p>
</li>
<li>
<p>修改后的源码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_proc</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Lab7内容</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//LAB8:EXERCISE2 YOUR CODE HINT:need add some code to init fs in proc_struct, ...</span></span><br><span class="line">        <span class="comment">// LAB8 添加一个filesp指针的初始化</span></span><br><span class="line">        proc-&gt;filesp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>do_fork</code></p>
<ul>
<li>
<p>fork机制在原先lab7的基础上，多了<code>file_struct</code>结构的复制操作与执行失败时的重置操作。</p>
<p>这两部操作分别需要调用<code>copy_files</code>和<code>put_files</code>函数</p>
</li>
<li>
<p>修改后的源码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LAB8:EXERCISE2 YOUR CODE  HINT:how to copy the fs in parent's proc_struct?</span></span><br><span class="line">    <span class="comment">// LAB8 将当前进程的fs复制到fork出的进程中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_files(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        set_links(proc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  <span class="comment">// LAB8 如果复制失败，则需要重置原先的操作</span></span><br><span class="line">bad_fork_cleanup_fs:  <span class="comment">//for LAB8</span></span><br><span class="line">    put_files(proc);</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>load_icode</code>函数可以在lab7原先的基础上进行修改，不需要从0开发。</p>
<ul>
<li>
<p>原先lab7源码中，读取可执行文件是直接读取内存的，但在这里需要使用函数<code>load_icode_read</code>来从文件系统中读取<code>ELF header</code>以及各个段的数据。</p>
</li>
<li>
<p>原先Lab7的<code>load_icode</code>函数中并没有对<code>execve</code>所执行的程序传入参数，而我们需要在lab8中补充这个实现。</p>
</li>
<li>
<p>补充后的源码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load_icode -  called by sys_exec--&gt;do_execve</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">load_icode(<span class="keyword">int</span> fd, <span class="keyword">int</span> argc, <span class="keyword">char</span> **kargv) &#123;</span><br><span class="line">    <span class="comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process's memory? how to setup argc/argv?</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *  mm_create        - create a mm</span></span><br><span class="line"><span class="comment">     *  setup_pgdir      - setup pgdir in mm</span></span><br><span class="line"><span class="comment">     *  load_icode_read  - read raw data content of program file</span></span><br><span class="line"><span class="comment">     *  mm_map           - build new vma</span></span><br><span class="line"><span class="comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span></span><br><span class="line"><span class="comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">/* (1) create a new mm for current process</span></span><br><span class="line"><span class="comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line"><span class="comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span></span><br><span class="line"><span class="comment">     *    (3.1) read raw data content in file and resolve elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span></span><br><span class="line"><span class="comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span></span><br><span class="line"><span class="comment">     *          and copy them into the new allocated pages</span></span><br><span class="line"><span class="comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span></span><br><span class="line"><span class="comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span></span><br><span class="line"><span class="comment">     * (5) setup current process's mm, cr3, reset pgidr (using lcr3 MARCO)</span></span><br><span class="line"><span class="comment">     * (6) setup uargc and uargv in user stacks</span></span><br><span class="line"><span class="comment">     * (7) setup trapframe for user environment</span></span><br><span class="line"><span class="comment">     * (8) if up steps failed, you should cleanup the env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assert(argc &gt;= <span class="number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">"load_icode: current-&gt;mm must be empty.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">// 创建proc的内存管理结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">// LAB8 这里要从文件中读取ELF header，而不是Lab7中的内存了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> = &amp;__<span class="title">elf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(struct elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断读取入的elf header是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据每一段的大小和基地址来分配不同的内存空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> = &amp;__<span class="title">ph</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm, phnum;</span><br><span class="line">    <span class="keyword">for</span> (phnum = <span class="number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123;</span><br><span class="line">        <span class="comment">// LAB8 从文件特定偏移处读取每个段的详细信息（包括大小、基地址等等）</span></span><br><span class="line">        <span class="keyword">off_t</span> phoff = elf-&gt;e_phoff + <span class="keyword">sizeof</span>(struct proghdr) * phnum;</span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(struct proghdr), phoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="comment">// 为当前段分配内存空间</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">off_t</span> offset = ph-&gt;p_offset;</span><br><span class="line">        <span class="keyword">size_t</span> off, size;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 设置该内存所对应的页表项</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// LAB8 读取elf对应段内的数据并写入至该内存中</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="comment">// 对于段中当前页中剩余的空间（复制elf数据后剩下的空间），将其置为0</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于段中剩余页中的空间（复制elf数据后的多余页面），将其置为0</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭读取的ELF</span></span><br><span class="line">    sysfile_close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置栈内存</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    <span class="comment">// 设置CR3页表相关寄存器</span></span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setup argc, argv</span></span><br><span class="line">    <span class="comment">// LAB8 设置execve所启动的程序参数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> argv_size=<span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">    <span class="comment">// 直接将传入的参数压入至新栈的底部</span></span><br><span class="line">    <span class="keyword">char</span>** uargv=(<span class="keyword">char</span> **)(stacktop  - argc * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line"></span><br><span class="line">    argv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">        uargv[i] = <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">        argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stacktop = (<span class="keyword">uintptr_t</span>)uargv - <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    *(<span class="keyword">int</span> *)stacktop = argc;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> = <span class="title">current</span>-&gt;<span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>给出设计实现基于”<strong>UNIX的硬链接和软链接机制</strong>“的概要设方案</p>
</blockquote>
<ul>
<li>
<p>SFS中已经预留出硬链接/软链接的相关定义（没有实现）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer high-level operations on pathnames</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_link         - Create a hard link to a file.</span></span><br><span class="line"><span class="comment"> *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.</span></span><br><span class="line"><span class="comment"> *    vfs_unlink       - Delete a file/directory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_link</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_symlink</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unlink</span><span class="params">(<span class="keyword">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>硬链接机制的实现</p>
<ul>
<li>创建硬链接时，仍然为<code>new_path</code>建立一个<code>sfs_disk_entry</code>结构，但该结构的内部<code>ino</code>成员指向<code>old_path</code>的磁盘索引结点，并使该磁盘索引节点的<code>nlinks</code>引用计数成员加一即可。</li>
<li>删除硬链接时，令对应磁盘结点<code>sfs_disk_inode</code>中的<code>nlinks</code>减一，同时删除硬链接的<code>sfs_disk_entry</code>结构即可。</li>
</ul>
</li>
<li>
<p>软链接的实现</p>
<ul>
<li>
<p>与创建硬链接不同，创建软链接时要多建立一个<code>sfs_disk_inode</code>结构（即建立一个全新的文件）。之后，将<code>old_path</code>写入该文件中，并标注<code>sfs_disk_inode</code>的<code>type</code>为<code>SFS_TYPE_LINK</code>即可。</p>
</li>
<li>
<p>删除软链接与删除文件的操作没有区别，直接将对应的<code>sfs_disk_entry</code>和<code>sfs_disk_inode</code>结构删除即可。</p>
</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://kiprey.github.io/2020/09/uCore-8/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uCore/" rel="tag">uCore</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/10/mojo/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Plaid CTF 2020 mojo Writeup
          
        </div>
      </a>
    
    
      <a href="/2020/09/uCore-7/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">uCore实验 - Lab7</div>
      </a>
    
  </nav>

   
 
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '5f6c407f4cb8963d03ac',
    clientSecret: '1d6faa663a735dbfd671990187d6e62b32498560',
    repo: 'kiprey.github.io',
    owner: 'kiprey',
    admin: ['kiprey'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2025
        <i class="ri-heart-fill heart_icon"></i> Kiprey
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        <!-- <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
        <script>
            $(document).ready(function() {
                var int1 = setInterval(fixCount1, 100);
                var int2 = setInterval(fixCount2, 100);

                var busuanziValueSiteOffset = 100000000000;
                var busuanziValuePageOffset = 200000000000;
                function fixCount1() {
                    if ($("#busuanzi_value_site_uv").css("display") != "none") {
                        clearInterval(int1);
                        $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + busuanziValueSiteOffset);
                    }
                }
                function fixCount2() {
                    if ($("#busuanzi_value_page_pv").css("display") != "none") {
                        clearInterval(int2);
                        $("#busuanzi_value_page_pv").html(parseInt($("#busuanzi_value_page_pv").html()) + busuanziValuePageOffset);
                    }
                }
            });
        </script> -->
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Kiprey&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>


<!-- mermaid -->

  <script src='https://cdn.bootcdn.net/ajax/libs/mermaid/8.5.2/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

<!-- baiduSpider auto push -->

  <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>


    
  </div>
</body>

</html>