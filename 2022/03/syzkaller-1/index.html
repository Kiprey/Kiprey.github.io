<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="syzkaller, 源码阅读,漏洞挖掘, 调试, 代码, 计算机科学, Kiprey, Blog, 二进制，信息安全" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    syzkaller 源码阅读笔记-1 |  Kiprey&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?acff2772e1f74a625e1e26c280afa6c2";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="Kiprey's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-syzkaller-1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  syzkaller 源码阅读笔记-1
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/syzkaller-1/" class="article-date">
  <time datetime="2022-03-14T16:00:00.000Z" itemprop="datePublished">2022-03-15</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">11.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">55 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、简介">一、简介</h2>
<p><a href="https://github.com/google/syzkaller" target="_blank" rel="noopener">syzkaller</a> 是 google 开源的一款无监督覆盖率引导的 kernel fuzzer，支持包括 Linux、Windows 等操作系统的测试。</p>
<p>syzkaller 有很多个部件。其中：</p>
<ul>
<li>syz-extract：用于解析 syzlang 中的常量</li>
<li>syz-sysgen：用于解析 syzlang，提取其中描述的 syscall 和参数类型，以及参数依赖关系</li>
<li>syz-manager：用于启动与管理 syzkaller</li>
<li>syz-fuzzer：实际在 VM 中运行的 fuzzer</li>
<li>syz-executor：实际在 VM 中运行的测试程序</li>
</ul>
<p>架构图如下：</p>
<p><img src="/2022/03/syzkaller-1/process_structure.png" alt="syzkaller 的进程结构"></p>
<p>在本文中，我将先介绍 <strong>syz-extract 和 syz-sysgen</strong> 的源码。</p>
<a id="more"></a>
<blockquote>
<p>在本系列源码阅读笔记中，所有涉及到的 arch 和 platform 均为 <strong>x86_64 linux</strong>，不再另行说明。</p>
<p>syzkaller git checkout： 3a9d0024ba818c5b37058d9ac6fdfc0ddfa78be6</p>
<p>checkout Date:   Fri Nov 19 13:06:38 2021 +0100</p>
</blockquote>
<h2 id="二、syz-extract">二、syz-extract</h2>
<p>用途：解析并获取 syzlang 文件中的常量所对应的具体整型，并将结果存放至 xxx.txt.const 文件中。</p>
<h3 id="1-main">1. main</h3>
<blockquote>
<p>syz-extract main 函数位于 <code>sys/syz-extract/extract.go</code> 中。</p>
</blockquote>
<p>首先，syz-extract 将会尝试解析传入的参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in Function `main` </span></span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="keyword">if</span> *flagBuild &amp;&amp; *flagBuildDir != <span class="string">""</span> &#123;</span><br><span class="line">    tool.Failf(<span class="string">"-build and -builddir is an invalid combination"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其参数列表如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    flagOS        = flag.String(<span class="string">"os"</span>, runtime.GOOS, <span class="string">"target OS"</span>)</span><br><span class="line">    flagBuild     = flag.Bool(<span class="string">"build"</span>, <span class="literal">false</span>, <span class="string">"regenerate arch-specific kernel headers"</span>)</span><br><span class="line">    flagSourceDir = flag.String(<span class="string">"sourcedir"</span>, <span class="string">""</span>, <span class="string">"path to kernel source checkout dir"</span>)</span><br><span class="line">    flagIncludes  = flag.String(<span class="string">"includedirs"</span>, <span class="string">""</span>, <span class="string">"path to other kernel source include dirs separated by commas"</span>)</span><br><span class="line">    flagBuildDir  = flag.String(<span class="string">"builddir"</span>, <span class="string">""</span>, <span class="string">"path to kernel build dir"</span>)</span><br><span class="line">    flagArch      = flag.String(<span class="string">"arch"</span>, <span class="string">""</span>, <span class="string">"comma-separated list of arches to generate (all by default)"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>之后是调用 archFileList 函数，解析传入的参数，并生成对应的返回值。</p>
<blockquote>
<p>其中</p>
<ul>
<li>OS 为操作系统<strong>字符串</strong></li>
<li>archArray 为待生成的 arch <strong>字符串数组</strong></li>
<li>files 为待分析的 syzlang 文件名 <strong>字符串数组</strong></li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in Function `main` </span></span><br><span class="line">OS, archArray, files, err := archFileList(*flagOS, *flagArch, flag.Args())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    tool.Fail(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，便是尝试获取 OS 所对应的 Extractor 结构体；如果 OS 不存在则肯定取不到，直接报错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in Function `main` </span></span><br><span class="line">extractor := extractors[OS]</span><br><span class="line"><span class="keyword">if</span> extractor == <span class="literal">nil</span> &#123;</span><br><span class="line">    tool.Failf(<span class="string">"unknown os: %v"</span>, OS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>extractors 数组如下所示，该数组为不同的 OS 实例化了不同的 Extractor 类。其中 linux OS 所对应的 Extractor 实例（即那三个函数的实现）位于 <code>sys/syz-extract/linux.go</code> 中：</p>
<blockquote>
<p>三个函数的实现我们稍后再看。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Extractor <span class="keyword">interface</span> &#123;</span><br><span class="line">    prepare(sourcedir <span class="keyword">string</span>, build <span class="keyword">bool</span>, arches []*Arch) error</span><br><span class="line">    prepareArch(arch *Arch) error</span><br><span class="line">    processFile(arch *Arch, info *compiler.ConstInfo) (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> extractors = <span class="keyword">map</span>[<span class="keyword">string</span>]Extractor&#123;</span><br><span class="line">    targets.Akaros:  <span class="built_in">new</span>(akaros),</span><br><span class="line">    targets.Linux:   <span class="built_in">new</span>(linux), <span class="comment">// sys/syz-extract/linux.go</span></span><br><span class="line">    targets.FreeBSD: <span class="built_in">new</span>(freebsd),</span><br><span class="line">    targets.Darwin:  <span class="built_in">new</span>(darwin),</span><br><span class="line">    targets.NetBSD:  <span class="built_in">new</span>(netbsd),</span><br><span class="line">    targets.OpenBSD: <span class="built_in">new</span>(openbsd),</span><br><span class="line">    <span class="string">"android"</span>:       <span class="built_in">new</span>(linux),</span><br><span class="line">    targets.Fuchsia: <span class="built_in">new</span>(fuchsia),</span><br><span class="line">    targets.Windows: <span class="built_in">new</span>(windows),</span><br><span class="line">    targets.Trusty:  <span class="built_in">new</span>(trusty),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 main 函数，syz-extract 要用已有的 <strong>OS 字符串、archArray 字符串数组，以及 syzlang 文件名数组</strong>来生成出对应的 <strong>arches 结构体数组</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `main`</span></span><br><span class="line">arches, err := createArches(OS, archArray, files)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    tool.Fail(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *flagSourceDir == <span class="string">""</span> &#123;</span><br><span class="line">    tool.Fail(fmt.Errorf(<span class="string">"provide path to kernel checkout via -sourcedir "</span> +</span><br><span class="line">                         <span class="string">"flag (or make extract SOURCEDIR)"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备工作已经做的差不多了，接下来让 extractor 执行初始化操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function main</span></span><br><span class="line"><span class="keyword">if</span> err := extractor.prepare(*flagSourceDir, *flagBuild, arches); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    tool.Fail(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步实际上会调用到 <code>sys/syz-extract/linux.go</code> 中的 <code>prepare</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in sys/syz-extract/linux.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*linux)</span> <span class="title">prepare</span><span class="params">(sourcedir <span class="keyword">string</span>, build <span class="keyword">bool</span>, arches []*Arch)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> build &#123;</span><br><span class="line">        <span class="comment">// Run 'make mrproper', otherwise out-of-tree build fails.</span></span><br><span class="line">        <span class="comment">// However, it takes unreasonable amount of time,</span></span><br><span class="line">        <span class="comment">// so first check few files and if they are missing hope for best.</span></span><br><span class="line">        <span class="keyword">for</span> _, a := <span class="keyword">range</span> arches &#123;</span><br><span class="line">            arch := a.target.KernelArch</span><br><span class="line">            <span class="keyword">if</span> osutil.IsExist(filepath.Join(sourcedir, <span class="string">".config"</span>)) ||</span><br><span class="line">                osutil.IsExist(filepath.Join(sourcedir, <span class="string">"init/main.o"</span>)) ||</span><br><span class="line">                osutil.IsExist(filepath.Join(sourcedir, <span class="string">"include/config"</span>)) ||</span><br><span class="line">                osutil.IsExist(filepath.Join(sourcedir, <span class="string">"include/generated/compile.h"</span>)) ||</span><br><span class="line">                osutil.IsExist(filepath.Join(sourcedir, <span class="string">"arch"</span>, arch, <span class="string">"include"</span>, <span class="string">"generated"</span>)) &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"make mrproper ARCH=%v\n"</span>, arch)</span><br><span class="line">                out, err := osutil.RunCmd(time.Hour, sourcedir, <span class="string">"make"</span>, <span class="string">"mrproper"</span>, <span class="string">"ARCH="</span>+arch,</span><br><span class="line">                    <span class="string">"-j"</span>, fmt.Sprint(runtime.NumCPU()))</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> fmt.Errorf(<span class="string">"make mrproper failed: %v\n%s"</span>, err, out)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arches) &gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"more than 1 arch is invalid without -build"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不指定<strong>重新生成 linux kernel header</strong>，那么只会做一些简单的检查。但如果指定重新生成了，则会尝试在 linux kernel src 上执行 <code>make mrproper</code>。</p>
<p>回到 main 函数，接下来便是创建 go routine 通信管道和启动并行 worker：</p>
<blockquote>
<p>go routine 是 go 的轻量级线程，其中关键字 <code>go</code> 后面的语句将被放进新的 go routine 中执行。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jobC := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(archArray)*<span class="built_in">len</span>(files))</span><br><span class="line"><span class="comment">// 将 arch 结构体放置进 jobC 管道中</span></span><br><span class="line"><span class="keyword">for</span> _, arch := <span class="keyword">range</span> arches &#123;</span><br><span class="line">    jobC &lt;- arch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p := <span class="number">0</span>; p &lt; runtime.GOMAXPROCS(<span class="number">0</span>); p++ &#123;</span><br><span class="line">    <span class="keyword">go</span> worker(extractor, jobC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worker 启动后，main 函数就需要等待 worker 处理完成后才能保存处理结果至文件中，这就涉及到了线程协同。注意到代码中有 <code>&lt;-arch.done</code> 和 <code>&lt;-f.done</code> 语句，这两个语句会一直阻塞等待管道，直到其传来信息。若 worker 函数中对管道执行 close 操作，则被关闭的管道将不再等待，继续向下执行。因此这里 syz-extract 就利用了管道来完成线程协同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `main`</span></span><br><span class="line">constFiles := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*compiler.ConstFile)</span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    constFiles[file] = compiler.NewConstFile()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, arch := <span class="keyword">range</span> arches &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"generating %v/%v...\n"</span>, arch.target.OS, arch.target.Arch)</span><br><span class="line">    &lt;-arch.done</span><br><span class="line">    <span class="keyword">if</span> arch.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        failed = <span class="literal">true</span></span><br><span class="line">        fmt.Printf(<span class="string">"%v\n"</span>, arch.err)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> arch.files &#123;</span><br><span class="line">        &lt;-f.done</span><br><span class="line">        <span class="keyword">if</span> f.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            failed = <span class="literal">true</span></span><br><span class="line">            fmt.Printf(<span class="string">"%v: %v\n"</span>, f.name, f.err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        constFiles[f.name].AddArch(f.arch.target.Arch, f.consts, f.undeclared)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面的代码内容便是将生成结果保存进 <code>.const</code> 文件中，没有其他有意思的东西了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `main`</span></span><br><span class="line"><span class="keyword">for</span> file, cf := <span class="keyword">range</span> constFiles &#123;</span><br><span class="line">    outname := filepath.Join(<span class="string">"sys"</span>, OS, file+<span class="string">".const"</span>)</span><br><span class="line">    data := cf.Serialize()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">        os.Remove(outname)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := osutil.WriteFile(outname, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tool.Failf(<span class="string">"failed to write output file: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !failed &amp;&amp; *flagArch == <span class="string">""</span> &#123;</span><br><span class="line">    failed = checkUnsupportedCalls(arches)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, arch := <span class="keyword">range</span> arches &#123;</span><br><span class="line">    <span class="keyword">if</span> arch.build &#123;</span><br><span class="line">        os.RemoveAll(arch.buildDir)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> failed &#123;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-archFileList">2. archFileList</h3>
<p>archFileList 函数用于解析传入的参数信息，代码量非常短。</p>
<p>首先，调用者需要将 <strong>OS 字符串</strong>、<strong>arch 字符串</strong>，以及<strong>存放 syzlang 文件路径的字符串数组</strong>传入该函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">archFileList</span><span class="params">(os, arch <span class="keyword">string</span>, files []<span class="keyword">string</span>)</span></span> </span><br><span class="line">    (<span class="keyword">string</span>, []<span class="keyword">string</span>, []<span class="keyword">string</span>, error)</span><br></pre></td></tr></table></figure>
<p>之后，archFileList 会对 android 设置一些特殊的字段，然后切割参数字符串 arch，并将切割后的结果全保存进<strong>字符串数组 arches</strong> 中。若没有指定 arches 参数，则添加全部的 arch 进 arches 数组中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in archFileList Function</span></span><br><span class="line"><span class="comment">// Note: this is linux-specific and should be part of Extractor and moved to linux.go.</span></span><br><span class="line">android := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> os == <span class="string">"android"</span> &#123;</span><br><span class="line">    android = <span class="literal">true</span></span><br><span class="line">    os = targets.Linux</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arches []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> arch != <span class="string">""</span> &#123;</span><br><span class="line">    arches = strings.Split(arch, <span class="string">","</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> arch := <span class="keyword">range</span> targets.List[os] &#123;</span><br><span class="line">        arches = <span class="built_in">append</span>(arches, arch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> android &#123;</span><br><span class="line">        arches = []<span class="keyword">string</span>&#123;targets.I386, targets.AMD64, targets.ARM, targets.ARM64&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(arches)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>targets.List</code> 是一个 map 映射（即 <code>sys/targets/targets.go</code> 中的 List 变量），这上面存放了很多关于不同 OS 以及这些 OS 在特定 arch 下的信息，以下是一个精简后的代码片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nolint: lll</span></span><br><span class="line"><span class="keyword">var</span> List = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]*Target&#123;</span><br><span class="line">    ...,</span><br><span class="line">    Linux: &#123;</span><br><span class="line">        AMD64: &#123;</span><br><span class="line">            PtrSize:          <span class="number">8</span>,</span><br><span class="line">            PageSize:         <span class="number">4</span> &lt;&lt; <span class="number">10</span>,</span><br><span class="line">            LittleEndian:     <span class="literal">true</span>,</span><br><span class="line">            CFlags:           []<span class="keyword">string</span>&#123;<span class="string">"-m64"</span>&#125;,</span><br><span class="line">            Triple:           <span class="string">"x86_64-linux-gnu"</span>,</span><br><span class="line">            KernelArch:       <span class="string">"x86_64"</span>,</span><br><span class="line">            KernelHeaderArch: <span class="string">"x86"</span>,</span><br><span class="line">            NeedSyscallDefine: <span class="function"><span class="keyword">func</span><span class="params">(nr <span class="keyword">uint64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">                <span class="comment">// Only generate defines for new syscalls</span></span><br><span class="line">                <span class="comment">// (added after commit 8a1ab3155c2ac on 2012-10-04).</span></span><br><span class="line">                <span class="keyword">return</span> nr &gt;= <span class="number">313</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        I386: &#123;</span><br><span class="line">            VMArch:           AMD64,</span><br><span class="line">            PtrSize:          <span class="number">4</span>,</span><br><span class="line">            PageSize:         <span class="number">4</span> &lt;&lt; <span class="number">10</span>,</span><br><span class="line">            Int64Alignment:   <span class="number">4</span>,</span><br><span class="line">            LittleEndian:     <span class="literal">true</span>,</span><br><span class="line">            CFlags:           []<span class="keyword">string</span>&#123;<span class="string">"-m32"</span>&#125;,</span><br><span class="line">            Triple:           <span class="string">"x86_64-linux-gnu"</span>,</span><br><span class="line">            KernelArch:       <span class="string">"i386"</span>,</span><br><span class="line">            KernelHeaderArch: <span class="string">"x86"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过在 <code>for arch := range targets.List[os]</code> 的过程中，只会取出这些 map 的 key 值，即一系列的架构字符串，因此最后 archs 数据中存放的值如下：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309090646115.png" alt="image-20220309090646115"></p>
<p>接下来我们回到函数 archFileList 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in archFileList Function</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">        matches, err := filepath.Glob(filepath.Join(<span class="string">"sys"</span>, os, <span class="string">"*.txt"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(matches) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to find sys files: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        manualFiles := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="comment">// Not upstream, generated on https://github.com/multipath-tcp/mptcp_net-next</span></span><br><span class="line">            <span class="string">"vnet_mptcp.txt"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// Was in linux-next, but then was removed, fate is unknown.</span></span><br><span class="line">            <span class="string">"dev_watch_queue.txt"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// Not upstream, generated on:</span></span><br><span class="line">            <span class="comment">// https://chromium.googlesource.com/chromiumos/third_party/kernel d2a8a1eb8b86</span></span><br><span class="line">            <span class="string">"dev_bifrost.txt"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// ION support was removed from kernel.</span></span><br><span class="line">            <span class="comment">// We plan to leave the descriptions for some time as is and later remove them.</span></span><br><span class="line">            <span class="string">"dev_ion.txt"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// Not upstream, generated on unknown tree.</span></span><br><span class="line">            <span class="string">"dev_img_rogue.txt"</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        androidFiles := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="string">"dev_tlk_device.txt"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// This was generated on:</span></span><br><span class="line">            <span class="comment">// https://source.codeaurora.org/quic/la/kernel/msm-4.9 msm-4.9</span></span><br><span class="line">            <span class="string">"dev_video4linux.txt"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// This was generated on:</span></span><br><span class="line">            <span class="comment">// https://chromium.googlesource.com/chromiumos/third_party/kernel 3a36438201f3</span></span><br><span class="line">            <span class="string">"fs_incfs.txt"</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, f := <span class="keyword">range</span> matches &#123;</span><br><span class="line">            f = filepath.Base(f)</span><br><span class="line">            <span class="keyword">if</span> manualFiles[f] || os == targets.Linux &amp;&amp; android != androidFiles[f] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            files = <span class="built_in">append</span>(files, f)</span><br><span class="line">        &#125;</span><br><span class="line">        sort.Strings(files)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>若传入的参数 <code>files</code> 为空，则 syz-extract 将尝试自动添加文件进入。在这一部分代码中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matches, err := filepath.Glob(filepath.Join(<span class="string">"sys"</span>, os, <span class="string">"*.txt"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(matches) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to find sys files: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>syz-extract 将尝试解析路径 <code>sys/linux/*.txt</code> 路径，并将解析结果存放进 matches 数组中：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309090909852.png" alt="image-20220309090909852"></p>
<p>之后，在下面的代码中，跳过人工添加的文件，以及 android 不允许添加的文件（androidFiles 映射中 value 为 false 的条目），最后为结果数组做个顺序排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in archFileList Function</span></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> matches &#123;</span><br><span class="line">    f = filepath.Base(f)</span><br><span class="line">    <span class="keyword">if</span> manualFiles[f] || os == targets.Linux &amp;&amp; android != androidFiles[f] &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    files = <span class="built_in">append</span>(files, f)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(files)</span><br></pre></td></tr></table></figure>
<p>函数结束，结果返回：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in archFileList Function</span></span><br><span class="line"><span class="keyword">return</span> os, arches, files, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<h3 id="3-createArches">3. createArches</h3>
<p>该函数用于生成与参数对应的 Arch 结构体数组。该函数内容较少，因此笔记以注释形式内嵌在函数中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createArches</span><span class="params">(OS <span class="keyword">string</span>, archArray, files []<span class="keyword">string</span>)</span> <span class="params">([]*Arch, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arches []*Arch</span><br><span class="line">    <span class="comment">// 遍历 archArray 结构体</span></span><br><span class="line">    <span class="keyword">for</span> _, archStr := <span class="keyword">range</span> archArray &#123;</span><br><span class="line">        <span class="comment">// 尝试确定 buid 文件夹路径</span></span><br><span class="line">        buildDir := <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> *flagBuild &#123;</span><br><span class="line">            dir, err := ioutil.TempDir(<span class="string">""</span>, <span class="string">"syzkaller-kernel-build"</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to create temp dir: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">            buildDir = dir</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> *flagBuildDir != <span class="string">""</span> &#123;</span><br><span class="line">            buildDir = *flagBuildDir</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buildDir = *flagSourceDir</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 targets.List 中对应与 OS 和 arch 的 `Target` 结构体</span></span><br><span class="line">        target := targets.Get(OS, archStr)</span><br><span class="line">        <span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unknown arch: %v"</span>, archStr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建 arch 结构体</span></span><br><span class="line">        arch := &amp;Arch&#123;</span><br><span class="line">            <span class="comment">// 存放特定 OS 特定 arch 的一些信息</span></span><br><span class="line">            target:      target,</span><br><span class="line">            <span class="comment">// kernel source 路径</span></span><br><span class="line">            sourceDir:   *flagSourceDir,</span><br><span class="line">            <span class="comment">// kernel source header 路径</span></span><br><span class="line">            includeDirs: *flagIncludes,</span><br><span class="line">            <span class="comment">// build 路径</span></span><br><span class="line">            buildDir:    buildDir,</span><br><span class="line">            <span class="comment">// bool 值，是否需要重新生成架构指定的 kernel header</span></span><br><span class="line">            build:       *flagBuild,</span><br><span class="line">            <span class="comment">// 管道，用于 go routine 间通信。当 arch 分析完成后，将会向该管道通知</span></span><br><span class="line">            done:        <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 syzlang 文件名数组添加进 arch 结构体中</span></span><br><span class="line">        <span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">            arch.files = <span class="built_in">append</span>(arch.files, &amp;File&#123;</span><br><span class="line">                arch: arch,</span><br><span class="line">                name: f,</span><br><span class="line">                <span class="comment">// 管道，用于 go routine 间通信。当 file 分析完成后，将会向该管道通知</span></span><br><span class="line">                done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新创建的 arch 结构体放置进 arches 数组中</span></span><br><span class="line">        arches = <span class="built_in">append</span>(arches, arch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arches, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-worker">4. worker</h3>
<p>worker 用于执行真正的解析变量工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(extractor Extractor, jobC <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>对于管道 jobC 中的元素来说，初始时在 main 函数放进去的肯定是 Arch 结构体：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309095730698.png" alt="image-20220309095730698"></p>
<p>因此初始时 worker 内部的 switch 将检测到传入的变量类型为 Arch 结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `worker`</span></span><br><span class="line"><span class="keyword">for</span> job := <span class="keyword">range</span> jobC &#123;</span><br><span class="line">    <span class="comment">// 为 j 赋值为 jobC 管道中的对象，初始时为 Arch</span></span><br><span class="line">    <span class="keyword">switch</span> j := job.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="comment">// 最开始的时候肯定会走入这个分支</span></span><br><span class="line">        <span class="keyword">case</span> *Arch:</span><br><span class="line">            <span class="comment">// 执行 processArch，生成 const 信息</span></span><br><span class="line">            infos, err := processArch(extractor, j)</span><br><span class="line">            j.err = err</span><br><span class="line">            <span class="built_in">close</span>(j.done)</span><br><span class="line">            <span class="keyword">if</span> j.err == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> _, f := <span class="keyword">range</span> j.files &#123;</span><br><span class="line">                    f.info = infos[filepath.Join(<span class="string">"sys"</span>, j.target.OS, f.name)]</span><br><span class="line">                    jobC &lt;- f</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> *File:</span><br><span class="line">            j.consts, j.undeclared, j.err = processFile(extractor, j.arch, j)</span><br><span class="line">            <span class="built_in">close</span>(j.done)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到变量 j 就是从 jobC 中取出来的 Arch 结构体，因此在 processArch 操作完成后，worker 函数会分别从 infos 映射中遍历取出对应文件的信息，并将其填充至 <strong>arch 结构体</strong>中 <strong>files 结构体数组</strong>内的各个元素字段里：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309111211911.png" alt="image-20220309111211911"></p>
<p>最后执行 <code>jobC &lt;- f</code> 操作，将这个 File 结构体放入 jobC 管道中。</p>
<p>由于 worker 函数是会循环读取 jobC 内数据，因此 worker 函数接下来便会取出刚刚新放入的 File 结构体，执行 <code>processFile</code> 函数。在 processFile 中，syz-extract 将会获取各个 const 变量（例如 O_RDWR）所对应的整型值(例如2)。</p>
<p>worker 函数中还有一个关键点需要注意，当 processXXX 函数执行完成后，worker 函数接下来都会执行 <code>close(j.done)</code> ，将通信管道关闭。这样做的目的是为了通知 main goroutine “某部分工作已经完成”。这个操作有点类似于使用信号量来保证线程同步。</p>
<h3 id="5-processArch">5. processArch</h3>
<p>processArch 的作用是，处理传入的 Extractor 和 Arch 结构体，生成 const 信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processArch</span><span class="params">(extractor Extractor, arch *Arch)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]*compiler.ConstInfo, error)</span></span> &#123;</span><br><span class="line">    errBuf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    <span class="comment">// 定义 error handler 函数</span></span><br><span class="line">    eh := <span class="function"><span class="keyword">func</span><span class="params">(pos ast.Pos, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(errBuf, <span class="string">"%v: %v\n"</span>, pos, msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析 sys/linux/*.txt 的 syzlang 文件，形成一个 AST 数组</span></span><br><span class="line">    <span class="comment">// 因此 top 变量就是 ast 森林的根节点</span></span><br><span class="line">    top := ast.ParseGlob(filepath.Join(<span class="string">"sys"</span>, arch.target.OS, <span class="string">"*.txt"</span>), eh)</span><br><span class="line">    <span class="keyword">if</span> top == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"%v"</span>, errBuf.String())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 compiler.ExtractConsts 获取每个 syzlang 文件中所对应的 const 信息</span></span><br><span class="line">    infos := compiler.ExtractConsts(top, arch.target, eh)</span><br><span class="line">    <span class="keyword">if</span> infos == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"%v"</span>, errBuf.String())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让 Extractor 为 arch 做些准备</span></span><br><span class="line">    <span class="keyword">if</span> err := extractor.prepareArch(arch); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> infos, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>compiler.ExtractConsts</code> 只是一个简单的 wrapper 函数，获取编译 syzlang 结果中的 fileConsts 字段：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309104824331.png" alt="image-20220309104824331"></p>
<p>字段 res.fileConsts 包含了 <strong>syzlang 文件名</strong>与其<strong>用到的常量数组</strong>的映射，以及其所 include 的头文件数组的映射；这些东西都将会用到获取 consts 对应的具体整数操作中。</p>
<p>而 <code>extractor.prepareArch</code> 函数在 <code>linux.go</code> 中，做的操作主要是定义了几个头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"stdarg.h"</span>: `</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_list __builtin_va_list</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start __builtin_va_start</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end __builtin_va_end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg __builtin_va_arg</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_copy __builtin_va_copy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __va_copy __builtin_va_copy</span></span><br><span class="line">`,</span><br><span class="line"></span><br><span class="line"><span class="string">"asm/a.out.h"</span>:    <span class="string">""</span>,</span><br><span class="line"><span class="string">"asm/prctl.h"</span>:    <span class="string">""</span>,</span><br><span class="line"><span class="string">"asm/mce.h"</span>:      <span class="string">""</span>,</span><br><span class="line"><span class="string">"uapi/asm/msr.h"</span>: <span class="string">""</span>,</span><br></pre></td></tr></table></figure>
<p>因为某些 arch 的 kernel src 可能会缺失这些文件，需要自己手动补全。补全之后 <code>extractor.prepareArch</code> 会重新执行一次 linux kernel make 生成。</p>
<p>回到 processArch 函数，该函数最后会把先前获取到的 consts info 返回给调用者：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309110405501.png" alt="image-20220309110405501"></p>
<h3 id="6-processFile">6. processFile</h3>
<p>processFile 函数只是 extractor.processFile 的 wrapper，主要是做了一些 check 操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(extractor Extractor, arch *Arch, file *File)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">    inname := filepath.Join(<span class="string">"sys"</span>, arch.target.OS, file.name)</span><br><span class="line">    <span class="keyword">if</span> file.info == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"const info for input file %v is missing"</span>, inname)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(file.info.Consts) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extractor.processFile(arch, file.info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际用于查找 const 值的操作位于 <code>extractor.processFile</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*linux)</span> <span class="title">processFile</span><span class="params">(arch *Arch, info *compiler.ConstInfo)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>在 linux.go 中，<code>processFile</code> 初始时先过滤掉不满足条件的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function processFile of sys/syz-extract/linux.go</span></span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(info.File, <span class="string">"_kvm.txt"</span>) &amp;&amp;</span><br><span class="line">    (arch.target.Arch == targets.ARM || arch.target.Arch == targets.RiscV64) &#123;</span><br><span class="line">    <span class="comment">// Hack: KVM is not supported on ARM anymore. We may want some more official support</span></span><br><span class="line">    <span class="comment">// for marking descriptions arch-specific, but so far this combination is the only</span></span><br><span class="line">    <span class="comment">// one. For riscv64, KVM is not supported yet but might be in the future.</span></span><br><span class="line">    <span class="comment">// Note: syz-sysgen also ignores this file for arm and riscv64.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，生成<strong>编译代码模板</strong>所要用到的 gcc 编译参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function processFile of sys/syz-extract/linux.go</span></span><br><span class="line">headerArch := arch.target.KernelHeaderArch</span><br><span class="line">sourceDir := arch.sourceDir</span><br><span class="line">buildDir := arch.buildDir</span><br><span class="line">args := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="comment">// This makes the build completely hermetic, only kernel headers are used.</span></span><br><span class="line">    <span class="string">"-nostdinc"</span>,</span><br><span class="line">    <span class="string">"-w"</span>, <span class="string">"-fmessage-length=0"</span>,</span><br><span class="line">    <span class="string">"-O3"</span>, <span class="comment">// required to get expected values for some __builtin_constant_p</span></span><br><span class="line">    <span class="string">"-I."</span>,</span><br><span class="line">    <span class="string">"-D__KERNEL__"</span>,</span><br><span class="line">    <span class="string">"-DKBUILD_MODNAME=\"-\""</span>,</span><br><span class="line">    <span class="string">"-I"</span> + sourceDir + <span class="string">"/arch/"</span> + headerArch + <span class="string">"/include"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + buildDir + <span class="string">"/arch/"</span> + headerArch + <span class="string">"/include/generated/uapi"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + buildDir + <span class="string">"/arch/"</span> + headerArch + <span class="string">"/include/generated"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + sourceDir + <span class="string">"/arch/"</span> + headerArch + <span class="string">"/include/asm/mach-malta"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + sourceDir + <span class="string">"/arch/"</span> + headerArch + <span class="string">"/include/asm/mach-generic"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + buildDir + <span class="string">"/include"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + sourceDir + <span class="string">"/include"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + sourceDir + <span class="string">"/arch/"</span> + headerArch + <span class="string">"/include/uapi"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + buildDir + <span class="string">"/arch/"</span> + headerArch + <span class="string">"/include/generated/uapi"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + sourceDir + <span class="string">"/include/uapi"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + buildDir + <span class="string">"/include/generated/uapi"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + sourceDir,</span><br><span class="line">    <span class="string">"-I"</span> + sourceDir + <span class="string">"/include/linux"</span>,</span><br><span class="line">    <span class="string">"-I"</span> + buildDir + <span class="string">"/syzkaller"</span>,</span><br><span class="line">    <span class="string">"-include"</span>, sourceDir + <span class="string">"/include/linux/kconfig.h"</span>,</span><br><span class="line">&#125;</span><br><span class="line">args = <span class="built_in">append</span>(args, arch.target.CFlags...)</span><br><span class="line"><span class="keyword">for</span> _, incdir := <span class="keyword">range</span> info.Incdirs &#123;</span><br><span class="line">    args = <span class="built_in">append</span>(args, <span class="string">"-I"</span>+sourceDir+<span class="string">"/"</span>+incdir)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> arch.includeDirs != <span class="string">""</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, dir := <span class="keyword">range</span> strings.Split(arch.includeDirs, <span class="string">","</span>) &#123;</span><br><span class="line">        args = <span class="built_in">append</span>(args, <span class="string">"-I"</span>+dir)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数有亿点点多：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309113521638.png" alt="image-20220309113521638"></p>
<p>在准备好参数之后，processFile 还准备了 extract 参数，以及待使用的 CC 编译器，之后执行<strong>更加核心的 extract 函数</strong>，生成出 res 映射和 undeclared 集合：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function processFile of sys/syz-extract/linux.go</span></span><br><span class="line">params := &amp;extractParams&#123;</span><br><span class="line">    AddSource:      <span class="string">"#include &lt;asm/unistd.h&gt;"</span>,</span><br><span class="line">    ExtractFromELF: <span class="literal">true</span>,</span><br><span class="line">    TargetEndian:   arch.target.HostEndian,</span><br><span class="line">&#125;</span><br><span class="line">cc := arch.target.CCompiler</span><br><span class="line">res, undeclared, err := extract(info, cc, args, params)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/syzkaller-1/image-20220309113727970.png" alt="image-20220309113727970"></p>
<p>其中，res 是 <strong>const 字符串与整型</strong>的映射；undeclared 是<strong>未声明 const 字符串</strong>与 bool 值的映射，通常这里的 bool 值都为 true：</p>
<blockquote>
<p>undeclared 所对应的常量将在 <code>.const</code> 文件中标明其值为 <code>???</code></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O_RDWR = <span class="number">2</span></span><br><span class="line">MyConst = ???</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/2022/03/syzkaller-1/image-20220309132346585.png" alt="image-20220309132346585"></p>
<p>执行完成 extract 函数后，如果当前架构为 32 位，则 syz-extract 需要使用 mmap2 来替换 mmap，以避免一些可能的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> arch.target.PtrSize == <span class="number">4</span> &#123;</span><br><span class="line">    <span class="comment">// mmap syscall on i386/arm is translated to old_mmap and has different signature.</span></span><br><span class="line">    <span class="comment">// As a workaround fix it up to mmap2, which has signature that we expect.</span></span><br><span class="line">    <span class="comment">// pkg/csource has the same hack.</span></span><br><span class="line">    <span class="keyword">const</span> mmap = <span class="string">"__NR_mmap"</span></span><br><span class="line">    <span class="keyword">const</span> mmap2 = <span class="string">"__NR_mmap2"</span></span><br><span class="line">    <span class="keyword">if</span> res[mmap] != <span class="number">0</span> || undeclared[mmap] &#123;</span><br><span class="line">        <span class="keyword">if</span> res[mmap2] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"%v is missing"</span>, mmap2)</span><br><span class="line">        &#125;</span><br><span class="line">        res[mmap] = res[mmap2]</span><br><span class="line">        <span class="built_in">delete</span>(undeclared, mmap)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换完成后将结果返回：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res, undeclared, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>以上内容便是 extractor.processFile 的源码解释，接下来我们深入一下 extract 函数。</p>
<h3 id="7-extract">7. extract</h3>
<blockquote>
<p>函数代码位于 sys/syz-extract/fetch.go</p>
</blockquote>
<p>该函数调用编译器来编译代码模板，并根据编译出的二进制文件来获取 consts 常量整数。若编译过程出错，则会尝试自动纠错。</p>
<p>函数声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extract</span><span class="params">(info *compiler.ConstInfo, cc <span class="keyword">string</span>, args []<span class="keyword">string</span>, params *extractParams)</span></span> </span><br><span class="line">    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, error)</span><br></pre></td></tr></table></figure>
<p>其中参数 Info 便是单个文件存放 const 数据的结构体，cc 是编译器名称字符串，args 是编译器执行参数，params 是用于 extract 执行过程用的选项：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309133255996.png" alt="image-20220309133255996"></p>
<p>初始时，extract 函数声明一系列的 map：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `extract`</span></span><br><span class="line">data := &amp;CompileData&#123;</span><br><span class="line">    extractParams: params,</span><br><span class="line">    Defines:       info.Defines,</span><br><span class="line">    Includes:      info.Includes,</span><br><span class="line">    Values:        info.Consts,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译生成的程序路径</span></span><br><span class="line">bin := <span class="string">""</span></span><br><span class="line"><span class="comment">// 这个字段貌似没有用途，先行忽略</span></span><br><span class="line">missingIncludes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">// 未定义的 const，通常是自己定义的常量</span></span><br><span class="line">undeclared := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">// 声明并初始化 valMap 中各个元素为 true</span></span><br><span class="line">valMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> info.Consts &#123;</span><br><span class="line">    valMap[val] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来便是尝试将 <strong>consts 常量字符串与模板C代码结合</strong>，并编译结合后的代码，形成一个可执行文件。编译操作由 <code>compile</code> 函数完成，其返回结果分别为编译出的可执行文件路径；编译器标准输出信息；编译器标准错误信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `extract`</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    bin1, out, err := compile(cc, args, data)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        bin = bin1</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先深入进 compile 函数看看，该函数非常的简单，因此将笔记内联进代码中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compile</span><span class="params">(cc <span class="keyword">string</span>, args []<span class="keyword">string</span>, data *CompileData)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建填充好后的 C 代码缓冲区</span></span><br><span class="line">    src := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    <span class="comment">// 使用传入的 data 对代码模板 srcTemplate 进行填充</span></span><br><span class="line">    <span class="keyword">if</span> err := srcTemplate.Execute(src, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to generate source: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个临时可执行文件路径</span></span><br><span class="line">    binFile, err := osutil.TempFile(<span class="string">"syz-extract-bin"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为编译器添加额外的参数</span></span><br><span class="line">    args = <span class="built_in">append</span>(args, []<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="comment">// -x c ：指定代码语言为 C 语言</span></span><br><span class="line">        <span class="comment">// - ：指定代码从标准输入而不是从文件中读取</span></span><br><span class="line">        <span class="string">"-x"</span>, <span class="string">"c"</span>, <span class="string">"-"</span>,</span><br><span class="line">        <span class="comment">// 指定文件输出的路径</span></span><br><span class="line">        <span class="string">"-o"</span>, binFile,</span><br><span class="line">        <span class="string">"-w"</span>,</span><br><span class="line">    &#125;...)</span><br><span class="line">    <span class="keyword">if</span> data.ExtractFromELF &#123;</span><br><span class="line">        <span class="comment">// gcc -c 参数：只编译但不链接</span></span><br><span class="line">        <span class="comment">// 由于我们测试时使用的是 Linux，因此会进入该分支</span></span><br><span class="line">        args = <span class="built_in">append</span>(args, <span class="string">"-c"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行程序</span></span><br><span class="line">    cmd := osutil.Command(cc, args...)</span><br><span class="line">    <span class="comment">// 将填充后的代码模板喂给 gcc 编译</span></span><br><span class="line">    cmd.Stdin = src</span><br><span class="line">    <span class="comment">// 将 stdin 和 stdout 的输入糅合，使得他俩的输出完全一致</span></span><br><span class="line">    <span class="comment">// 通俗的说就是让 stdin 和 stdout 都指向同一个管道</span></span><br><span class="line">    <span class="keyword">if</span> out, err := cmd.CombinedOutput(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        os.Remove(binFile)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, out, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binFile, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行至该函数入口时，其参数示例如下：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309134856818.png" alt="image-20220309134856818"></p>
<p>现在我们看看是什么样的代码模板：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> srcTemplate = template.Must(template.New(<span class="string">""</span>).Parse(<span class="string">`</span></span><br><span class="line"><span class="string">&#123;&#123;if not .ExtractFromELF&#125;&#125;</span></span><br><span class="line"><span class="string">#define __asm__(...)</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;&#123;if .DefineGlibcUse&#125;&#125;</span></span><br><span class="line"><span class="string">#ifndef __GLIBC_USE</span></span><br><span class="line"><span class="string">#    define __GLIBC_USE(X) 0</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;&#123;range $incl := $.Includes&#125;&#125;</span></span><br><span class="line"><span class="string">#include &lt;&#123;&#123;$incl&#125;&#125;&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;&#123;range $name, $val := $.Defines&#125;&#125;</span></span><br><span class="line"><span class="string">#ifndef &#123;&#123;$name&#125;&#125;</span></span><br><span class="line"><span class="string">#    define &#123;&#123;$name&#125;&#125; &#123;&#123;$val&#125;&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;&#123;.AddSource&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;&#123;if .DeclarePrintf&#125;&#125;</span></span><br><span class="line"><span class="string">int printf(const char *format, ...);</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;&#123;if .ExtractFromELF&#125;&#125;</span></span><br><span class="line"><span class="string">__attribute__((section("syz_extract_data")))</span></span><br><span class="line"><span class="string">unsigned long long vals[] = &#123;</span></span><br><span class="line"><span class="string">    &#123;&#123;range $val := $.Values&#125;&#125;(unsigned long long)&#123;&#123;$val&#125;&#125;,</span></span><br><span class="line"><span class="string">    &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&#123;&#123;else&#125;&#125;</span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    int i;</span></span><br><span class="line"><span class="string">    unsigned long long vals[] = &#123;</span></span><br><span class="line"><span class="string">        &#123;&#123;range $val := $.Values&#125;&#125;(unsigned long long)&#123;&#123;$val&#125;&#125;,</span></span><br><span class="line"><span class="string">        &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    for (i = 0; i &lt; sizeof(vals)/sizeof(vals[0]); i++) &#123;</span></span><br><span class="line"><span class="string">        if (i != 0)</span></span><br><span class="line"><span class="string">            printf(" ");</span></span><br><span class="line"><span class="string">        printf("%llu", vals[i]);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">`</span>))</span><br></pre></td></tr></table></figure>
<p>可以很容易的看出来，该模板会将先前从 syzlang 收集到的 include、define 和 consts 字符串全部融合：</p>
<ul>
<li>如果设置了 ExtractFromELF 标志位，则 <strong>consts 值将全部放置在一个名为 syz_extract_data 的 section 上</strong></li>
<li>如果没有设置该标志位，则<strong>编译出来的程序在执行时将会依次打印 consts 值，以 <code>%llu</code> 的输出格式&amp;使用空格来区分每个变量，输出至 stdout</strong>中。这样，sys-extract 就可以通过分析所编译程序的输出，来确定每个 consts 字符串所对应的数值是多少。</li>
</ul>
<p>回到 <code>extract</code> 函数，由于编写 syzlang 时极易出问题，因此 syz-extract 需要尝试自动纠错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `extract`</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    bin1, out, err := compile(cc, args, data)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        bin = bin1</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Some consts and syscall numbers are not defined on some archs.</span></span><br><span class="line">    <span class="comment">// Figure out from compiler output undefined consts,</span></span><br><span class="line">    <span class="comment">// and try to compile again without them.</span></span><br><span class="line">    <span class="comment">// May need to try multiple times because some severe errors terminate compilation.</span></span><br><span class="line">    tryAgain := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 遍历所有预先定义的错误信息，并使用正则表达式匹配</span></span><br><span class="line">    <span class="keyword">for</span> _, errMsg := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">`error: [‘']([a-zA-Z0-9_]+)[’'] undeclared`</span>,</span><br><span class="line">        <span class="string">`note: in expansion of macro [‘']([a-zA-Z0-9_]+)[’']`</span>,</span><br><span class="line">        <span class="string">`note: expanded from macro [‘']([a-zA-Z0-9_]+)[’']`</span>,</span><br><span class="line">        <span class="string">`error: use of undeclared identifier [‘']([a-zA-Z0-9_]+)[’']`</span>,</span><br><span class="line">    &#125; &#123;</span><br><span class="line">        re := regexp.MustCompile(errMsg)</span><br><span class="line">        matches := re.FindAllSubmatch(out, <span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 如果匹配到了，则将出问题的常量取出至 undeclared 中</span></span><br><span class="line">        <span class="keyword">for</span> _, match := <span class="keyword">range</span> matches &#123;</span><br><span class="line">            val := <span class="keyword">string</span>(match[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> valMap[val] &amp;&amp; !undeclared[val] &#123;</span><br><span class="line">                undeclared[val] = <span class="literal">true</span></span><br><span class="line">                tryAgain = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !tryAgain &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to run compiler: %v %v\n%v\n%s"</span>,</span><br><span class="line">                                    cc, args, err, out)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置编译用的 consts 数组</span></span><br><span class="line">    data.Values = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将出错的 consts 剔除，并将剩余没出错的 consts 存入编译用的 consts 数组</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> info.Consts &#123;</span><br><span class="line">        <span class="keyword">if</span> undeclared[v] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        data.Values = <span class="built_in">append</span>(data.Values, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这部分代码没咋看懂，因为 data.Includes 没有被重置，没必要重复添加</span></span><br><span class="line">    data.Includes = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> info.Includes &#123;</span><br><span class="line">        <span class="comment">// missingIncludes 没有初始化，因此是个一直为空的变量</span></span><br><span class="line">        <span class="keyword">if</span> missingIncludes[v] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        data.Includes = <span class="built_in">append</span>(data.Includes, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后便是从编译出的二进制文件中读取数值，解析并返回：</p>
<blockquote>
<p>注意：虽然 syz-extract <strong>立即</strong>对编译出的二进制文件执行 remove 操作，但由于 syz-extract <strong>仍然持有该文件的文件描述符</strong>，因此该文件将<strong>不会立即被删除</strong>，而是等到 syz-extract 释放了该文件的文件描述符后才会被删除。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将新编译出的二进制文件删除</span></span><br><span class="line"><span class="keyword">defer</span> os.Remove(bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flagVals []<span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> data.ExtractFromELF &#123;</span><br><span class="line">    flagVals, err = extractFromELF(bin, params.TargetEndian)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    flagVals, err = extractFromExecutable(bin)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(flagVals) != <span class="built_in">len</span>(data.Values) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"fetched wrong number of values %v, want != %v"</span>,</span><br><span class="line">                                <span class="built_in">len</span>(flagVals), <span class="built_in">len</span>(data.Values))</span><br><span class="line">&#125;</span><br><span class="line">res := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>)</span><br><span class="line"><span class="keyword">for</span> i, name := <span class="keyword">range</span> data.Values &#123;</span><br><span class="line">    res[name] = flagVals[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, undeclared, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>操作二进制文件的代码主要是这几行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> data.ExtractFromELF &#123;</span><br><span class="line">    flagVals, err = extractFromELF(bin, params.TargetEndian)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    flagVals, err = extractFromExecutable(bin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 ExtractFromELF 字段为 false，则 sys-extract 会走下面这个分支，执行函数 extractFromExecutable。该函数将实际执行目标程序，解析其输出并转换为整型数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractFromExecutable</span><span class="params">(binFile <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line">    out, err := osutil.Command(binFile).CombinedOutput()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to run flags binary: %v\n%s"</span>, err, out)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(out) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> vals []<span class="keyword">uint64</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> strings.Split(<span class="keyword">string</span>(out), <span class="string">" "</span>) &#123;</span><br><span class="line">        n, err := strconv.ParseUint(val, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to parse value: %v (%v)"</span>, err, val)</span><br><span class="line">        &#125;</span><br><span class="line">        vals = <span class="built_in">append</span>(vals, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但由于 OS 为 Linux 时，其 ExtractFromELF 标志为 true，因此会执行 extractFromELF 函数。在该函数中， syz-extract 将<strong>不会实际执行程序</strong>，而是<strong>从 ELF 文件中一个名为 <code>syz_extract_data</code> 的 section 中读取常量值</strong>：</p>
<blockquote>
<p>而且也执行不起来，因为先前手动不让二进制文件执行 link 操作，还没 main 函数。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractFromELF</span><span class="params">(binFile <span class="keyword">string</span>, targetEndian binary.ByteOrder)</span> <span class="params">([]<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line">    f, err := os.Open(binFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    ef, err := elf.NewFile(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, sec := <span class="keyword">range</span> ef.Sections &#123;</span><br><span class="line">        <span class="keyword">if</span> sec.Name != <span class="string">"syz_extract_data"</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        data, err := ioutil.ReadAll(sec.Open())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        vals := <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="built_in">len</span>(data)/<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> err := binary.Read(bytes.NewReader(data), targetEndian, &amp;vals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vals, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"did not find syz_extract_data section"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样做的目的貌似是为了<strong>提高常量读取速度</strong>，因为读取文件远比执行程序来的快。</p>
</blockquote>
<h3 id="8-小结">8. 小结</h3>
<p>syz-extract 会调用自定义 compiler 解析 syzlang 为 ast 森林，并依次提取每个 ast 树上的 consts 节点，然后将这些 consts 节点上的字符串放置进模板中，编译模板生成一个 ELF 或其他可执行文件。</p>
<p>接下来 syz-extract 会分析 ELF 文件上的数据，或者尝试执行可执行文件来解析其输出，以获得各个 consts 字符串所对应的具体整型值。</p>
<p>最后 syz-extract 将获取到的 consts 字符串与具体整型的映射关系，一个个序列化并填入 <code>.const</code> 文件中，这样便生成了对应于每个 syzlang 文件的 .const 文件。</p>
<p>在 syz-extract 执行的整个过程中，syz-extract 另起一个 go routine 来执行 worker，是为了能达到边进行常量提取，边将先前已有的提取结果存放进文件中，这样做是为了提高效率，加快常量提取的速度。</p>
<p>调试用的 vscode launch.json 文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"syzextractLaunch"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"go"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"mode"</span>: <span class="string">"auto"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;fileDirname&#125;"</span>,</span><br><span class="line">            <span class="attr">"env"</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"/usr/class/syzkaller"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [<span class="string">"-sourcedir"</span>, <span class="string">"/usr/class/linux"</span>, <span class="string">"-arch"</span>, <span class="string">"amd64"</span>] </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、syz-sysgen">三、syz-sysgen</h2>
<blockquote>
<p>代码位于 <code>sys/syz-sysgen/sysgen.go</code> 中。</p>
</blockquote>
<p>syz-gen 用于解析人工编写的 syzlang 代码文件，并将其 syzlang 内部定义的 syscall 类型信息转换成后续 syzkaller 能够使用的数据结构。</p>
<p>在理解了 syz-extract 的代码后，syz-sysgen 的代码相对来说也比较好理解，接下来我们先从 main 函数开始看起。</p>
<h3 id="1-main-2">1. main</h3>
<p>首先是将所有 OS 的类型都取出来，并且创建了用于存储结果的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey：in Function main</span></span><br><span class="line"><span class="keyword">defer</span> tool.Init()()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OSList []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> OS := <span class="keyword">range</span> targets.List &#123;</span><br><span class="line">    OSList = <span class="built_in">append</span>(OSList, OS)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(OSList)</span><br><span class="line"></span><br><span class="line">data := &amp;ExecutorData&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其中第一行的 golang <code>defer</code> 关键字表示，<strong>defer 后面的函数将在整个函数正常返回时被执行</strong>。由于 <code>tool.Init()</code> 涉及到命令行中 CPU/Mem 分析，不在我们的考虑范畴，因此忽略不看。</p>
<p>完成这段代码的执行后，其变量情况如下图所示：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309165347651.png" alt="image-20220309165347651"></p>
<p>紧接着便是一个 for 循环，遍历 OSList 中的每个 OS 字符串，并解析其中的 syzlang 代码。我将这个 for 循环分为了上中下三个部分：</p>
<ul>
<li>
<p>首先是第一部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey：in Function main</span></span><br><span class="line"><span class="keyword">for</span> _, OS := <span class="keyword">range</span> OSList &#123;</span><br><span class="line">    descriptions := ast.ParseGlob(filepath.Join(*srcDir, <span class="string">"sys"</span>, OS, <span class="string">"*.txt"</span>), <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> descriptions == <span class="literal">nil</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    constFile := compiler.DeserializeConstFile(filepath.Join(*srcDir, <span class="string">"sys"</span>, OS, <span class="string">"*.const"</span>), <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> constFile == <span class="literal">nil</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  osutil.MkdirAll(filepath.Join(*outDir, <span class="string">"sys"</span>, OS, <span class="string">"gen"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> archs []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> arch := <span class="keyword">range</span> targets.List[OS] &#123;</span><br><span class="line">        archs = <span class="built_in">append</span>(archs, arch)</span><br><span class="line">    &#125;</span><br><span class="line">  sort.Strings(archs)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分内容较为简单，将当前遍历到的 OS 所对应的 <code>sys/&lt;os&gt;/*.txt</code> 和 <code>sys/&lt;os&gt;/*.const</code>文件，分别解析成 AST 树 (ast.Description 类型) 和 ConstFile 结构体。之后创建 <code>sys/&lt;os&gt;/gen</code> 文件夹，整个 syz-sysgen 的输出将存放在该文件夹下：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309170145753.png" alt="image-20220309170145753"></p>
<p>之后还是收集当前 OS 所对应的全部 arch 字符串集合，并做一次排序操作。</p>
</li>
<li>
<p>其次是第二部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey：in Function main</span></span><br><span class="line"><span class="keyword">for</span> _, OS := <span class="keyword">range</span> OSList &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> jobs []*Job</span><br><span class="line">    <span class="keyword">for</span> _, arch := <span class="keyword">range</span> archs &#123;</span><br><span class="line">        jobs = <span class="built_in">append</span>(jobs, &amp;Job&#123;</span><br><span class="line">            Target:      targets.List[OS][arch],</span><br><span class="line">            Unsupported: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(jobs, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jobs[i].Target.Arch &lt; jobs[j].Target.Arch</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(jobs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        job := job</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            processJob(job, descriptions, constFile)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是为每个 arch 都创建了一个 Job 结构体，将其添加进数组 jobs中，并为数组执行排序操作，其中排序规则是自定义的。</p>
<p>接下来创建了一个 <code>sync.WaitGroup</code> 结构体，这个结构体用于<strong>等待指定数量的 go routine 集合执行完成</strong>。其内部原理有点类似于信号量，执行 <code>wg.Add</code> 函数以增加其内部计数器值，执行 <code>wg.Done</code> 函数以减小其内部计数器值，执行 <code>wg.Wait</code> 则判断内部计数器值状态，进而选择是否挂起等待。</p>
<p>其中最重要的是，syz-sysgen 依次遍历 jobs 数组中的每个 job，并创建 go routine 并行执行这些 job。函数 processJob 用于编译先前 parse 的 syzlang AST、分析其中的类型信息与依赖关系，并将其序列化为 golang 代码至 <code>sys/&lt;OS&gt;/gen/&lt;arch&gt;.go</code> 中，同时还将 syscall 属性相关的信息保存在 <code>job.ArchData</code> 中，供后续生成 sys-executor 关键头文件代码所用。</p>
</li>
<li>
<p>最后是第三部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey：in Function main</span></span><br><span class="line"><span class="keyword">for</span> _, OS := <span class="keyword">range</span> OSList &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> syscallArchs []ArchData</span><br><span class="line">    unsupported := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        <span class="keyword">if</span> !job.OK &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"compilation of %v/%v target failed:\n"</span>, job.Target.OS, job.Target.Arch)</span><br><span class="line">            <span class="keyword">for</span> _, msg := <span class="keyword">range</span> job.Errors &#123;</span><br><span class="line">                fmt.Print(msg)</span><br><span class="line">            &#125;</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        syscallArchs = <span class="built_in">append</span>(syscallArchs, job.ArchData)</span><br><span class="line">        <span class="keyword">for</span> u := <span class="keyword">range</span> job.Unsupported &#123;</span><br><span class="line">            unsupported[u]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data.OSes = <span class="built_in">append</span>(data.OSes, OSData&#123;</span><br><span class="line">        GOOS:  OS,</span><br><span class="line">        Archs: syscallArchs,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> what, count := <span class="keyword">range</span> unsupported &#123;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="built_in">len</span>(jobs) &#123;</span><br><span class="line">            tool.Failf(<span class="string">"%v is unsupported on all arches (typo?)"</span>, what)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三部分没什么需要特别关注的，这部分主要是做了一些检查，并将先前 worker 里生成的 ArchData 提取进变量 data 中。</p>
</li>
</ul>
<p>for 循环结束后吗，main 函数最后这部分的代码继续为变量 data 设置一些字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">attrs := reflect.TypeOf(prog.SyscallAttrs&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; attrs.NumField(); i++ &#123;</span><br><span class="line">    data.CallAttrs = <span class="built_in">append</span>(data.CallAttrs, prog.CppName(attrs.Field(i).Name))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props := prog.CallProps&#123;&#125;</span><br><span class="line">props.ForeachProp(<span class="function"><span class="keyword">func</span><span class="params">(name, _ <span class="keyword">string</span>, value reflect.Value)</span></span> &#123;</span><br><span class="line">    data.CallProps = <span class="built_in">append</span>(data.CallProps, CallPropDescription&#123;</span><br><span class="line">        Type: value.Kind().String(),</span><br><span class="line">        Name: prog.CppName(name),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这部分代码乍看上去可能不太能理解，但仔细一看就能发现，它只是分别将 <code>prog.SyscallAttrs</code> 和 <code>prog.CallProps</code> 这两个结构体对应的字段名存了起来。俩结构体声明如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyscallAttrs represents call attributes in syzlang.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This structure is the source of truth for the all other parts of the system.</span></span><br><span class="line"><span class="comment">// pkg/compiler uses this structure to parse descriptions.</span></span><br><span class="line"><span class="comment">// syz-sysgen uses this structure to generate code for executor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Only bool's and uint64's are currently supported.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See docs/syscall_descriptions_syntax.md for description of individual attributes.</span></span><br><span class="line"><span class="keyword">type</span> SyscallAttrs <span class="keyword">struct</span> &#123;</span><br><span class="line">    Disabled      <span class="keyword">bool</span></span><br><span class="line">    Timeout       <span class="keyword">uint64</span></span><br><span class="line">    ProgTimeout   <span class="keyword">uint64</span></span><br><span class="line">    IgnoreReturn  <span class="keyword">bool</span></span><br><span class="line">    BreaksReturns <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These properties are parsed and serialized according to the tag and the type</span></span><br><span class="line"><span class="comment">// of the corresponding fields.</span></span><br><span class="line"><span class="comment">// IMPORTANT: keep the exact values of "key" tag for existing props unchanged,</span></span><br><span class="line"><span class="comment">// otherwise the backwards compatibility would be broken.</span></span><br><span class="line"><span class="keyword">type</span> CallProps <span class="keyword">struct</span> &#123;</span><br><span class="line">    FailNth <span class="keyword">int</span> <span class="string">`key:"fail_nth"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际保存进变量 data 中的内容如下：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309231414961.png" alt="image-20220309231414961"></p>
<p>通过对上面源码的分析，我发现貌似 syz-sysgen <strong>将整个 <code>prog.SyscallAttrs</code> 结构体的字段名和每个 syscall 所对应的数据，全都转换成了普通字符串型和整型</strong>。看上去这像是要用这些数据来填充 C 语言模板？我们接下来再来看看 writeExecutorSyscalls 函数，看看这里面具体是做了什么。</p>
<blockquote>
<p>writeExecutorSyscalls 函数源码分析位于下文，这里不再赘述。</p>
</blockquote>
<h3 id="2-processJob">2. processJob</h3>
<p>processJob 函数的主要功能是：编译传入的 syzlang AST，分析其中的 syscall 类型信息等，并反序列化为一个 golang 语法源码。</p>
<p>传入 processJob 的参数 <code>job</code>，其结构体声明如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    Target      *targets.Target <span class="comment">// 存放着一些关于特定 OS 特定 arch 的一些常量信息</span></span><br><span class="line">    OK          <span class="keyword">bool</span></span><br><span class="line">    Errors      []<span class="keyword">string</span>        <span class="comment">// 保存报错信息的字符串集合，一条字符串表示一行报错信息</span></span><br><span class="line">    Unsupported <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span> <span class="comment">// 存放不支持的 syscall 集合</span></span><br><span class="line">    ArchData    ArchData        <span class="comment">// 存放待从 worker routine 返回给 main 函数的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，该函数会生成一个 error handler，用于输出错误信息；之后从 ConstFile 结构体中，取出对应 arch 的 consts <strong>字符串-&gt;整型</strong>映射表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `processJob`</span></span><br><span class="line">eh := <span class="function"><span class="keyword">func</span><span class="params">(pos ast.Pos, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    job.Errors = <span class="built_in">append</span>(job.Errors, fmt.Sprintf(<span class="string">"%v: %v\n"</span>, pos, msg))</span><br><span class="line">&#125;</span><br><span class="line">consts := constFile.Arch(job.Target.Arch)</span><br><span class="line">top := descriptions</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/syzkaller-1/image-20220309171903363.png" alt="image-20220309171903363"></p>
<p>之后，对于一些 Linux OS 需要特殊处理的架构，syz-sysgen 设置了过滤器，过滤掉那些文件名中带有 <code>_kvm.txt</code> 后缀的 syzlang，那些 syzlang 将不参与处理；并且将那些不支持的条目将会存放进 <code>job.Unsupported</code> 中，接下来的操作将跳过这些条目：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `processJob`</span></span><br><span class="line"><span class="keyword">if</span> job.Target.OS == targets.Linux &amp;&amp; (job.Target.Arch == targets.ARM || job.Target.Arch == targets.RiscV64) &#123;</span><br><span class="line">    <span class="comment">// Hack: KVM is not supported on ARM anymore. On riscv64 it</span></span><br><span class="line">    <span class="comment">// is not supported yet but might be in the future.</span></span><br><span class="line">    <span class="comment">// Note: syz-extract also ignores this file for arm and riscv64.</span></span><br><span class="line">    top = descriptions.Filter(<span class="function"><span class="keyword">func</span><span class="params">(n ast.Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        pos, typ, name := n.Info()</span><br><span class="line">        <span class="keyword">if</span> !strings.HasSuffix(pos.File, <span class="string">"_kvm.txt"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> *ast.Resource, *ast.Struct, *ast.Call, *ast.TypeDef:</span><br><span class="line">            <span class="comment">// Mimic what pkg/compiler would do with unsupported entries.</span></span><br><span class="line">            <span class="comment">// This is required to keep the unsupported diagnostic below working</span></span><br><span class="line">            <span class="comment">// for kvm entries, otherwise it will not think that kvm entries</span></span><br><span class="line">            <span class="comment">// are not supported on all architectures.</span></span><br><span class="line">            job.Unsupported[typ+<span class="string">" "</span>+name] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了这些 Linux OS 需要过滤的架构以外，syz-sysgen 还需要过滤掉自己开发者人员测试用的 testOS：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `processJob`</span></span><br><span class="line"><span class="keyword">if</span> job.Target.OS == targets.TestOS &#123;</span><br><span class="line">    constInfo := compiler.ExtractConsts(top, job.Target, eh)</span><br><span class="line">    compiler.FabricateSyscallConsts(job.Target, constInfo, consts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中，targets.TestOS 所对应的字符串为 <code>test</code>。</p>
</blockquote>
<p>接下来，syz-sysgen 需要分析 AST 信息，对 syzlang 进行编译：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `processJob`</span></span><br><span class="line">prog := compiler.Compile(top, consts, job.Target, eh)</span><br><span class="line"><span class="keyword">if</span> prog == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> what := <span class="keyword">range</span> prog.Unsupported &#123;</span><br><span class="line">    job.Unsupported[what] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的 Prog 结构体声明如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `processJob`</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Prog is description compilation result.</span></span><br><span class="line"><span class="keyword">type</span> Prog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Resources []*prog.ResourceDesc</span><br><span class="line">    Syscalls  []*prog.Syscall</span><br><span class="line">    Types     []prog.Type</span><br><span class="line">    <span class="comment">// Set of unsupported syscalls/flags.</span></span><br><span class="line">    Unsupported <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Returned if consts was nil.</span></span><br><span class="line">    fileConsts <span class="keyword">map</span>[<span class="keyword">string</span>]*ConstInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译操作和先前 syz-extract 类似，不同的是这次提供了 consts 信息，因此会执行完整的编译过程，分析 syzlang 代码中描述的<strong>全部 syscall 参数类型信息</strong>。返回的 Prog 结构体中：</p>
<ul>
<li>字段 fileConsts 为空</li>
<li>涉及到的类型信息保存在了 Resource 和 Types 字段</li>
<li>syscall 的描述则存放在 Syscalls 字段中。</li>
</ul>
<p>之后便是将分析结果，序列化为 go 语言源代码，留待后续 syz-fuzzer 所使用；序列化后的 golang 代码存放至 <code>sys/&lt;OS&gt;/gen/&lt;arch&gt;.go</code>，例如 <code>sys/linux/gen/amd64.go</code>（<strong>loc: ~11w</strong>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `processJob`</span></span><br><span class="line">sysFile := filepath.Join(*outDir, <span class="string">"sys"</span>, job.Target.OS, <span class="string">"gen"</span>, job.Target.Arch+<span class="string">".go"</span>)</span><br><span class="line">out := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="comment">// generate 执行 golang 序列化操作</span></span><br><span class="line">generate(job.Target, prog, consts, out)</span><br><span class="line">rev := hash.String(out.Bytes())</span><br><span class="line">fmt.Fprintf(out, <span class="string">"const revision_%v = %q\n"</span>, job.Target.Arch, rev)</span><br><span class="line">writeSource(sysFile, out.Bytes())</span><br></pre></td></tr></table></figure>
<p>我们来看看生成出的 golang 代码是什么样的（以 <code>/sys/linux/gen/amd64.go</code> 为例）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AUTOGENERATED FILE</span></span><br><span class="line"><span class="comment">// +build !codeanalysis</span></span><br><span class="line"><span class="comment">// +build !syz_target syz_target,syz_os_linux,syz_arch_amd64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> gen</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> . <span class="string">"github.com/google/syzkaller/prog"</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">"github.com/google/syzkaller/sys/linux"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    RegisterTarget(&amp;Target&#123;OS: <span class="string">"linux"</span>, Arch: <span class="string">"amd64"</span>, Revision: revision_amd64, PtrSize: <span class="number">8</span>, PageSize: <span class="number">4096</span>, NumPages: <span class="number">4096</span>, DataOffset: <span class="number">536870912</span>, LittleEndian: <span class="literal">true</span>, ExecutorUsesShmem: <span class="literal">true</span>, Syscalls: syscalls_amd64, Resources: resources_amd64, Consts: consts_amd64&#125;, types_amd64, InitTarget)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resources_amd64 = []*ResourceDesc&#123;</span><br><span class="line">&#123;Name:<span class="string">"ANYRES16"</span>,Kind:[]<span class="keyword">string</span>&#123;<span class="string">"ANYRES16"</span>&#125;,Values:[]<span class="keyword">uint64</span>&#123;<span class="number">18446744073709551615</span>,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">&#123;Name:<span class="string">"ANYRES32"</span>,Kind:[]<span class="keyword">string</span>&#123;<span class="string">"ANYRES32"</span>&#125;,Values:[]<span class="keyword">uint64</span>&#123;<span class="number">18446744073709551615</span>,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">&#123;Name:<span class="string">"ANYRES64"</span>,Kind:[]<span class="keyword">string</span>&#123;<span class="string">"ANYRES64"</span>&#125;,Values:[]<span class="keyword">uint64</span>&#123;<span class="number">18446744073709551615</span>,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">&#123;Name:<span class="string">"IMG_DEV_VIRTADDR"</span>,Kind:[]<span class="keyword">string</span>&#123;<span class="string">"IMG_DEV_VIRTADDR"</span>&#125;,Values:[]<span class="keyword">uint64</span>&#123;<span class="number">0</span>&#125;&#125;,</span><br><span class="line">&#123;Name:<span class="string">"IMG_HANDLE"</span>,Kind:[]<span class="keyword">string</span>&#123;<span class="string">"IMG_HANDLE"</span>&#125;,Values:[]<span class="keyword">uint64</span>&#123;<span class="number">0</span>&#125;&#125;,</span><br><span class="line">&#123;Name:<span class="string">"assoc_id"</span>,Kind:[]<span class="keyword">string</span>&#123;<span class="string">"assoc_id"</span>&#125;,Values:[]<span class="keyword">uint64</span>&#123;<span class="number">0</span>&#125;&#125;,</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> syscalls_amd64 = []*Syscall&#123;</span><br><span class="line">&#123;NR:<span class="number">43</span>,Name:<span class="string">"accept"</span>,CallName:<span class="string">"accept"</span>,Args:[]Field&#123;</span><br><span class="line">&#123;Name:<span class="string">"fd"</span>,Type:Ref(<span class="number">11199</span>)&#125;,</span><br><span class="line">&#123;Name:<span class="string">"peer"</span>,Type:Ref(<span class="number">10021</span>)&#125;,</span><br><span class="line">&#123;Name:<span class="string">"peerlen"</span>,Type:Ref(<span class="number">10305</span>)&#125;,</span><br><span class="line">&#125;,Ret:Ref(<span class="number">11199</span>)&#125;,</span><br><span class="line">&#123;NR:<span class="number">43</span>,Name:<span class="string">"accept$alg"</span>,CallName:<span class="string">"accept"</span>,Args:[]Field&#123;</span><br><span class="line">&#123;Name:<span class="string">"fd"</span>,Type:Ref(<span class="number">11202</span>)&#125;,</span><br><span class="line">&#123;Name:<span class="string">"peer"</span>,Type:Ref(<span class="number">4943</span>)&#125;,</span><br><span class="line">&#123;Name:<span class="string">"peerlen"</span>,Type:Ref(<span class="number">4943</span>)&#125;,</span><br><span class="line">&#125;,Ret:Ref(<span class="number">11203</span>)&#125;,</span><br><span class="line">&#123;NR:<span class="number">43</span>,Name:<span class="string">"accept$ax25"</span>,CallName:<span class="string">"accept"</span>,Args:[]Field&#123;</span><br><span class="line">&#123;Name:<span class="string">"fd"</span>,Type:Ref(<span class="number">11204</span>)&#125;,</span><br><span class="line">&#123;Name:<span class="string">"peer"</span>,Type:Ref(<span class="number">10033</span>)&#125;,</span><br><span class="line">&#123;Name:<span class="string">"peerlen"</span>,Type:Ref(<span class="number">10305</span>)&#125;,</span><br><span class="line">&#125;,Ret:Ref(<span class="number">11204</span>)&#125;,</span><br><span class="line">&#123;NR:<span class="number">43</span>,Name:<span class="string">"accept$inet"</span>,CallName:<span class="string">"accept"</span>,Args:[]Field&#123;</span><br><span class="line">&#123;Name:<span class="string">"fd"</span>,Type:Ref(<span class="number">11223</span>)&#125;,</span><br><span class="line">&#123;Name:<span class="string">"peer"</span>,Type:Ref(<span class="number">10025</span>)&#125;,</span><br><span class="line">&#123;Name:<span class="string">"peerlen"</span>,Type:Ref(<span class="number">10305</span>)&#125;,</span><br><span class="line">&#125;,Ret:Ref(<span class="number">11223</span>)&#125;,</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> types_amd64 = []Type&#123;</span><br><span class="line">&amp;ArrayType&#123;TypeCommon:TypeCommon&#123;TypeName:<span class="string">"array"</span>,TypeAlign:<span class="number">1</span>,IsVarlen:<span class="literal">true</span>&#125;,Elem:Ref(<span class="number">17155</span>)&#125;,</span><br><span class="line">&amp;ArrayType&#123;TypeCommon:TypeCommon&#123;TypeName:<span class="string">"array"</span>,TypeAlign:<span class="number">1</span>,IsVarlen:<span class="literal">true</span>&#125;,Elem:Ref(<span class="number">14707</span>),Kind:<span class="number">1</span>,RangeEnd:<span class="number">32</span>&#125;,</span><br><span class="line">&amp;ArrayType&#123;TypeCommon:TypeCommon&#123;TypeName:<span class="string">"array"</span>,TypeAlign:<span class="number">1</span>,IsVarlen:<span class="literal">true</span>&#125;,Elem:Ref(<span class="number">14707</span>),Kind:<span class="number">1</span>,RangeEnd:<span class="number">8</span>&#125;,</span><br><span class="line">&amp;ArrayType&#123;TypeCommon:TypeCommon&#123;TypeName:<span class="string">"array"</span>,TypeAlign:<span class="number">1</span>,IsVarlen:<span class="literal">true</span>&#125;,Elem:Ref(<span class="number">14560</span>)&#125;,</span><br><span class="line">&amp;ArrayType&#123;TypeCommon:TypeCommon&#123;TypeName:<span class="string">"array"</span>,TypeAlign:<span class="number">1</span>,IsVarlen:<span class="literal">true</span>&#125;,Elem:Ref(<span class="number">14575</span>)&#125;,</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> consts_amd64 = []ConstValue&#123;</span><br><span class="line">&#123;<span class="string">"ABS_CNT"</span>,<span class="number">64</span>&#125;,</span><br><span class="line">&#123;<span class="string">"ABS_MAX"</span>,<span class="number">63</span>&#125;,</span><br><span class="line">&#123;<span class="string">"ACL_EXECUTE"</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="string">"ACL_GROUP"</span>,<span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="string">"ACL_GROUP_OBJ"</span>,<span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="string">"ACL_LINK"</span>,<span class="number">1</span>&#125;,</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> revision_amd64 = <span class="string">"e61403f96ca19fc071d8e9c946b2259a2804c68e"</span></span><br></pre></td></tr></table></figure>
<p>其中，init 函数用于将当前这个 linux amd64 的 target，注册进 <code>targets</code> 数组中以供后续 syz-fuzzer 取出使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targets = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Target)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterTarget</span><span class="params">(target *Target, types []Type, initArch <span class="keyword">func</span>(target *Target)</span>)</span> &#123;</span><br><span class="line">    key := target.OS + <span class="string">"/"</span> + target.Arch</span><br><span class="line">    <span class="keyword">if</span> targets[key] != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"duplicate target %v"</span>, key))</span><br><span class="line">    &#125;</span><br><span class="line">    target.initArch = initArch</span><br><span class="line">    target.types = types</span><br><span class="line">    targets[key] = target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>amd64.go 内部还声明了多个数组，其中：</p>
<ul>
<li><code>resources_amd64</code> 数组：存放着每个 syzlang 代码中声明的 resource 变量</li>
<li><code>syscalls_amd64</code> 数组：存放着每个 syscall 所对应的名称、调用号，以及各个参数的名称和类型。</li>
<li><code>types_amd64</code> 数组：每个类型的具体信息，例如数组、结构体类型信息等等</li>
<li><code>consts_amd64</code>：存放 consts 字符串与整型的映射关系</li>
<li><code>revision_amd64</code>：amd64.go 源码的哈希值</li>
</ul>
<p>回到 generateExecutorSyscall 函数，该函数最后便是调用 generateExecutorSyscalls 函数来创建 Executor 的 syscall 信息，并将其返回给上层调用者（即 main 函数）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kiprey: in function `processJob`</span></span><br><span class="line">job.ArchData = generateExecutorSyscalls(job.Target, prog.Syscalls, rev)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Don't print warnings, they are printed in syz-check.</span></span><br><span class="line">job.Errors = <span class="literal">nil</span></span><br><span class="line">job.OK = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这个信息将用于生成 syz-exexcutor 的 C 代码。</p>
<h3 id="3-generateExecutorSyscalls">3. generateExecutorSyscalls</h3>
<p>该函数的作用是，为生成 syz-executor 准备相关的 syscall 数据，因此起名神似 <strong>生成（generate） executor 的 syscall 数据</strong>。</p>
<p>初始时，generateExecutorSyscalls 函数创建了一个 ArchData 结构体，这个结构体将一层层返回给 main 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data := ArchData&#123;</span><br><span class="line">    Revision:   rev,</span><br><span class="line">    GOARCH:     target.Arch,</span><br><span class="line">    PageSize:   target.PageSize,</span><br><span class="line">    NumPages:   target.NumPages,</span><br><span class="line">    DataOffset: target.DataOffset,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> target.ExecutorUsesForkServer &#123;</span><br><span class="line">    data.ForkServer = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> target.ExecutorUsesShmem &#123;</span><br><span class="line">    data.Shmem = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<strong>目标 OS &amp; arch</strong> 所对应的 target 结构体，设置了对 ForkServer 和 Shmem（共享内存）的支持，则在 data 中将这两个字段设置为 true，这样 syz-executor 便可以使用这两个技术加速 fuzz 过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyscallAttrs represents call attributes in syzlang.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This structure is the source of truth for the all other parts of the system.</span></span><br><span class="line"><span class="comment">// pkg/compiler uses this structure to parse descriptions.</span></span><br><span class="line"><span class="comment">// syz-sysgen uses this structure to generate code for executor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Only bool's and uint64's are currently supported.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See docs/syscall_descriptions_syntax.md for description of individual attributes.</span></span><br><span class="line"><span class="keyword">type</span> SyscallAttrs <span class="keyword">struct</span> &#123;</span><br><span class="line">    Disabled      <span class="keyword">bool</span></span><br><span class="line">    Timeout       <span class="keyword">uint64</span></span><br><span class="line">    ProgTimeout   <span class="keyword">uint64</span></span><br><span class="line">    IgnoreReturn  <span class="keyword">bool</span></span><br><span class="line">    BreaksReturns <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来便是一个<strong>遍历 syscalls 数组中的各个 Syscall 类型结构体</strong>的 for 循环。这个 for 循环虽然看上去一眼难以看懂，但实际上，它只是将变量 c 中<strong>结构体 SyscallAttrs 里的各个字段取出，并将其依次存放至整型数组 attrVals</strong>，然后再使用生成的 attrVals 数组进一步生成 SyscallData 结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> syscalls &#123;</span><br><span class="line">    <span class="keyword">var</span> attrVals []<span class="keyword">uint64</span></span><br><span class="line">    attrs := reflect.ValueOf(c.Attrs)</span><br><span class="line">    last := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; attrs.NumField(); i++ &#123;</span><br><span class="line">        attr := attrs.Field(i)</span><br><span class="line">        val := <span class="keyword">uint64</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">switch</span> attr.Type().Kind() &#123;</span><br><span class="line">            <span class="keyword">case</span> reflect.Bool:</span><br><span class="line">            <span class="keyword">if</span> attr.Bool() &#123;</span><br><span class="line">                val = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> reflect.Uint64:</span><br><span class="line">            val = attr.Uint()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"unsupported syscall attribute type"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        attrVals = <span class="built_in">append</span>(attrVals, val)</span><br><span class="line">        <span class="keyword">if</span> val != <span class="number">0</span> &#123;</span><br><span class="line">            last = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data.Calls = <span class="built_in">append</span>(data.Calls, newSyscallData(target, c, attrVals[:last+<span class="number">1</span>]))</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(data.Calls, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.Calls[i].Name &lt; data.Calls[j].Name</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>以下是 data 变量中所存放信息的一个示例：</p>
<p><img src="/2022/03/syzkaller-1/image-20220309214932071.png" alt="image-20220309214932071"></p>
<p>结构体 SyscallAttrs 定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyscallAttrs represents call attributes in syzlang.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This structure is the source of truth for the all other parts of the system.</span></span><br><span class="line"><span class="comment">// pkg/compiler uses this structure to parse descriptions.</span></span><br><span class="line"><span class="comment">// syz-sysgen uses this structure to generate code for executor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Only bool's and uint64's are currently supported.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See docs/syscall_descriptions_syntax.md for description of individual attributes.</span></span><br><span class="line"><span class="keyword">type</span> SyscallAttrs <span class="keyword">struct</span> &#123;</span><br><span class="line">    Disabled      <span class="keyword">bool</span></span><br><span class="line">    Timeout       <span class="keyword">uint64</span></span><br><span class="line">    ProgTimeout   <span class="keyword">uint64</span></span><br><span class="line">    IgnoreReturn  <span class="keyword">bool</span></span><br><span class="line">    BreaksReturns <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上图所示，由于当前遍历的 SyscallAttrs 结构体（也就是变量 attrs）的值全为默认值0，因此取出来的 Attrs 数组中各元素也为 0:</p>
<p><img src="/2022/03/syzkaller-1/image-20220309215426959.png" alt="image-20220309215426959"></p>
<p>该 for 循环会一次次的将遍历到的 syscall 对应的 SyscallData 添加进<code>data.Calls</code>，其中 <code>newSyscallData</code> 函数所生成的 SyscallData 结构体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sys/syz-sysgen/sysgen.go</span></span><br><span class="line"><span class="keyword">type</span> SyscallData <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name     <span class="keyword">string</span>      <span class="comment">// syzlang 中的调用名，例如 accept$inet</span></span><br><span class="line">    CallName <span class="keyword">string</span>      <span class="comment">// 实际的 syscall 调用名，例如 accept</span></span><br><span class="line">    NR       <span class="keyword">int32</span>       <span class="comment">// syscall 对应的调用号，例如 30</span></span><br><span class="line">    NeedCall <span class="keyword">bool</span>        <span class="comment">// 一个用于后续的 syz-executor 源码生成的标志，后面会提到</span></span><br><span class="line">    Attrs    []<span class="keyword">uint64</span>    <span class="comment">// 存放分析 syzlang 所生成的 SyscallAttrs 数据数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>待整个 for 循环完成后，generateExecutorSyscall 函数将会把上面所生成的 data.Calls 数组进行排序，并返回 data 变量。</p>
<h3 id="4-writeExecutorSyscalls">4. writeExecutorSyscalls</h3>
<p>作用：该函数将生成 syz-executor 所使用的 C 代码头文件。</p>
<p>通读一下代码可以很容易的发现，该函数将会尝试填充两个 C 代码模板，并将填充后的 C 代码输出至 <code>executor/defs.h</code> 和 <code>executor/syscalls.h</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeExecutorSyscalls</span><span class="params">(data *ExecutorData)</span></span> &#123;</span><br><span class="line">    osutil.MkdirAll(filepath.Join(*outDir, <span class="string">"executor"</span>))</span><br><span class="line">    sort.Slice(data.OSes, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data.OSes[i].GOOS &lt; data.OSes[j].GOOS</span><br><span class="line">    &#125;)</span><br><span class="line">    buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    <span class="keyword">if</span> err := defsTempl.Execute(buf, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tool.Failf(<span class="string">"failed to execute defs template: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    writeFile(filepath.Join(*outDir, <span class="string">"executor"</span>, <span class="string">"defs.h"</span>), buf.Bytes())</span><br><span class="line">    buf.Reset()</span><br><span class="line">    <span class="keyword">if</span> err := syscallsTempl.Execute(buf, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tool.Failf(<span class="string">"failed to execute syscalls template: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    writeFile(filepath.Join(*outDir, <span class="string">"executor"</span>, <span class="string">"syscalls.h"</span>), buf.Bytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，defsTempl 代码模板如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defsTempl = template.Must(template.New(<span class="string">""</span>).Parse(<span class="string">`// AUTOGENERATED FILE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct call_attrs_t &#123; &#123;&#123;range $attr := $.CallAttrs&#125;&#125;</span></span><br><span class="line"><span class="string">    uint64_t &#123;&#123;$attr&#125;&#125;;&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct call_props_t &#123; &#123;&#123;range $attr := $.CallProps&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;$attr.Type&#125;&#125; &#123;&#123;$attr.Name&#125;&#125;;&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#define read_call_props_t(var, reader) &#123; \&#123;&#123;range $attr := $.CallProps&#125;&#125;</span></span><br><span class="line"><span class="string">    (var).&#123;&#123;$attr.Name&#125;&#125; = (&#123;&#123;$attr.Type&#125;&#125;)(reader); \&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;&#123;range $os := $.OSes&#125;&#125;</span></span><br><span class="line"><span class="string">#if GOOS_&#123;&#123;$os.GOOS&#125;&#125;</span></span><br><span class="line"><span class="string">#define GOOS "&#123;&#123;$os.GOOS&#125;&#125;"</span></span><br><span class="line"><span class="string">&#123;&#123;range $arch := $os.Archs&#125;&#125;</span></span><br><span class="line"><span class="string">#if GOARCH_&#123;&#123;$arch.GOARCH&#125;&#125;</span></span><br><span class="line"><span class="string">#define GOARCH "&#123;&#123;.GOARCH&#125;&#125;"</span></span><br><span class="line"><span class="string">#define SYZ_REVISION "&#123;&#123;.Revision&#125;&#125;"</span></span><br><span class="line"><span class="string">#define SYZ_EXECUTOR_USES_FORK_SERVER &#123;&#123;.ForkServer&#125;&#125;</span></span><br><span class="line"><span class="string">#define SYZ_EXECUTOR_USES_SHMEM &#123;&#123;.Shmem&#125;&#125;</span></span><br><span class="line"><span class="string">#define SYZ_PAGE_SIZE &#123;&#123;.PageSize&#125;&#125;</span></span><br><span class="line"><span class="string">#define SYZ_NUM_PAGES &#123;&#123;.NumPages&#125;&#125;</span></span><br><span class="line"><span class="string">#define SYZ_DATA_OFFSET &#123;&#123;.DataOffset&#125;&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">`</span>))</span><br></pre></td></tr></table></figure>
<p>代码模板看上去有点难以理解，因为其中混杂着 C 宏定义与模板描述，因此不妨从 <code>executor/defs.h</code> 中直接看看生成好的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AUTOGENERATED FILE</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">call_attrs_t</span> &#123;</span> </span><br><span class="line">    <span class="keyword">uint64_t</span> disabled;</span><br><span class="line">    <span class="keyword">uint64_t</span> timeout;</span><br><span class="line">    <span class="keyword">uint64_t</span> prog_timeout;</span><br><span class="line">    <span class="keyword">uint64_t</span> ignore_return;</span><br><span class="line">    <span class="keyword">uint64_t</span> breaks_returns;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">call_props_t</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> fail_nth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_call_props_t(var, reader) &#123; \</span></span><br><span class="line">    (var).fail_nth = (<span class="keyword">int</span>)(reader); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GOOS_akaros</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOOS <span class="meta-string">"akaros"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GOARCH_amd64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOARCH <span class="meta-string">"amd64"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_REVISION <span class="meta-string">"361c8bb8e04aa58189bcdd153dc08078d629c0b5"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_EXECUTOR_USES_FORK_SERVER 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_EXECUTOR_USES_SHMEM 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_NUM_PAGES 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_DATA_OFFSET 536870912</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GOOS_linux</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOOS <span class="meta-string">"linux"</span></span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GOARCH_amd64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOARCH <span class="meta-string">"amd64"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_REVISION <span class="meta-string">"e61403f96ca19fc071d8e9c946b2259a2804c68e"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_EXECUTOR_USES_FORK_SERVER 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_EXECUTOR_USES_SHMEM 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_NUM_PAGES 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_DATA_OFFSET 536870912</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GOOS_windows</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOOS <span class="meta-string">"windows"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GOARCH_amd64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOARCH <span class="meta-string">"amd64"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_REVISION <span class="meta-string">"8967babc353ed00daaa6992068d3044bad9d29fa"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_EXECUTOR_USES_FORK_SERVER 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_EXECUTOR_USES_SHMEM 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_NUM_PAGES 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYZ_DATA_OFFSET 536870912</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到， syz-sysgen 会将把先前 <code>generateExecutorSyscalls</code> 函数中所生成的 ArchData 结构体数据，导出至 executor/defs.h 文件中，供后续编译 syz-executor 所使用。syz-sysgen 将所有OS所有架构所对应的 ArchData 数据全部导出至一个文件中，并使用宏定义来选择启用哪一部分的数据。</p>
<p>另一个代码模板 syscallsTempl 的内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nolint: lll</span></span><br><span class="line"><span class="keyword">var</span> syscallsTempl = template.Must(template.New(<span class="string">""</span>).Parse(<span class="string">`// AUTOGENERATED FILE</span></span><br><span class="line"><span class="string">// clang-format off</span></span><br><span class="line"><span class="string">&#123;&#123;range $os := $.OSes&#125;&#125;</span></span><br><span class="line"><span class="string">#if GOOS_&#123;&#123;$os.GOOS&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;range $arch := $os.Archs&#125;&#125;</span></span><br><span class="line"><span class="string">#if GOARCH_&#123;&#123;$arch.GOARCH&#125;&#125;</span></span><br><span class="line"><span class="string">const call_t syscalls[] = &#123;</span></span><br><span class="line"><span class="string">&#123;&#123;range $c := $arch.Calls&#125;&#125;    &#123;"&#123;&#123;$c.Name&#125;&#125;", &#123;&#123;$c.NR&#125;&#125;&#123;&#123;if or $c.Attrs $c.NeedCall&#125;&#125;, &#123; &#123;&#123;- range $attr := $c.Attrs&#125;&#125;&#123;&#123;$attr&#125;&#125;, &#123;&#123;end&#125;&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;if $c.NeedCall&#125;&#125;, (syscall_t)&#123;&#123;$c.CallName&#125;&#125;&#123;&#123;end&#125;&#125;&#125;,</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;&#125;;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">`</span>))</span><br></pre></td></tr></table></figure>
<p>乍看上去还是有点难懂，我们不妨看看 <code>executor/syscalls.h</code> 示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GOOS_linux</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GOARCH_amd64</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">call_t</span> syscalls[] = &#123;</span><br><span class="line">    &#123;<span class="string">"accept"</span>, <span class="number">43</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"accept$alg"</span>, <span class="number">43</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"accept$ax25"</span>, <span class="number">43</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"accept$inet"</span>, <span class="number">43</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"accept$inet6"</span>, <span class="number">43</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"accept$netrom"</span>, <span class="number">43</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"accept$nfc_llcp"</span>, <span class="number">43</span>&#125;,</span><br><span class="line">    ....,</span><br><span class="line">    &#123;<span class="string">"bind"</span>, <span class="number">49</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"bind$802154_dgram"</span>, <span class="number">49</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"bind$802154_raw"</span>, <span class="number">49</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"bind$alg"</span>, <span class="number">49</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"bind$ax25"</span>, <span class="number">49</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"bind$bt_hci"</span>, <span class="number">49</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"bind$bt_l2cap"</span>, <span class="number">49</span>&#125;,</span><br><span class="line">    ....</span><br><span class="line">    &#123;<span class="string">"prctl$PR_CAPBSET_DROP"</span>, <span class="number">167</span>, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, &#125;&#125;,</span><br><span class="line">    &#123;<span class="string">"prctl$PR_CAPBSET_READ"</span>, <span class="number">167</span>, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, &#125;&#125;,</span><br><span class="line">    &#123;<span class="string">"prctl$PR_CAP_AMBIENT"</span>, <span class="number">167</span>, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, &#125;&#125;,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">...</span><br><span class="line">#endif</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>executor/syscalls.h</code> 下会存放着各个 syzlang 中<strong>所声明的 syscall 名与 syscall调用号的映射关系</strong>，以及可能有的 <strong>SyscallData</strong>。同时，也是使用宏定义来控制使用<strong>哪个OS哪个Arch下的 syscalls 映射关系</strong>。</p>
<blockquote>
<p>再贴一下 SyscallData 结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyscallData <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name     <span class="keyword">string</span></span><br><span class="line">    CallName <span class="keyword">string</span></span><br><span class="line">    NR       <span class="keyword">int32</span></span><br><span class="line">    NeedCall <span class="keyword">bool</span></span><br><span class="line">    Attrs    []<span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-小结">5. 小结</h3>
<p>当执行完 syz-extractor 为每个 syslang 文件生成一个常量映射表 <code>.const</code> 文件后，syz-sysgen 便会利用常量映射表，来彻底的解析 syzlang 源码，获取到其中声明的类型信息与 syscall 参数依赖关系。</p>
<p>当这些信息全都收集完毕后，syz-sysgen 便会将这些数据全部序列化为 go 文件，以供后续 syz-fuzzer 所使用。除此之外，syz-sysgen 还会创建 executor/defs.h 和 executor/syscalls.h，将部分信息导出至 C 头文件，以供后续 syz-executor 编译使用。</p>
<p>简单地说，syz-sysgen 解析 syzlang 文件，并为 syz-fuzzer 和 syz-executor 的编译运行做准备。</p>
<p>调试用的 vscode launch.json 文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"syzgenLaunch"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"go"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"mode"</span>: <span class="string">"auto"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;fileDirname&#125;"</span>,</span><br><span class="line">            <span class="attr">"env"</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"/usr/class/syzkaller"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [<span class="string">"-src"</span>, <span class="string">"/usr/class/syzkaller"</span>, <span class="string">"-out"</span>, <span class="string">"/tmp"</span>] </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://kiprey.github.io/2022/03/syzkaller-1/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/syzkaller/" rel="tag">syzkaller</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/04/dirty-pipe/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Linux Dirty Pipe CVE-2022-0847 漏洞分析
          
        </div>
      </a>
    
    
      <a href="/2022/03/other_paper_notes/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">论文笔记随笔 - 1</div>
      </a>
    
  </nav>

   
 
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '5f6c407f4cb8963d03ac',
    clientSecret: '1d6faa663a735dbfd671990187d6e62b32498560',
    repo: 'kiprey.github.io',
    owner: 'kiprey',
    admin: ['kiprey'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2025
        <i class="ri-heart-fill heart_icon"></i> Kiprey
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        <!-- <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
        <script>
            $(document).ready(function() {
                var int1 = setInterval(fixCount1, 100);
                var int2 = setInterval(fixCount2, 100);

                var busuanziValueSiteOffset = 100000000000;
                var busuanziValuePageOffset = 200000000000;
                function fixCount1() {
                    if ($("#busuanzi_value_site_uv").css("display") != "none") {
                        clearInterval(int1);
                        $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + busuanziValueSiteOffset);
                    }
                }
                function fixCount2() {
                    if ($("#busuanzi_value_page_pv").css("display") != "none") {
                        clearInterval(int2);
                        $("#busuanzi_value_page_pv").html(parseInt($("#busuanzi_value_page_pv").html()) + busuanziValuePageOffset);
                    }
                }
            });
        </script> -->
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Kiprey&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>


<!-- mermaid -->

  <script src='https://cdn.bootcdn.net/ajax/libs/mermaid/8.5.2/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

<!-- baiduSpider auto push -->

  <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>


    
  </div>
</body>

</html>