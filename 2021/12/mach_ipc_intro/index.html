<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="MacOS, Mach, IPC,漏洞挖掘, 调试, 代码, 计算机科学, Kiprey, Blog, 二进制，信息安全" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    MacOSX Mach IPC 入门 |  Kiprey&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?acff2772e1f74a625e1e26c280afa6c2";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="Kiprey's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-mach_ipc_intro"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  MacOSX Mach IPC 入门
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/12/mach_ipc_intro/" class="article-date">
  <time datetime="2021-12-23T16:00:00.000Z" itemprop="datePublished">2021-12-24</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">14.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">63 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、简介">一、简介</h2>
<p>Mach，是一个<strong>面向通信</strong>的操作系统<strong>微内核</strong>，其基本工作单位为 <code>task</code>（而不是 process）。Mach 内核提供了一种 IPC 机制，而 XNU 的大多数服务也建立在 Mach IPC 和 Mach Task 上。</p>
<p>Mach 有多种抽象的基本概念，其中一部分分别是 <code>task</code>、<code>thread</code>、<code>port</code>、<code>message</code>、<code>memory object</code>。</p>
<p>Mach 微内核作为 MacOS XNU 内核的组成部分，接管了相当重要的一部分功能。其中最著名的莫过于 Mach IPC 进程间通信机制。</p>
<p>本人将在这里简单记录一下 Mach IPC 部分机理。</p>
<blockquote>
<p>需要注意的是，这是本人第一次接触 Mach IPC，因此其中可能会有一部分陈述或者说明存在问题，还请各位师傅不吝指出。</p>
</blockquote>
<a id="more"></a>
<h2 id="二、Mach-Task-Thread">二、Mach Task &amp; Thread</h2>
<p>Mach 将传统的 UNIX <strong>进程</strong>抽象拆分成了 <code>task</code> 和 <code>thread</code>。其中：</p>
<ul>
<li>
<p>task 是一个<strong>执行环境与静态实体</strong>。它并不直接执行计算，而是提供了一个框架，其他实体（例如线程）在其中执行。内核中的BSD 进程（类似 Unix 进程）与 Mach task 有着一一对应的关系。</p>
<p>task 还是<strong>资源分配的基本单元</strong>。那些与 BSD 进程所关联的资源被包含于 task 中。</p>
<p>同时每个 task 也代表了<strong>保护边界</strong>。在获取访问权限前，不同 task 不能访问其他的 task 中的资源。</p>
</li>
<li>
<p>thread 是 Mach 中实际执行的实体，也是 task 的控制流执行点。它在 task 的上下文中执行。</p>
<p>thread 执行的代码驻留在其 task 中的地址空间中。每个 task 中包含 0 至多个 thread。</p>
</li>
</ul>
<p>通过上面的说明，我们也可以将 task 这个概念，间接理解成传统意义上的 process（是不是非常的相似:)）</p>
<blockquote>
<p>需要注意的是：一旦创建了 task，那么<strong>任何持有着 task identifier 的用户都可以修改 task</strong>。</p>
</blockquote>
<h2 id="三、Mach-Port">三、Mach Port</h2>
<h3 id="1-概念">1. 概念</h3>
<p>Mach Port 是受内核保护的<strong>单向</strong> IPC 通道、功能和名称。在 Mach <strong>内核</strong>中，mach port 被实现成一个<strong>有限长度</strong>且<strong>被内核所维护</strong>的<strong>消息队列</strong>，与 Linux Pipe 有些相似，都会因为队列满或者队列空而阻塞，其基本操作为发送和接收消息。该队列是<strong>多生产者、单消费者</strong>队列，只能有单个 receive right。</p>
<p>Port 的这种抽象以及相关的操作是 mach 通信的基础。一个端口有着与之相关联的内核管理权限，而每个 task 都必须拥有 port 的适当权限才能操作它。当一个 Mach Message 被发送至某个 task 中，只有具有<strong>接收权限</strong>的 Mach port 才能接收该 Message，并将其从队列中删除。</p>
<blockquote>
<p>例如这种权限设置可以允许一些任务向给定的端口发送信息，或者指定一些任务可以接收到发送给它的信息。</p>
</blockquote>
<p>mach port 在 Mach 中<strong>非常重要</strong>，它表示着<strong>对象的引用</strong>，代表了OS中各类服务、资源等抽象。在 Mach 内核中，相当多的数据结构、服务等等都用 mach port 表示；而用户也可以通过对应的 mach port 来访问到 tasks、threads以及 memory objects。</p>
<p>Mach port 的名称是一个整数，但与文件描述符不同， Mach 端口不会通过 fork 而隐式继承。</p>
<h3 id="2-Port-Right">2. Port Right</h3>
<p>每个 Mach Port 都有着对应 port 的<strong>权限（right）</strong>，以下是 Mac OSX 所定义的部分 port right 类型：</p>
<ul>
<li><code>MACH_PORT_RIGHT_SEND</code>：表示权限拥有者可以向该端口发送信息</li>
<li><code>MACH_PORT_RIGHT_RECEIVE</code>：表示权限拥有者可以从该端口中获取 Message</li>
<li><code>MACH_PORT_RIGHT_SEND_ONCE</code>：表示发送方只能发送一次 Message。不管该权限是否被销毁，该句柄始终会发送一条消息。</li>
<li><code>MACH_PORT_RIGHT_PORT_SET</code>：表示多个 port name 的集合，可以被看做是多个端口接收权限的集合。端口集可用于同时侦听多个端口，类似于 Unix epoll 机制等等。</li>
<li><code>MACH_PORT_RIGHT_DEAD_NAME</code>：只是一个占位符。若某个端口的权限被销毁后，则该端口的<strong>所有现有句柄的权限</strong>都将转换成 dead name（即无效权限）。dead name 机制是为了防止所接管的<strong>端口名</strong>被过早重用。</li>
</ul>
<p>若某个端口的<strong>接收权限</strong>被释放时，则将该端口视为<strong>被销毁</strong>。注意接收句柄在任何时候都只能有一个 task 所持有。</p>
<p>而<strong>端口权限名称（port right name）<strong>是某个 task 用来</strong>引用所持有的 port right</strong> 的特定整数值，有点类似文件描述符。需要注意的是每个port right name 只会在原始任务的上下文中有意义，这意味着即便将该名称发送给其他的任务，该任务也无法使用该名称访问对应的 mach port。（这也再次类似于文件描述符）</p>
<blockquote>
<p>这个 port right name 正是我们日常见到最多的**用户层（注意必须指定是用户层）**中 <code>mach_port_t</code> 类型的值。</p>
<p>注意还有一个 port name（和 port right name 不一样），在用户层中是 mach_port_name_t 类型的值。</p>
</blockquote>
<p><strong>port name 和 right 的关系</strong>，类似于 Unix 中<strong>文件描述符</strong>和文件描述符<strong>权限</strong>的关系。但是，<strong>请勿直接将 right 等同于 权限</strong>，mach port right 和<strong>权限</strong>二字仍然有着较大的差别。</p>
<h2 id="四、Mach-Message">四、Mach Message</h2>
<p>Mach IPC message 是线程之间相互通信的数据对象，它也是 tasks 之间通信的典型方式。一个 Message 中可能包含实际的数据（即内联数据），或者包含指向外联数据（out-of-line，OOL）的指针；后者是针对大数据传输的一种优化。</p>
<p>Mach Message 由以下几个部分组成：</p>
<ul>
<li>
<p>一个<strong>强制</strong>要有的消息头 （mach_msg_header_t 类型）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span>     msgh_bits;           <span class="comment">// 一些消息标志位</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>     msgh_size;           <span class="comment">// 消息 header + body + data 的总大小</span></span><br><span class="line">  <span class="keyword">mach_port_t</span>         msgh_remote_port;    <span class="comment">// 目标 port right</span></span><br><span class="line">  <span class="keyword">mach_port_t</span>         msgh_local_port;     <span class="comment">// 辅助 port right</span></span><br><span class="line">  <span class="keyword">mach_port_name_t</span>    msgh_voucher_port;</span><br><span class="line">  <span class="keyword">mach_msg_id_t</span>       msgh_id;            <span class="comment">// 传递 mach msg 时不会使用该字段，用户可自行设置该字段</span></span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一个可选的消息 body （mach_msg_body_t 类型）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="keyword">mach_msg_body_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，消息 body <strong>并不只是</strong>这一个简简单单的结构体，请看下面的图。</p>
</blockquote>
</li>
<li>
<p>用户待发送的数据 data</p>
</li>
<li>
<p>一个可选的 tailer（mach_msg_trailer_t 类型）。该字段只与发送方有关。这个我们将在下面讲到。</p>
</li>
</ul>
<p>一个简单 Message 示例。其中 header.size 描述的是 header + data 的总大小：</p>
<p><img src="/2021/12/mach_ipc_intro/5e0d813f5ca94df8896453137156d751.png" alt="Mach消息发送机制_第1张图片"></p>
<p>一个复杂 Message 示例。与简单消息不同的是，复杂消息还包含了 body 信息，用以额外说明一些信息。</p>
<p><img src="/2021/12/mach_ipc_intro/bbb233c138ce4e8595162d43dcb90e5a.png" alt="Mach消息发送机制_第2张图片"></p>
<p>这个是更详细的说明图：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20211230113611950.png" alt="image-20211230113611950"></p>
<p>这是一个复杂 Message 的具体代码样例。其中 <strong>body 部分包括 <code>msgBody</code> 字段和 <code>ports[1]</code> 字段</strong>，待发送 data 部分为 <code>notifyHeader</code> 字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PingMsg</span> &#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_header_t</span>           msgHdr;</span><br><span class="line">    <span class="keyword">mach_msg_body_t</span>             msgBody;</span><br><span class="line">    <span class="keyword">mach_msg_port_descriptor_t</span>  ports[<span class="number">1</span>];</span><br><span class="line">    OSNotificationHeader64      notifyHeader __attribute__ ((packed));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Message 的具体使用与机理将在下面使用中慢慢说明。</p>
<h2 id="五、Mach-API-入门使用">五、Mach API 入门使用</h2>
<h3 id="1-单向-Mach-通信示例">1. 单向 Mach 通信示例</h3>
<h4 id="代码示例">*. 代码示例</h4>
<p>以下是使用 Mach 低级 API 进行 IPC 的一个简单例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;servers/bootstrap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 bootstrap 中查询并获取一个 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = bootstrap_look_up(bootstrap_port, <span class="string">"io.github.kiprey"</span>, &amp;port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bootstrap_look_up() returned port right name %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造待发送的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">        <span class="keyword">char</span> texts[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> integer;</span><br><span class="line">    &#125; message;</span><br><span class="line"></span><br><span class="line">    message.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>);</span><br><span class="line">    message.header.msgh_remote_port = port;</span><br><span class="line">    message.header.msgh_local_port = MACH_PORT_NULL;</span><br><span class="line">    message.header.msgh_size = <span class="keyword">sizeof</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(message.texts, <span class="string">"kiprey_texts"</span>);</span><br><span class="line">    message.integer = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其发送</span></span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr = mach_msg_send(&amp;message.header);</span><br><span class="line">    assert(mr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"message is sent.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个带有接收权限的 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mach_port_allocate() created port right name %d\n"</span>, port);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给该 port 再增加一个发送权限</span></span><br><span class="line">    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">    assert (kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mach_port_insert_right() inserted a send right\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该端口的 send right 发送给 bootstrap，这样就可以被其他进程所查询</span></span><br><span class="line">    kr = bootstrap_register(bootstrap_port, <span class="string">"io.github.kiprey"</span>, port);</span><br><span class="line">    assert (kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bootstrap_register()'ed our port\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 message</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">        <span class="keyword">char</span> texts[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> integer;</span><br><span class="line">        <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">    &#125; message;</span><br><span class="line"></span><br><span class="line">    message.header.msgh_size = <span class="keyword">sizeof</span>(message);</span><br><span class="line">    message.header.msgh_local_port = port;</span><br><span class="line">    kr = mach_msg_receive(&amp;message.header);</span><br><span class="line">    assert (kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Got a message\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Text: %s, number: %d\n"</span>, message.texts, message.integer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待 receiver 注册好 port 后再发送信息</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sender();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        receiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20211225192910087.png" alt="image-20211225192910087"></p>
<p>接下来将简单讲讲该例子中所调用的一些用户 API。</p>
<h4 id="a-mach-port-allocate">a. mach_port_allocate</h4>
<p>初始时，接收端调用 <code>mach_port_allocate</code> 创建一个指定权限的 mach port：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_port_t</span> port;</span><br><span class="line"><span class="keyword">kern_return_t</span> kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);</span><br></pre></td></tr></table></figure>
<p>该函数的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kern_return_t</span> <span class="title">mach_port_allocate</span><span class="params">(<span class="keyword">ipc_space_t</span> task,  <span class="keyword">mach_port_right_t</span> right, <span class="keyword">mach_port_name_t</span> *name)</span></span></span><br></pre></td></tr></table></figure>
<p>其中，第一个参数指定当前进程所在的 task。有趣的是，这种<strong>指定 task</strong> 的方式也是通过传递一个 mach port name 来完成。以下是 task_self_trap 函数的源代码，mach_task_self 函数是该函数的 wrapper。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Routine:    task_self_trap [mach trap]</span></span><br><span class="line"><span class="comment"> *  Purpose:</span></span><br><span class="line"><span class="comment"> *      Give the caller send rights for his own task port.</span></span><br><span class="line"><span class="comment"> *  Conditions:</span></span><br><span class="line"><span class="comment"> *      Nothing locked.</span></span><br><span class="line"><span class="comment"> *  Returns:</span></span><br><span class="line"><span class="comment"> *      MACH_PORT_NULL if there are any resource failures</span></span><br><span class="line"><span class="comment"> *      or other errors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_name_t</span></span><br><span class="line">task_self_trap(</span><br><span class="line">    __unused struct task_self_trap_args *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">task_t</span> task = current_task();</span><br><span class="line">    <span class="keyword">ipc_port_t</span> sright;</span><br><span class="line">    <span class="keyword">mach_port_name_t</span> name;</span><br><span class="line"></span><br><span class="line">    sright = retrieve_task_self_fast(task);</span><br><span class="line">    name = ipc_port_copyout_send(sright, task-&gt;itk_space);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个参数指定当前待分配 Mach port 的 right，这里请求的是<strong>接收权限</strong>。根据 xnu 源码，该函数的第二个参数只有以下三种有效：</p>
<ul>
<li><code>MACH_PORT_RIGHT_RECEIVE</code>：创建一个新端口，且当前只有接收权限</li>
<li><code>MACH_PORT_RIGHT_PORT_SET</code>：创建一个空的端口集，其中端口集里没有任何成员</li>
<li><code>MACH_PORT_RIGHT_DEAD_NAME</code> ：创建一个新的 dead name</li>
</ul>
<p>该函数的第三个参数指定 <strong>成功分配 port 时其所存放的位置</strong>，这个没啥好说的，略过。</p>
<h4 id="b-mach-port-insert-right">b. mach_port_insert_right</h4>
<p>作用：将指定的 port right 插入进当前 task 中。</p>
<p>例子中的使用方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给该 port 再增加一个发送权限</span></span><br><span class="line">kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);</span><br></pre></td></tr></table></figure>
<p>其函数声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_port_insert_right(</span><br><span class="line">    <span class="keyword">ipc_space_t</span> task,</span><br><span class="line">    <span class="keyword">mach_port_name_t</span> name,</span><br><span class="line">    <span class="keyword">mach_port_t</span> poly,</span><br><span class="line">    <span class="keyword">mach_msg_type_name_t</span> polyPoly)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，调用者会对新创建的 port （此时只有 receive right） 添加上 send right。这里的 send right 指的是<strong>给当前 port 发送 mach message 的权限</strong>。</p>
<h4 id="c-bootstrap-register-lookup">c. bootstrap_register/lookup</h4>
<p>在 OSX 中，当一个新的 task 被创建时，它会被额外设置一组特殊的Mach port。其中包括：</p>
<ul>
<li>主机端口（host port，itk_host），表示运行该任务的机器。该端口允许 task 获取有关内核和主机的信息。</li>
<li>任务端口（task port，itk_sself），即这个端口引用的任务是自己。这个端口不允许用于控制自生，貌似该端口只能用于获取 task info。</li>
<li>引导端口（bootstrap port，itk_bootstrap），连接到 bootstrap  server（launchd）。</li>
</ul>
<blockquote>
<p>剩余的可以在 <code>osfmk\mach\task_special_ports.h</code> 中了解。</p>
</blockquote>
<p>对应与 task 内核结构体中的字段如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IPC structures */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_self</span>;</span>  <span class="comment">/* not a right, doesn't hold ref */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_nself</span>;</span> <span class="comment">/* not a right, doesn't hold ref */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_sself</span>;</span> <span class="comment">/* a send right */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exception_action</span> <span class="title">exc_actions</span>[<span class="title">EXC_TYPES_COUNT</span>];</span></span><br><span class="line"><span class="comment">/* a send right each valid element  */</span></span><br><span class="line"><span class="comment">// host port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_host</span>;</span>  <span class="comment">/* a send right */</span> </span><br><span class="line"><span class="comment">// bootstrap port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_bootstrap</span>;</span> <span class="comment">/* a send right */</span></span><br><span class="line"><span class="comment">// seatbelt port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_seatbelt</span>;</span>  <span class="comment">/* a send right */</span></span><br><span class="line"><span class="comment">// seatbelt port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_gssd</span>;</span>  <span class="comment">/* yet another send right */</span></span><br><span class="line"><span class="comment">// debug port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_debug_control</span>;</span> <span class="comment">/* send right for debugmode communications */</span></span><br><span class="line"><span class="comment">// task_access port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_task_access</span>;</span> <span class="comment">/* and another send right */</span> </span><br><span class="line"><span class="comment">// resume port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_resume</span>;</span>    <span class="comment">/* a receive right to resume this task */</span></span><br><span class="line"><span class="comment">// 注册端口, 可以调用 mach_ports_register 进行注册</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">itk_registered</span>[<span class="title">TASK_PORT_REGISTER_MAX</span>];</span></span><br><span class="line"><span class="comment">/* all send rights */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">itk_space</span>;</span></span><br></pre></td></tr></table></figure>
<p>可以发现这些 <code>struct ipc_port itk_*</code> 都是特殊的 mach port，每个 task 都会被设置。</p>
<blockquote>
<p>其中，<code>itk_host</code>、<code>itk_bootstrap</code>、<code>itk_seatbelt</code>、<code>itk_gssd</code>、<code>itk_task_access</code> 都是从 parent task 中继承。</p>
</blockquote>
<p>对于 <code>itk_registered</code> 数组来说，用户可以使用 <strong>mach_ports_register</strong> 函数将目标端口注册进该数组中，并使用 <strong>mach_ports_lookup</strong> 进行查询。注册后的 port right 将会填充至 task 结构体中 itk_registered 数组的某个槽。</p>
<p>bootstrap  server 提供一个 port namespace，task 可以在其中注册自己的端口，其他 task 可以查找并向其发送消息。</p>
<p>我们可以将 bootstrap  server 看作一个电话簿：task 可以放置一个<strong>已知且被命名</strong>的值，以对应于该 task 正在监听的 Mach port。</p>
<p>若某个 task 需要向 bootstrap  server 注册服务，则 task 可以使用 <code>bootstrap_register()</code> 函数，该函数接受字符串名称和与之关联的Mach端口。但需要主要的是，Mac OSX 在10.5中弃用了这个函数，因此在编译上面的例子时，编译器会报出一个 Deprecated 的 warnning。</p>
<blockquote>
<p>不过，我们还可以使用 bootstrap_check_in 来取代 bootstrap_register 函数。</p>
</blockquote>
<p>在这个例子中，接收方会将<strong>带有 send right 的 mach port</strong> 注册进 bootstrap 中；那么当<strong>发送方</strong>尝试向 bootstrap 申请获取<strong>接收方</strong>的 port 时，bootstrap 就可以将<strong>当前所注册的 mach port 的 send right</strong> 复制一份给<strong>发送方</strong>。</p>
<p>这样，<strong>发送方</strong>便有了该 mach port 的 send right，可以向该 port 发送数据。而 mach port 的另一端（也就是<strong>接收方</strong>）便可以直接读取到发送方发来的消息。</p>
<h4 id="d-mach-msg">d. mach_msg</h4>
<p>作用：发送 mach message 或者接收 mach message。在这个例子中，发送方和接收方都会间接调用到这个函数来发送或者接收 mach msg。</p>
<p>我们先简单看看 mach_msg 函数的定义，了解该函数各个参数的作用或功能，内核的具体处理方式将在后面讲到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">mach_msg(msg, option, send_size, rcv_size, rcv_name, timeout, notify)</span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> *msg;    <span class="comment">// 指向 Mach message 的指针</span></span><br><span class="line">    <span class="keyword">mach_msg_option_t</span> option;  <span class="comment">// 一些基础标志，例如 MACH_SEND_MSG 或 MACH_RCV_MSG 标志以指定消息是发送还是接收</span></span><br><span class="line">    <span class="keyword">mach_msg_size_t</span> send_size; <span class="comment">// 待发送的消息长度</span></span><br><span class="line">    <span class="keyword">mach_msg_size_t</span> rcv_size;  <span class="comment">// 待接收的消息长度</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> rcv_name;      <span class="comment">// 接收消息的 port </span></span><br><span class="line">    <span class="keyword">mach_msg_timeout_t</span> timeout;<span class="comment">// 指定 mach_msg 最长等待时间</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> notify;        <span class="comment">// 一个通知 port，用于接收通知信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">mach_msg_send(<span class="keyword">mach_msg_header_t</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mach_msg(msg, MACH_SEND_MSG,</span><br><span class="line">            msg-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL,</span><br><span class="line">            MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">mach_msg_receive(<span class="keyword">mach_msg_header_t</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mach_msg(msg, MACH_RCV_MSG,</span><br><span class="line">            <span class="number">0</span>, msg-&gt;msgh_size, msg-&gt;msgh_local_port,</span><br><span class="line">            MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于发送方而言，发送方需要指定 header 的一些字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>); <span class="comment">// 设置下面对应 port 的 mach 信息类型</span></span><br><span class="line">message.header.msgh_remote_port = port;          <span class="comment">// 设置发送端口为目标 port</span></span><br><span class="line">message.header.msgh_local_port = MACH_PORT_NULL; <span class="comment">// 没有辅助端口</span></span><br><span class="line">message.header.msgh_size = <span class="keyword">sizeof</span>(message);</span><br></pre></td></tr></table></figure>
<h3 id="2-双向-mach-通信示例">2. 双向 mach 通信示例</h3>
<p>上面的例子已经为我们展示了单向 mach 通信的基本方式（<strong>sender-&gt; receiver</strong>）。接下来尝试让<strong>receiver</strong>也能发送数据给<strong>sender</strong>，实现双向通信。</p>
<p>需要注意的是， mach 是单向通信，因此必须让 <strong>sender 再创建一个新的 port</strong>（即 sender 持有新 mach port，注意此时 receiver 已经持有了一个旧的 mach port），并<strong>让 receiver 持有该 port 的 send right</strong> 才能实现双向通信。而这就涉及到一个问题：<strong>如何传递 mach port right？</strong></p>
<p>一种解法是，再次利用 bootstrap 做中转，这确实是一个解决方法，但是不够优雅。实际上，因为此时的 sender 是可以通过已有的 mach port 将信息发送给 receiver，因此我们可以<strong>利用这个 mach port ，将新的 mach port 的 send right 发送给 receiver</strong>。</p>
<p><strong>因为 Mach message 是支持传输 port right 的。</strong></p>
<p>以下是整个通信的完整过程，其中 bob 是 sender, alice 是 receiver：</p>
<p><img src="/2021/12/mach_ipc_intro/mach-messages-bidirectional.png" alt="img"></p>
<p>现在的问题是，如何把权限发送过去？我们分别看看两种不同的方式。</p>
<h4 id="a-reply-port">a. reply port</h4>
<h5 id="1-sender">1) sender</h5>
<p>当 sender 从 bootstrap 中获取到了 receiver mach port 的 send right 后，sender 便可以给 receiver 发送信息。这是之前的 message header 设置方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message.header.msgh_bits = MACH_MSGH_BITS(<span class="comment">/* remote */</span> MACH_MSG_TYPE_COPY_SEND, <span class="comment">/* local */</span><span class="number">0</span>);</span><br><span class="line">message.header.msgh_remote_port = port;</span><br><span class="line">message.header.msgh_local_port = MACH_PORT_NULL;</span><br></pre></td></tr></table></figure>
<p>但在这里，我们将使用一个新的 message 方式：</p>
<ol>
<li>在 msgh_bits 中额外设置 local port 的 right 为 MACH_MSG_TYPE_MAKE_SEND_ONCE，这会使得<strong>对端只能向该端口发送一次信息</strong>。</li>
<li>在 msgh_local_port 字段中放入本地自己新建立的 replyPort 端口。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">message.header.msgh_bits = MACH_MSGH_BITS_SET(</span><br><span class="line">    <span class="comment">/* remote */</span> MACH_MSG_TYPE_COPY_SEND,</span><br><span class="line">    <span class="comment">/* local */</span> MACH_MSG_TYPE_MAKE_SEND_ONCE,</span><br><span class="line">    <span class="comment">/* voucher */</span> <span class="number">0</span>,</span><br><span class="line">    <span class="comment">/* other */</span> <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 注： 上面这条语句等价于 </span></span><br><span class="line"><span class="comment">// message.header.msgh_bits = MACH_MSGH_BITS(/* remote */ MACH_MSG_TYPE_COPY_SEND, /* local */ MACH_MSG_TYPE_MAKE_SEND_ONCE);</span></span><br><span class="line"></span><br><span class="line">message.header.msgh_remote_port = port;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与之前单向通信设置 MACH_PORT_NULL 不同，这里设置了一个 sender 自己创建并带有 send right 的 mach port</span></span><br><span class="line">message.header.msgh_local_port = replyPort;</span><br></pre></td></tr></table></figure>
<p>那么此时再使用 mach_msg 发送这条 message，则 sender 发送来的信息中将包含一个 replyPort。</p>
<blockquote>
<p>这个 replyPort 有什么用呢？事实上，对面的 receiver 将会通过这个传过去的 replyPort，向这边的 sender 发送信息。</p>
</blockquote>
<p>注意所设置的 <code>message.header.msgh_bits</code>，其中 <code>local</code> 部分对应的是 <strong>MACH_MSG_TYPE_MAKE_SEND_ONCE</strong>， 这意味着 replyPort 只能被 receiver 使用一次 send 操作。</p>
<h5 id="2-receiver">2) receiver</h5>
<p>当 receiver 接收 message 时，sender 发送信息时的 <code>remote_port</code> 和 <code>local_port</code>，分别一一对应于 receiver 所接收到 message 中的 <code>local_port</code> 和 <code>remote_port</code>。</p>
<p>因此此时 receiver 方的 message 中 <code>remote_port</code>  不会是 MACH_PORT_NULL，而是<strong>先前设置的 <code>replyPort</code></strong>。</p>
<p>因此接下来 receiver 便可以通过这个 replyPort 向 sender 发送信息。但需要注意的是，在发送信息给 replyPort 时，其 message.header.msgh_bits 字段，必须设置成 <code>MACH_MSG_TYPE_MAKE_SEND_ONCE</code>，即和发送该端口过来时所设置的位一致。</p>
<p>因为受到发送 replyPort 方（即 sender 方）的设置或者限制， receivier 方只能发送一次信息至 replyPort  中。</p>
<h5 id="3-代码示例">3) 代码示例</h5>
<p>以下是完整的代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;servers/bootstrap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_msg_send_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">    <span class="keyword">char</span> texts[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">int</span> integer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_msg_receive_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mach_msg_send_t</span> <span class="title">recv_content</span>;</span></span><br><span class="line">    <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从 bootstrap 中查询并获取一个 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = bootstrap_look_up(bootstrap_port, <span class="string">"io.github.kiprey"</span>, &amp;port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] bootstrap_look_up() returned port right name %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造待发送的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mach_msg_send_t</span> <span class="title">send_msg</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(send_msg.texts, <span class="string">"Hello, I'm sender."</span>);</span><br><span class="line">    send_msg.integer = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建立一个 receiver 发送的 replyPort</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> replyPort;</span><br><span class="line">    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;replyPort);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] mach_port_allocate() created port right name %d\n"</span>, replyPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给该 port 再增加一个发送权限</span></span><br><span class="line">    kr = mach_port_insert_right(mach_task_self(), replyPort, replyPort, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] mach_port_insert_right() inserted a send right\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里，remote port 的发送权限是 MACH_MSG_TYPE_MAKE_SEND_ONCE</span></span><br><span class="line">    send_msg.header.msgh_bits           = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);</span><br><span class="line">    send_msg.header.msgh_remote_port    = port;</span><br><span class="line">    send_msg.header.msgh_local_port     = replyPort;</span><br><span class="line">    send_msg.header.msgh_size           = <span class="keyword">sizeof</span>(send_msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其发送</span></span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr = mach_msg_send(&amp;send_msg.header);</span><br><span class="line">    assert(mr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] Message is sent.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 message</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mach_msg_receive_t</span> <span class="title">recv_msg</span>;</span></span><br><span class="line">    recv_msg.recv_content.header.msgh_size          = <span class="keyword">sizeof</span>(recv_msg);</span><br><span class="line">    recv_msg.recv_content.header.msgh_local_port    = replyPort;</span><br><span class="line">    kr = mach_msg_receive(&amp;recv_msg.recv_content.header);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] Got a Message\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] Text: %s | number: %d\n"</span>, recv_msg.recv_content.texts, recv_msg.recv_content.integer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个带有接收权限的 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] mach_port_allocate() created port right name %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给该 port 再增加一个发送权限</span></span><br><span class="line">    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] mach_port_insert_right() inserted a send right\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该端口的 send right 发送给 bootstrap，这样就可以被其他进程所查询</span></span><br><span class="line">    kr = bootstrap_register(bootstrap_port, <span class="string">"io.github.kiprey"</span>, port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] bootstrap_register()'ed our port\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 message</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mach_msg_receive_t</span> <span class="title">recv_msg</span>;</span></span><br><span class="line">    recv_msg.recv_content.header.msgh_size          = <span class="keyword">sizeof</span>(recv_msg);</span><br><span class="line">    recv_msg.recv_content.header.msgh_local_port    = port;</span><br><span class="line">    kr = mach_msg_receive(&amp;recv_msg.recv_content.header);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] Got a Message\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] Text: %s | number: %d | remote_port: %d\n"</span>, recv_msg.recv_content.texts, recv_msg.recv_content.integer, recv_msg.recv_content.header.msgh_remote_port);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mach_msg_send_t</span> <span class="title">send_msg</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(send_msg.texts, <span class="string">"Hello, I'm receiver."</span>);</span><br><span class="line">    send_msg.integer = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里的发送权限是 MACH_MSG_TYPE_MAKE_SEND_ONCE</span></span><br><span class="line">    send_msg.header.msgh_bits           = recv_msg.recv_content.header.msgh_bits &amp; MACH_MSGH_BITS_REMOTE_MASK;</span><br><span class="line">    send_msg.header.msgh_remote_port    = recv_msg.recv_content.header.msgh_remote_port;</span><br><span class="line">    send_msg.header.msgh_local_port     = MACH_PORT_NULL;</span><br><span class="line">    send_msg.header.msgh_size           = <span class="keyword">sizeof</span>(send_msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其发送</span></span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr = mach_msg_send(&amp;send_msg.header);</span><br><span class="line">    assert(mr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] Message is sent.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        sender();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        receiver();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20211229213351546.png" alt="image-20211229213351546"></p>
<p>那么可能会有疑问，为什么 replyPort 的 msg 类型要设置成 MACH_MSG_TYPE_MAKE_<strong>SEND_ONCE</strong>？能不能设置成 MACH_MSG_TYPE_<strong>COPY_SEND</strong> ？实际上是可以的，并且后者可以允许 receiver 多次向 replyPort 发送 mach message，而不是<strong>只有一次</strong>。</p>
<h4 id="b-complex-message">b. complex message</h4>
<p>还记得之前描述 Mach Message 的结构么？Mach message 既可以传递简单信息（即之前的那些示例）又可以传递复杂信息（即接下来要讲的）。现在，我们将尝试使用<strong>复杂</strong> mach message 来传递一个通信 mach port。</p>
<blockquote>
<p>为了简化说明，这里假设上面的内容已经完全理解。</p>
</blockquote>
<h5 id="1-sender-2">1) sender</h5>
<p>现在， sender 需要尝试将自己新建好的 replyPort（已完成包括 alloc, insert right 等操作） 发给 receiver，那该怎么做呢？</p>
<p>其实可以直接在<strong>消息主体</strong>中，传递<strong>端口描述符</strong>。这里需要先引入一下待发送的 mach msg 结构类型定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">  <span class="keyword">mach_msg_port_descriptor_t</span> descriptor;</span><br><span class="line">&#125; <span class="keyword">mach_msg_complex_send_t</span>;</span><br></pre></td></tr></table></figure>
<p>其中，header 自不必说；<code>msgh_descriptor_count</code> 说明接下来将会有多少个 descriptor；而<code>mach_msg_port_descriptor_t</code> 类型的 descriptor 字段将会描述一些关于待传递 port 的信息。</p>
<p>每个 <code>descriptor</code> 不管是什么类型，都会占用 40 字节。以下是最原始的 descriptor 的类型声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">natural_t</span>                     pad1;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>               pad2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>                  pad3 : <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">mach_msg_descriptor_type_t</span>    type : <span class="number">8</span>;</span><br><span class="line">&#125; <span class="keyword">mach_msg_type_descriptor_t</span>;</span><br></pre></td></tr></table></figure>
<p>而端口描述符的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">mach_port_t</span>                   name;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>               pad1;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>                  pad2 : <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">mach_msg_type_name_t</span>          disposition : <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">mach_msg_descriptor_type_t</span>    type : <span class="number">8</span>;</span><br><span class="line">&#125; <span class="keyword">mach_msg_port_descriptor_t</span>;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>
<p><code>name</code>：待传递的 port。这里要设置为 <strong>replyPort</strong></p>
</li>
<li>
<p><code>disposition</code>：待传递 port 的 right。这里设置为 <strong>MACH_MSG_TYPE_PORT_SEND</strong></p>
<p>一共有以下几种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Values received/carried in messages.  Tells the receiver what</span></span><br><span class="line"><span class="comment"> *  sort of port right he now has.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  MACH_MSG_TYPE_PORT_NAME is used to transfer a port name</span></span><br><span class="line"><span class="comment"> *  which should remain uninterpreted by the kernel.  (Port rights</span></span><br><span class="line"><span class="comment"> *  are not transferred, just the port name.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_PORT_NONE         0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_PORT_NAME         15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_PORT_RECEIVE      MACH_MSG_TYPE_MOVE_RECEIVE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_PORT_SEND         MACH_MSG_TYPE_MOVE_SEND</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_PORT_SEND_ONCE    MACH_MSG_TYPE_MOVE_SEND_ONCE</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>type</code>：待传递的类型。这里要设置为 <strong>MACH_MSG_PORT_DESCRIPTOR</strong></p>
<p>由于 descriptor 的类型<strong>不只是端口描述符一种</strong>，因此需要<strong>显式为 descriptor 指定类型</strong>，以便于内核处理。共有以下几种类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_PORT_DESCRIPTOR                0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_OOL_DESCRIPTOR                 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_OOL_PORTS_DESCRIPTOR           2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_OOL_VOLATILE_DESCRIPTOR        3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_GUARDED_PORT_DESCRIPTOR        4</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">send_msg.msgh_descriptor_count      = <span class="number">1</span>;</span><br><span class="line">send_msg.descriptor.name            = replyPort;</span><br><span class="line">send_msg.descriptor.disposition     = MACH_MSG_TYPE_PORT_SEND;</span><br><span class="line">send_msg.descriptor.type            = MACH_MSG_PORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>最后执行 mach_msg_send 之前，别忘记向 msgh_bits 字段中添加  MACH_MSGH_BITS_COMPLEX，以指定该信息为<strong>复杂信息</strong>。否则这些描述符只会被解释成<strong>内联信息</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里，要指定待发送的信息格式为 complex</span></span><br><span class="line">send_msg.header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>, <span class="number">0</span>, MACH_MSGH_BITS_COMPLEX);</span><br></pre></td></tr></table></figure>
<h5 id="2-receiver-2">2) receiver</h5>
<p>接收端只需接收发送端发来的数据，并取出端口描述符中的 port name，即可开始通信。</p>
<p>要做的事情较为简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待 message</span></span><br><span class="line"><span class="keyword">mach_msg_complex_receive_t</span> recv_msg;</span><br><span class="line">recv_msg.recv_content.header.msgh_size          = <span class="keyword">sizeof</span>(recv_msg);</span><br><span class="line">recv_msg.recv_content.header.msgh_local_port    = port;</span><br><span class="line">kr = mach_msg_receive(&amp;recv_msg.recv_content.header);</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_msg_simple_send_t</span> send_msg;</span><br><span class="line"><span class="built_in">strcpy</span>(send_msg.texts, <span class="string">"Hello, I'm receiver."</span>);</span><br><span class="line">send_msg.integer = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">send_msg.header.msgh_bits           = recv_msg.recv_content.descriptor.disposition;</span><br><span class="line">send_msg.header.msgh_remote_port    = recv_msg.recv_content.descriptor.name;</span><br><span class="line">send_msg.header.msgh_local_port     = MACH_PORT_NULL;</span><br><span class="line">send_msg.header.msgh_size           = <span class="keyword">sizeof</span>(send_msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其发送</span></span><br><span class="line"><span class="keyword">mach_msg_return_t</span> mr = mach_msg_send(&amp;send_msg.header);</span><br></pre></td></tr></table></figure>
<h5 id="3-代码示例-2">3) 代码示例</h5>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;servers/bootstrap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">    <span class="keyword">char</span> texts[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">int</span> integer;</span><br><span class="line">&#125; <span class="keyword">mach_msg_simple_send_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_simple_send_t</span> recv_content;</span><br><span class="line">    <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">mach_msg_simple_receive_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">  <span class="keyword">mach_msg_port_descriptor_t</span> descriptor;</span><br><span class="line">&#125; <span class="keyword">mach_msg_complex_send_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_complex_send_t</span> recv_content;</span><br><span class="line">    <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">mach_msg_complex_receive_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 等待一小会，让 receiver 注册一下 bootstrap</span></span><br><span class="line">    usleep(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 从 bootstrap 中查询并获取一个 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = bootstrap_look_up(bootstrap_port, <span class="string">"io.github.kiprey"</span>, &amp;port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] bootstrap_look_up() returned port right name %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造待发送的信息</span></span><br><span class="line">    <span class="keyword">mach_msg_complex_send_t</span> send_msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建立一个 receiver 发送的 replyPort</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> replyPort;</span><br><span class="line">    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;replyPort);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] mach_port_allocate() created port right name %d\n"</span>, replyPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给该 port 再增加一个发送权限</span></span><br><span class="line">    kr = mach_port_insert_right(mach_task_self(), replyPort, replyPort, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] mach_port_insert_right() inserted a send right\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里，要指定待发送的信息格式为 complex</span></span><br><span class="line">    send_msg.header.msgh_bits           = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>, <span class="number">0</span>, MACH_MSGH_BITS_COMPLEX);</span><br><span class="line">    send_msg.header.msgh_remote_port    = port;</span><br><span class="line">    send_msg.header.msgh_local_port     = MACH_PORT_NULL;</span><br><span class="line">    send_msg.header.msgh_size           = <span class="keyword">sizeof</span>(send_msg);</span><br><span class="line">    <span class="comment">// 指定只有一个描述符需要传递</span></span><br><span class="line">    send_msg.msgh_descriptor_count      = <span class="number">1</span>;</span><br><span class="line">    send_msg.descriptor.name            = replyPort;</span><br><span class="line">    send_msg.descriptor.disposition     = MACH_MSG_TYPE_PORT_SEND;</span><br><span class="line">    send_msg.descriptor.type            = MACH_MSG_PORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其发送</span></span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr = mach_msg_send(&amp;send_msg.header);</span><br><span class="line">    assert(mr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] Message is sent.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 message</span></span><br><span class="line">    <span class="keyword">mach_msg_simple_receive_t</span> recv_msg;</span><br><span class="line">    recv_msg.recv_content.header.msgh_size          = <span class="keyword">sizeof</span>(recv_msg);</span><br><span class="line">    recv_msg.recv_content.header.msgh_local_port    = replyPort;</span><br><span class="line">    kr = mach_msg_receive(&amp;recv_msg.recv_content.header);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] Got a Message\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] Text: %s | number: %d\n"</span>, recv_msg.recv_content.texts, recv_msg.recv_content.integer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个带有接收权限的 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] mach_port_allocate() created port right name %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给该 port 再增加一个发送权限</span></span><br><span class="line">    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] mach_port_insert_right() inserted a send right\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该端口的 send right 发送给 bootstrap，这样就可以被其他进程所查询</span></span><br><span class="line">    kr = bootstrap_register(bootstrap_port, <span class="string">"io.github.kiprey"</span>, port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] bootstrap_register()'ed our port\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 message</span></span><br><span class="line">    <span class="keyword">mach_msg_complex_receive_t</span> recv_msg;</span><br><span class="line">    recv_msg.recv_content.header.msgh_size          = <span class="keyword">sizeof</span>(recv_msg);</span><br><span class="line">    recv_msg.recv_content.header.msgh_local_port    = port;</span><br><span class="line">    kr = mach_msg_receive(&amp;recv_msg.recv_content.header);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    assert(recv_msg.recv_content.msgh_descriptor_count == <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] Got a Message\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] remote_port: %d\n"</span>, recv_msg.recv_content.descriptor.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mach_msg_simple_send_t</span> send_msg;</span><br><span class="line">    <span class="built_in">strcpy</span>(send_msg.texts, <span class="string">"Hello, I'm receiver."</span>);</span><br><span class="line">    send_msg.integer = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里的发送权限是 MACH_MSG_TYPE_MAKE_SEND_ONCE</span></span><br><span class="line">    send_msg.header.msgh_bits           = recv_msg.recv_content.descriptor.disposition;</span><br><span class="line">    send_msg.header.msgh_remote_port    = recv_msg.recv_content.descriptor.name;</span><br><span class="line">    send_msg.header.msgh_local_port     = MACH_PORT_NULL;</span><br><span class="line">    send_msg.header.msgh_size           = <span class="keyword">sizeof</span>(send_msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其发送</span></span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr = mach_msg_send(&amp;send_msg.header);</span><br><span class="line">    assert(mr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] Message is sent.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fork() ? sender() : receiver();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20211229233517941.png" alt="image-20211229233517941"></p>
<h3 id="3-mach-OOL-通信">3. mach OOL  通信</h3>
<p>当某个进程需要传递<strong>大量</strong>数据给对端时，simple message 中的内联数据已经无法满足我们的需求了（因为将数据拷贝进内联数据的开销是相当大的）。因此，我们可以试着使用 mach complex message 中的 <strong>OOL 描述符</strong>来<strong>传递内存页</strong>。</p>
<h4 id="a-sender">a. sender</h4>
<p>首先，我们需要定义一下复杂 mach msg 的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">    <span class="keyword">mach_msg_ool_descriptor_t</span> descriptor;</span><br><span class="line">&#125; <span class="keyword">mach_msg_complex_send_t</span>;</span><br></pre></td></tr></table></figure>
<p>注意到消息体中的描述符为 <code>mach_msg_ool_descriptor_t</code> 类型。该类型的结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>*                         address;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__LP64__)</span></span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>               size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">boolean_t</span>                     deallocate: <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">mach_msg_copy_options_t</span>       copy: <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>                  pad1: <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">mach_msg_descriptor_type_t</span>    type: <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>               size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">mach_msg_ool_descriptor_t</span>;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>
<p>address 字段：存放待发送内存页面的基地址。</p>
</li>
<li>
<p>size 字段：待发送内存长度。</p>
</li>
<li>
<p>deallocate 字段：发送内存页面后，指定发送者<strong>是否需要隐式释放</strong>已发送的内存页面（例如自动调用 vm_deallocate），通常是 false。</p>
<p>这个字段可以将 <strong>内存复制</strong> 转换成 <strong>内存移动</strong>，即将发送方的内存页移动到接收方的进程中，内存处理效率更高。</p>
</li>
<li>
<p>copy 字段：指定内核<strong>以什么方式来复制</strong>发送过来的内存页面。共有两种方式：</p>
<ul>
<li>MACH_MSG_VIRTUAL_COPY：允许内核<strong>选择任何机制</strong>来传输数据。通常内核会先<strong>复制虚拟页面，共享物理页面</strong>，直到实际写入操作的发生再来进行数据复制操作，即写时复制。</li>
<li>MACH_MSG_PHYSICAL_COPY：内核会实际复制数据至<strong>新的物理页</strong>中。</li>
</ul>
</li>
<li>
<p>type 字段：指定当前 descriptor 的类型，这里必须为 <strong>MACH_MSG_OOL_DESCRIPTOR</strong></p>
</li>
</ul>
<p>接下来，sender 需要创建一个虚拟页面，并在该页面上写入一些数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">vm_size_t</span> len = vm_page_size;</span><br><span class="line"><span class="keyword">if</span> (vm_allocate(mach_task_self(), (<span class="keyword">vm_address_t</span> *)&amp;buf, len,</span><br><span class="line">                VM_PROT_READ | VM_PROT_WRITE) != KERN_SUCCESS)</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">"This is a buf message from sender."</span>);</span><br></pre></td></tr></table></figure>
<p>然后设置 Message，并将其发送：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里，要指定待发送的信息格式为 complex</span></span><br><span class="line">send_msg.header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>, <span class="number">0</span>, MACH_MSGH_BITS_COMPLEX);</span><br><span class="line">send_msg.header.msgh_remote_port = port;</span><br><span class="line">send_msg.header.msgh_local_port = MACH_PORT_NULL;</span><br><span class="line">send_msg.header.msgh_size = <span class="keyword">sizeof</span>(send_msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 OOL 描述符信息</span></span><br><span class="line">send_msg.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">send_msg.descriptor.address = buf;</span><br><span class="line">send_msg.descriptor.copy = MACH_MSG_VIRTUAL_COPY;</span><br><span class="line">send_msg.descriptor.deallocate = <span class="literal">false</span>;</span><br><span class="line">send_msg.descriptor.size = len;</span><br><span class="line">send_msg.descriptor.type = MACH_MSG_OOL_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<h4 id="b-receiver">b. receiver</h4>
<p>当接收方接收这个 mach message 时，在接收方的地址空间中，内核将<strong>新分配一块内存</strong>用于存放接收到的数据。</p>
<p>原先有一个选项用于<strong>指定内核</strong>将接收到的数据<strong>覆盖至</strong>接收方<strong>指定的内存地址</strong>处（MACH_MSG_OVERWRITE），但这个选项已经被废弃。</p>
<h4 id="c-代码示例">c. 代码示例</h4>
<p>以下是一个简单的代码示例，其中接收方使用 <code>MACH_MSG_ALLOCATE</code> 方式来接收数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;servers/bootstrap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">    <span class="keyword">mach_msg_ool_descriptor_t</span> descriptor;</span><br><span class="line">&#125; <span class="keyword">mach_msg_complex_send_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_complex_send_t</span> recv_content;</span><br><span class="line">    <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">mach_msg_complex_receive_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 等待一小会，让 receiver 注册一下 bootstrap</span></span><br><span class="line">    usleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 从 bootstrap 中查询并获取一个 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">if</span> (bootstrap_look_up(bootstrap_port, <span class="string">"io.github.kiprey"</span>, &amp;port) != KERN_SUCCESS)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] bootstrap_look_up() returned port right name %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造待发送的信息</span></span><br><span class="line">    <span class="keyword">mach_msg_complex_send_t</span> send_msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里，要指定待发送的信息格式为 complex</span></span><br><span class="line">    send_msg.header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>, <span class="number">0</span>, MACH_MSGH_BITS_COMPLEX);</span><br><span class="line">    send_msg.header.msgh_remote_port = port;</span><br><span class="line">    send_msg.header.msgh_local_port = MACH_PORT_NULL;</span><br><span class="line">    send_msg.header.msgh_size = <span class="keyword">sizeof</span>(send_msg);</span><br><span class="line">    <span class="comment">// 指定待传递的地址</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">vm_size_t</span> len = vm_page_size;</span><br><span class="line">    <span class="keyword">if</span> (vm_allocate(mach_task_self(), (<span class="keyword">vm_address_t</span> *)&amp;buf, len,</span><br><span class="line">                    VM_PROT_READ | VM_PROT_WRITE) != KERN_SUCCESS)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">"This is a buf message from sender."</span>);</span><br><span class="line"></span><br><span class="line">    send_msg.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">    send_msg.descriptor.address = buf;</span><br><span class="line">    send_msg.descriptor.copy = MACH_MSG_VIRTUAL_COPY;</span><br><span class="line">    send_msg.descriptor.deallocate = <span class="literal">false</span>;</span><br><span class="line">    send_msg.descriptor.size = len;</span><br><span class="line">    send_msg.descriptor.type = MACH_MSG_OOL_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其发送</span></span><br><span class="line">    <span class="keyword">if</span> (mach_msg_send(&amp;send_msg.header) != KERN_SUCCESS)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] Message is sent, buf address: %#p\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个带有接收权限的 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">if</span> (mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port) != KERN_SUCCESS)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] mach_port_allocate() created port right name %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给该 port 再增加一个发送权限</span></span><br><span class="line">    <span class="keyword">if</span> (mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND) != KERN_SUCCESS)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] mach_port_insert_right() inserted a send right\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该端口的 send right 发送给 bootstrap，这样就可以被其他进程所查询</span></span><br><span class="line">    <span class="keyword">if</span> (bootstrap_register(bootstrap_port, <span class="string">"io.github.kiprey"</span>, port) != KERN_SUCCESS)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] bootstrap_register()'ed our port\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 message</span></span><br><span class="line">    <span class="keyword">mach_msg_complex_receive_t</span> recv_msg;</span><br><span class="line">    recv_msg.recv_content.header.msgh_size = <span class="keyword">sizeof</span>(recv_msg);</span><br><span class="line">    recv_msg.recv_content.header.msgh_local_port = port;</span><br><span class="line">    <span class="keyword">if</span> (mach_msg_receive(&amp;recv_msg.recv_content.header) != KERN_SUCCESS)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    assert(recv_msg.recv_content.msgh_descriptor_count == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = recv_msg.recv_content.descriptor.address;</span><br><span class="line">    <span class="keyword">size_t</span> len = recv_msg.recv_content.descriptor.size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] Got a Message\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] recv buf address: %#p, len: %d, content: %s\n"</span>, buf, len, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fork() ? sender() : receiver();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20211230091913991.png" alt="image-20211230091913991"></p>
<h3 id="4-Message-Trailer">4. Message Trailer</h3>
<p>接收方接收到的 Mach message 会包含一个 trailer 结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">    <span class="keyword">char</span> texts[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">int</span> integer;</span><br><span class="line">&#125; <span class="keyword">mach_msg_send_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_send_t</span> recv_content;</span><br><span class="line">    <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">mach_msg_receive_t</span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>mach_msg_trailer_t</code>结构体中有如下几种字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_trailer_type_t</span>       msgh_trailer_type;</span><br><span class="line">    <span class="keyword">mach_msg_trailer_size_t</span>       msgh_trailer_size;</span><br><span class="line">&#125; <span class="keyword">mach_msg_trailer_t</span>;</span><br></pre></td></tr></table></figure>
<p>第一个字段表示 trailer 的类型，第二个字段表示接下来 trailer 的个数。</p>
<p>对于 trailer 类型来说，目前 Mac OSX 对用户层来说只提供了一种格式，即<code>MACH_MSG_TRAILER_FORMAT_0</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">mach_msg_trailer_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TRAILER_FORMAT_0       0</span></span><br></pre></td></tr></table></figure>
<p>但是，该格式下有许多种 trailer 的类型，分别有：</p>
<ol>
<li>
<p><strong>mach_msg_trailer_t</strong>：一个空的 trailer，只包含了 type 和 size 字段。</p>
</li>
<li>
<p><strong>mach_msg_seqno_trailer_t</strong>：在第1个结构体的内存布局基础之上，额外增添第3个字段</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">natural_t</span> <span class="keyword">mach_port_seqno_t</span>;            <span class="comment">/* sequence number */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_seqno_t</span>             msgh_seqno;</span><br></pre></td></tr></table></figure>
<p>sequence number，即消息序列号</p>
</li>
<li>
<p><strong>mach_msg_security_trailer_t</strong>：在第2个结构体之上，额外增添第4个字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span>                  val[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">security_token_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">security_token_t</span>              msgh_sender;</span><br></pre></td></tr></table></figure>
<p>security token 的两个整数分别表示发送方的 UID 和 GID。</p>
</li>
<li>
<p><strong>mach_msg_audit_trailer_t</strong>：在第3个结构体之上，额外增添第5个字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The audit token is an opaque token which identifies</span></span><br><span class="line"><span class="comment"> * Mach tasks and senders of Mach messages as subjects</span></span><br><span class="line"><span class="comment"> * to the BSM audit system.  Only the appropriate BSM</span></span><br><span class="line"><span class="comment"> * library routines should be used to interpret the</span></span><br><span class="line"><span class="comment"> * contents of the audit token as the representation</span></span><br><span class="line"><span class="comment"> * of the subject identity within the token may change</span></span><br><span class="line"><span class="comment"> * over time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span>                  val[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="keyword">audit_token_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">audit_token_t</span>                 msgh_audit;</span><br></pre></td></tr></table></figure>
<p>audit token 中共有 8 个整型，该 token 需要使用其他处理例程来进行解释。</p>
</li>
<li>
<p><strong>mach_msg_context_trailer_t</strong>：在第4个结构体之上，额外增添第6个字段</p>
</li>
<li>
<p><strong>mach_msg_mac_trailer_t</strong>：在第5个结构体之上，额外增添第7个字段</p>
</li>
<li>
<p><strong>mach_msg_max_trailer_t</strong>：在第6个结构体之上，额外增添第8个字段</p>
</li>
</ol>
<blockquote>
<p>可以看到，每一个 trailer 总是嵌套在下一个 trailer 之中，这有利于兼容。</p>
</blockquote>
<p>接收者在接收 mach messag 时，必须<strong>显式指定 mach_msg 函数的 option 字段</strong>，以说明<strong>接收的 trailer 的类型为 FORMAT_0</strong>，同时指定<strong>接收 trailer 时终止接收的那个字段</strong>。请看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待 message</span></span><br><span class="line"><span class="keyword">mach_msg_receive_t</span> message;</span><br><span class="line"><span class="keyword">mach_msg_option_t</span> option = MACH_RCV_MSG </span><br><span class="line">    | MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0) </span><br><span class="line">    | MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER);</span><br><span class="line">kr = mach_msg(&amp;message.recv_content.header, option,</span><br><span class="line">              <span class="number">0</span>, <span class="keyword">sizeof</span>(message), port,</span><br><span class="line">              MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，option 设置了 <code>MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER)</code>，这个操作是为了<strong>指定接收 mach_msg_security_trailer_t 类型</strong>的 trailer，因为<strong>该类型的最后一个字段为 sender</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_RCV_TRAILER_NULL   0 <span class="comment">// mach_msg_trailer_t </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_RCV_TRAILER_SEQNO  1 <span class="comment">// mach_msg_trailer_seqno_t </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_RCV_TRAILER_SENDER 2 <span class="comment">// mach_msg_security_trailer_t </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_RCV_TRAILER_AUDIT  3 <span class="comment">// mach_msg_audit_trailer_t</span></span></span><br></pre></td></tr></table></figure>
<p>以下是一个简单的测试例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;servers/bootstrap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">    <span class="keyword">char</span> texts[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">int</span> integer;</span><br><span class="line">&#125; <span class="keyword">mach_msg_send_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_send_t</span> recv_content;</span><br><span class="line">    <span class="keyword">mach_msg_security_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">mach_msg_receive_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] Current UID(%d) GID(%d)\n"</span>, getuid(), getgid());</span><br><span class="line">    usleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 从 bootstrap 中查询并获取一个 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = bootstrap_look_up(bootstrap_port, <span class="string">"io.github.kiprey"</span>, &amp;port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] bootstrap_look_up() returned port right name %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造待发送的信息</span></span><br><span class="line">    <span class="keyword">mach_msg_send_t</span> message;</span><br><span class="line"></span><br><span class="line">    message.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>);</span><br><span class="line">    message.header.msgh_remote_port = port;</span><br><span class="line">    message.header.msgh_local_port = MACH_PORT_NULL;</span><br><span class="line">    message.header.msgh_size = <span class="keyword">sizeof</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(message.texts, <span class="string">"Hello, I'm sender"</span>);</span><br><span class="line">    message.integer = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其发送</span></span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr = mach_msg_send(&amp;message.header);</span><br><span class="line">    assert(mr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[sender] Message is sent.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个带有接收权限的 mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] mach_port_allocate() created port right name %d\n"</span>, port);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给该 port 再增加一个发送权限</span></span><br><span class="line">    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">    assert (kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] mach_port_insert_right() inserted a send right\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该端口的 send right 发送给 bootstrap，这样就可以被其他进程所查询</span></span><br><span class="line">    kr = bootstrap_register(bootstrap_port, <span class="string">"io.github.kiprey"</span>, port);</span><br><span class="line">    assert (kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] bootstrap_register()'ed our port\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 message</span></span><br><span class="line">    <span class="keyword">mach_msg_receive_t</span> message;</span><br><span class="line">    <span class="keyword">mach_msg_option_t</span> option = MACH_RCV_MSG </span><br><span class="line">                            | MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0) </span><br><span class="line">                            | MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER);</span><br><span class="line">    kr = mach_msg(&amp;message.recv_content.header, option,</span><br><span class="line">            <span class="number">0</span>, <span class="keyword">sizeof</span>(message), port,</span><br><span class="line">            MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">    assert (kr == KERN_SUCCESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] Got a message\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] Text: %s, number: %d\n"</span>, message.recv_content.texts, message.recv_content.integer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[receiver] Security token = UID(%u) GID(%u)\n"</span>, </span><br><span class="line">           message.trailer.msgh_sender.val[<span class="number">0</span>],  <span class="comment">// sender's user ID </span></span><br><span class="line">           message.trailer.msgh_sender.val[<span class="number">1</span>]); <span class="comment">// sender's group ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    fork() ? sender() : receiver();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20211230155320740.png" alt="image-20211230155320740"></p>
<h2 id="六、部分内核类型介绍">六、部分内核类型介绍</h2>
<h3 id="1-ipc-space">1. ipc_space</h3>
<p>对于 task 结构体中，其内部存在一个 <code>struct ipc_space *itk_space</code> 的字段，以存放当前 task 所使用的 IPC 信息，其结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> &#123;</span></span><br><span class="line">    <span class="keyword">lck_spin_t</span>    is_lock_data;</span><br><span class="line">    <span class="keyword">ipc_space_refs_t</span> is_bits;    <span class="comment">/* holds refs, active, growing */</span></span><br><span class="line">    <span class="keyword">ipc_entry_num_t</span> is_table_size;    <span class="comment">/* current size of table */</span></span><br><span class="line">    <span class="keyword">ipc_entry_num_t</span> is_table_free;    <span class="comment">/* count of free elements */</span></span><br><span class="line">    <span class="keyword">ipc_entry_t</span> is_table;        <span class="comment">/* an array of entries */</span></span><br><span class="line">    <span class="keyword">task_t</span> is_task;                 <span class="comment">/* associated task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_table_size</span> *<span class="title">is_table_next</span>;</span> <span class="comment">/* info for larger table */</span></span><br><span class="line">    <span class="keyword">ipc_entry_num_t</span> is_low_mod;    <span class="comment">/* lowest modified entry during growth */</span></span><br><span class="line">    <span class="keyword">ipc_entry_num_t</span> is_high_mod;    <span class="comment">/* highest modified entry during growth */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bool_gen</span> <span class="title">bool_gen</span>;</span>       <span class="comment">/* state for boolean RNG */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> is_entropy[IS_ENTROPY_CNT]; <span class="comment">/* pool of entropy taken from RNG */</span></span><br><span class="line">    <span class="keyword">int</span> is_node_id;            <span class="comment">/* HOST_LOCAL_NODE, or remote node if proxy space */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>字段 <code>is_table</code> 指向一个元素类型为 <code>struct ipc_entry</code> 的数组，长度为 <code>is_table_size</code>，通常用户层使用的 mach port name （整型表示）将会映射到内核层的该结构体。<code>is_table</code> 在创建时就会存放一些初始条目。</p>
<p>字段 <code>is_bits</code> 包含了较多的控制信息，例如引用计数、当前 ipc_space <strong>是否激活(active)</strong> 以及<strong>当前 ipc_space是否正在增大内存空间(growing)</strong>。其中 growing 位是为了<strong>防止条件竞争</strong>所设定的一个简单比特。内核使用 ipc_space 时，如果发现当前 ipc_space 的 is_table 大小不够，则会尝试进行 grow 操作；但如果<strong>当前</strong>内核线程发现<strong>当前 ipc_space 正在被其他内核线程 growing 时</strong>，则会<strong>先休眠(is_write_sleep)</strong>，直到其他线程完成处理后再来进行接下来的操作。</p>
<p>当某个 mach port 的 <strong>receive right 被释放</strong>了，则这个 mach port 便<strong>视为被释放</strong>了，若此时持有该 mach port 的引用为 0 ，则 is_table 中对应的 ipc_entry 结构体将被<strong>移动至 is_table_free 中</strong>，并且被释放的 mach port 的所有 right 都被更改为 MACH_PORT_RIGHT_DEAD_NAME，表示这些 right 全都 dead。</p>
<blockquote>
<p>这种机制是为了，防止所接管的 port name 被过早的重用。</p>
</blockquote>
<p>若当前的 ipc_space 需要创建一个新的 ipc_entry 时，首先 ipc_space 会尝试从 is_table_free 中取出最早被释放的 ipc_entry（即 <strong>is_table_free 为 FIFO</strong>）并重用；但若 is_table_free 为空，则将尝试 <strong>扩大（grow）</strong> ipc_space，并插入一个新的 ipc_entry 结构体。</p>
<blockquote>
<p>需要注意的是，即便某个 mach port 的 receive right 已经被释放了，那么如果该 mach port 的引用不为 0 （此时 mach port 的各个 right 为 Dead name），则在下次分配 mach port 时，仍然不能重用该 mach port name。</p>
</blockquote>
<h3 id="2-ipc-entry">2. ipc_entry</h3>
<p>用户层的 mach port name（整数表示）实际上对应至内核中 <code>task-&gt;ipc_space-&gt;is_table</code> 上的某个 ipc_entry 条目。而 ipc_entry 结构声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> *<span class="title">ie_object</span>;</span></span><br><span class="line">    <span class="keyword">ipc_entry_bits_t</span> ie_bits;</span><br><span class="line">    <span class="keyword">mach_port_index_t</span> ie_index;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">mach_port_index_t</span> next;        <span class="comment">/* next in freelist, or...  */</span></span><br><span class="line">        <span class="keyword">ipc_table_index_t</span> request;    <span class="comment">/* dead name request notify */</span></span><br><span class="line">    &#125; index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ie_object</code> 指针字段，实际指向的结构体有两种：<code>ipc_port</code>、<code>ipc_pset</code>。</p>
<p><code>ie_bits</code> 标志位字段保存了给定 port name 所代表的 right 类型。</p>
<h3 id="3-ipc-port">3. ipc_port</h3>
<p>ipc_port  结构体，对应于单个 mach port。该结构体记录了 Mach message 队列、mach port 的接收方和发送方 port、内核存储的相关数据等等。这些字段不一一解释，有用到再说。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Initial sub-structure in common with ipc_pset</span></span><br><span class="line"><span class="comment">     * First element is an ipc_object second is a</span></span><br><span class="line"><span class="comment">     * message queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">receiver</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">destination</span>;</span></span><br><span class="line">        <span class="keyword">ipc_port_timestamp_t</span> timestamp;</span><br><span class="line">    &#125; data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">ipc_kobject_t</span> kobject;</span><br><span class="line">        <span class="keyword">ipc_importance_task_t</span> imp_task;</span><br><span class="line">        <span class="keyword">ipc_port_t</span> sync_qos_override_port;</span><br><span class="line">    &#125; kdata;</span><br><span class="line">        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_nsrequest</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_pdrequest</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_port_request</span> *<span class="title">ip_requests</span>;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span> *<span class="title">premsg</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">sync_qos_count_t</span> sync_qos[THREAD_QOS_LAST];</span><br><span class="line">            <span class="keyword">sync_qos_count_t</span> special_port_qos;</span><br><span class="line">        &#125; qos_counter;</span><br><span class="line">    &#125; kdata2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mach_vm_address_t</span> ip_context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">natural_t</span> ip_sprequests:<span class="number">1</span>,    <span class="comment">/* send-possible requests outstanding */</span></span><br><span class="line">          ip_spimportant:<span class="number">1</span>,    <span class="comment">/* ... at least one is importance donating */</span></span><br><span class="line">          ip_impdonation:<span class="number">1</span>,    <span class="comment">/* port supports importance donation */</span></span><br><span class="line">          ip_tempowner:<span class="number">1</span>,    <span class="comment">/* dont give donations to current receiver */</span></span><br><span class="line">          ip_guarded:<span class="number">1</span>,         <span class="comment">/* port guarded (use context value as guard) */</span></span><br><span class="line">          ip_strict_guard:<span class="number">1</span>,    <span class="comment">/* Strict guarding; Prevents user manipulation of context values directly */</span></span><br><span class="line">          ip_specialreply:<span class="number">1</span>,    <span class="comment">/* port is a special reply port */</span></span><br><span class="line">          ip_link_sync_qos:<span class="number">1</span>,    <span class="comment">/* link the special reply port to destination port */</span></span><br><span class="line">          ip_impcount:<span class="number">24</span>;    <span class="comment">/* number of importance donations in nested queue */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mach_port_mscount_t</span> ip_mscount;</span><br><span class="line">    <span class="keyword">mach_port_rights_t</span> ip_srights;</span><br><span class="line">    <span class="keyword">mach_port_rights_t</span> ip_sorights;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MACH_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP_NSPARES  4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP_CALLSTACK_MAX    16</span></span><br><span class="line"><span class="comment">/*  queue_chain_t   ip_port_links;*/</span><span class="comment">/* all allocated ports */</span></span><br><span class="line">    <span class="keyword">thread_t</span>    ip_thread;  <span class="comment">/* who made me?  thread context */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   ip_timetrack;   <span class="comment">/* give an idea of "when" created */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span>   ip_callstack[IP_CALLSTACK_MAX]; <span class="comment">/* stack trace */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   ip_spares[IP_NSPARES]; <span class="comment">/* for debugging */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* MACH_ASSERT */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-ipc-pset">4. ipc_pset</h3>
<p>ipc_pset 结构体，对应于多个 mach port 的集合。以下是其声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_pset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Initial sub-structure in common with all ipc_objects.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span>    <span class="title">ips_object</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span>    <span class="title">ips_messages</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到上面这两个结构体的<strong>第一个字段都是 <code>struct ipc_object</code> 字段</strong>。</p>
<p>因此当 ipc_entry 中的 ie_object 指针指向这两个<strong>结构体中的 ipc_object 结构体字段</strong>时，这种指向关系也<strong>等价于直接指向这两个结构体的基地址</strong>。</p>
</blockquote>
<h3 id="5-mach-port-t-与-mach-port-name-t">5. mach_port_t 与 mach_port_name_t</h3>
<blockquote>
<p><strong>注：这一节较为重要。</strong></p>
</blockquote>
<p>在用户层调用 mach API 时，我们经常会看到 <code>mach_port_t</code> 与 <code>mach_port_name_t</code> 类型，并很容易<strong>将这些类型混淆</strong>（至少我学 mach 的时候经常混）。</p>
<p>引起混淆的原因很简单</p>
<ol>
<li>用户层输出这两个类型的值<strong>都是同一个整型数值</strong></li>
<li>使用某些 mach API 时，经常将 <code>mach_port_t</code> 类型的值直接作为 <code>mach_port_name_t</code> 类型的函数参数。</li>
<li>被一些函数声明给混淆了。明明是<code>mach_port_t</code>类型的参数，偏偏参数名为 <code>name</code>。</li>
</ol>
<p>虽然这两个类型在用户层中表示的值是相同的，但实际上在内核里有着非常明显的不同。</p>
<ul>
<li>
<p>对于<strong>端口名称</strong> (<strong>port name</strong>, aka <strong>mach_port_name_t</strong>) 来说，port name <strong>只是表示特定于某个 task 的 port</strong>，并且<strong>不携带任何关于该 port 的 right 相关信息</strong>。</p>
</li>
<li>
<p>而对于 <strong>端口</strong> (port, aka <strong>mach_port_t</strong>) 来说，它表示的是可以<strong>添加或删除某些端口权限</strong>的<strong>一个引用</strong>。当内核返回这样的一个引用给用户层时，用户层所获取到的是这个引用的 <strong>name</strong>，即 port name。这就是为什么用户层中，内核返回的 mach_port_name_t 和 mach_port_t 类型的变量都是同一个整型值。</p>
<blockquote>
<p><strong>正常来说</strong>，对于某个 mach port 来说，引用<strong>不同 right 的 name</strong> 是<strong>互不相同</strong>的。但也有例外，下文中有说明。</p>
</blockquote>
<p>但需要注意的是 ，mach_port_t 类型在内核中，确确实实映射了一个 ipc_port 类型的结构体，其中该结构体内含 port right 的相关数据。但 mach_port_name_t 只是 mach port 的一个整数表示形式，没有映射任何 ipc_port 类型的结构体，因此就没有关于该 mach port 的 right 信息。</p>
</li>
</ul>
<p>同时还有一点需要注意：对于某一个特定 mach port（即引用了相同的 ipc_port 结构体） ，如果该端口有多个 right，例如同时拥有 send right 和 receiver right。那么这些 right 的 name 将合并成一个 name，即一个 name 可以同时代表目标 mach port 的 send right 和 receiver right。但是，send once right 所对应的 name 总是唯一的命令，即总是会有一个独立的 name 来指代这个 mach port 的 send right。</p>
<p>当这两个类型被很好的区分开后，mach_port_t、mach_port_name_t、mach port right 以及 mach port 之间的关系就能很好的区分开了，对理解 mach IPC 有着非常多的帮助。这里先完整概括一下 port、right 以及 name 之间的关系：</p>
<ul>
<li>
<p>我们常常说的 <strong>mach port</strong>，指代的是<strong>内核</strong>中的 <strong>ipc_port 结构体</strong>，我们可以向这个 mach port 发送信息以及接收信息。</p>
</li>
<li>
<p>一个 mach port 在一些 task 中可能存在一些 rights，这些 rights 指定了当前 task 对该 mach port 的一些权限，例如接收信息，发送信息权限等等。这些在<strong>当前 task</strong> 中<strong>存在权限</strong>的 mach port ，一定在当前 task 的 ipc_space 中<strong>存在一个 ipc_port 结构体</strong>。</p>
<p>因此，<code>mach_port_t</code> 类型在<strong>内核</strong>（注意不是用户层）中就指代了一个在<strong>当前 task</strong> 中的 mach port 的<strong>一个 right</strong> 引用。</p>
<blockquote>
<p>注意 <code>mach_port_t</code> 类型在内核中<strong>不是</strong>直接代表一个 mach port，是不是觉得很绕？</p>
</blockquote>
</li>
<li>
<p>而 <code>mach_port_name_t</code> 类型在<strong>内核层和用户层</strong>中<strong>只是表示</strong>了一个 mach port，并<strong>没有涉及任何 right</strong>，也就更别说是 right 的引用了。</p>
</li>
<li>
<p>当内核返回给<strong>用户层</strong>一个 <code>mach_port_t</code> 类型引用时，与内核不同，这里<strong>用户层</strong>接收到的<strong>值的实质</strong>是<strong>对应该 right 的 name</strong>。即在用户层中， mach_port_t 类型的值表示的是对某个 mach port 对应的 <strong>right</strong> 的 <strong>name</strong>（注意此时<strong>并非直接引用</strong> right）。因此 <code>mach_port_t</code> 类型的值和 <code>mach_port_name_t</code> 类型的值会是相同的。</p>
</li>
<li>
<p>承接刚刚说的，正常来讲一个 mach_port_t 类型的值在<strong>用户层</strong>中会是某个 mach port 中<strong>一个 right</strong> 的 name。</p>
<p>但是，如果某个 mach_port_t 已经表示了<strong>某个 mach port 的 send right name</strong>，那么当用户请求一个表示了<strong>某个 mach port 的 receive right name（注意两个 right 是不同类型的）</strong>。那么这次请求将重用之前的 send right name，也就是说最后这个 port 既表示 send right name 又表示 receive right  name。</p>
<p>这种机制称为<strong>名称合并</strong>，即不同类型的 right 的 name 将可以合并为一个 name ，并指定多个 right。但需要注意的是 <strong>send-once right name无法被合并</strong>。</p>
<blockquote>
<p>例如两个 mach_port_t 类型分别表示引用某个 mach port 的 <strong>send right</strong> 和 <strong>send-once right</strong> 的 name，那么此时这两个 mach_port_t 类型的变量将是不同值。</p>
</blockquote>
</li>
</ul>
<h2 id="七、部分-IPC-基础-API">七、部分 IPC 基础 API</h2>
<h3 id="1-User-Mode">1. User Mode</h3>
<h4 id="a-mach-port-names">a. mach_port_names</h4>
<p>作用：返回指定 task 相关的 port namespace 信息。</p>
<p>函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span>   mach_port_names</span><br><span class="line">                (<span class="keyword">ipc_space_t</span>                               task,</span><br><span class="line">                 <span class="keyword">mach_port_name_array_t</span>                  *names,</span><br><span class="line">                 <span class="keyword">mach_msg_type_number_t</span>               *namesCnt,</span><br><span class="line">                 mach_port_type_array_                   *types,</span><br><span class="line">                 <span class="keyword">mach_msg_type_number_t</span>               *typesCnt);</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li><code>task</code>：待查阅的 task port，查阅者必须拥有目标 task 的 mach port  send right。</li>
<li><code>names</code>：存放查询结果的 <code>mach_port_name_t</code> 数组</li>
<li><code>namesCnt</code>：names 数组中的元素个数</li>
<li><code>types</code>：存放<strong>对于 names 数组中每个对应 name 的 right 类型</strong>的数组。</li>
<li><code>typesCnt</code>：types 数组中的元素个数。</li>
</ul>
<p>可以肯定的是，<strong>namesCnt 应该等于 typesCnt</strong>。</p>
<blockquote>
<p>而这个接口返回两个单独的 Cnt 是因为这是 Mach Interface Generator 的产物。‘</p>
</blockquote>
<p>需要注意的是，names 和 types 的缓冲区将会被自动创建，因此在使用完成后需要及时调用 vm_deallocate 释放。</p>
<h4 id="b-mach-port-get-attributes">b. mach_port_get_attributes</h4>
<p>作用：查询指定 port 的相关信息。</p>
<p>函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span>   mach_port_get_attributes</span><br><span class="line">                (<span class="keyword">ipc_space_t</span>                               task,</span><br><span class="line">                 <span class="keyword">mach_port_name_t</span>                          name,</span><br><span class="line">                 <span class="keyword">mach_port_flavor_t</span>                      flavor,</span><br><span class="line">                 <span class="keyword">mach_port_info_t</span>                     port_info,</span><br><span class="line">                 <span class="keyword">mach_msg_type_number_t</span>        *port_info_count);</span><br></pre></td></tr></table></figure>
<p>其中，参数说明如下：</p>
<ul>
<li>
<p><code>task</code>：持有待查询 port 的 task</p>
</li>
<li>
<p><code>name</code>：待查询 port 的 name</p>
</li>
<li>
<p><code>flavor</code>：所查询的信息类型</p>
<p>查询的信息类型有两种，分别是：</p>
<ul>
<li><strong>MACH_PORT_LIMITS_INFO</strong>：返回端口的资源限制（<strong>mach_port_limits</strong>）</li>
<li><strong>MACH_PORT_RECEIVE_STATUS</strong>：随机返回与端口相关的 <strong>right 和 message</strong> 的信息（<strong>mach_port_status</strong>）</li>
</ul>
</li>
<li>
<p><code>port_info</code>：一个指向<strong>存放查询结果的缓冲区</strong>的指针</p>
</li>
<li>
<p><code>port_info_count</code>：缓冲区最大可存放结果的数量。函数返回时该值将会被修改为实际返回的查询结果个数。</p>
</li>
</ul>
<p>以下是组合使用上面两个函数的一个简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_ON_MACH_ERROR(msg, retval) \</span></span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS)   &#123; mach_error(msg <span class="string">":"</span>, kr); <span class="built_in">exit</span>((retval)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_mach_port_type</span><span class="params">(<span class="keyword">mach_port_type_t</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type &amp; MACH_PORT_TYPE_SEND)         <span class="built_in">printf</span>(<span class="string">"SEND "</span>);</span><br><span class="line">    <span class="keyword">if</span> (type &amp; MACH_PORT_TYPE_RECEIVE)      <span class="built_in">printf</span>(<span class="string">"RECEIVE "</span>);</span><br><span class="line">    <span class="keyword">if</span> (type &amp; MACH_PORT_TYPE_SEND_ONCE)    <span class="built_in">printf</span>(<span class="string">"SEND_ONCE "</span>);</span><br><span class="line">    <span class="keyword">if</span> (type &amp; MACH_PORT_TYPE_PORT_SET)     <span class="built_in">printf</span>(<span class="string">"PORT_SET "</span>);</span><br><span class="line">    <span class="keyword">if</span> (type &amp; MACH_PORT_TYPE_DEAD_NAME)    <span class="built_in">printf</span>(<span class="string">"DEAD_NAME "</span>);</span><br><span class="line">    <span class="keyword">if</span> (type &amp; MACH_PORT_TYPE_DNREQUEST)    <span class="built_in">printf</span>(<span class="string">"DNREQUEST "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">mach_port_name_array_t</span> names;</span><br><span class="line">    <span class="keyword">mach_port_type_array_t</span> types;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> ncount, tcount;</span><br><span class="line">    <span class="keyword">mach_port_limits_t</span> port_limits;</span><br><span class="line">    <span class="keyword">mach_port_status_t</span> port_status;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> port_info_count;</span><br><span class="line">    <span class="keyword">task_t</span> task;</span><br><span class="line">    <span class="keyword">task_t</span> mytask = mach_task_self();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;pid&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    kr = task_for_pid(mytask, (<span class="keyword">int</span>)pid, &amp;task);</span><br><span class="line">    EXIT_ON_MACH_ERROR(<span class="string">"task_for_pid"</span>, kr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retrieve a list of the rights present in the given task's IPC space,</span></span><br><span class="line">    <span class="comment">// along with type information (no particular ordering)</span></span><br><span class="line">    kr = mach_port_names(task, &amp;names, &amp;ncount, &amp;types, &amp;tcount);</span><br><span class="line">    EXIT_ON_MACH_ERROR(<span class="string">"mach_port_names"</span>, kr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%8s %8s %8s %8s %8s task rights\n"</span>,</span><br><span class="line">           <span class="string">"name"</span>, <span class="string">"q-limit"</span>, <span class="string">"seqno"</span>, <span class="string">"msgcount"</span>, <span class="string">"sorights"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ncount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%08x "</span>, names[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get resource limits for the port</span></span><br><span class="line">        port_info_count = MACH_PORT_LIMITS_INFO_COUNT;</span><br><span class="line">        kr = mach_port_get_attributes(</span><br><span class="line">            task,                           <span class="comment">// the IPC space in question</span></span><br><span class="line">            names[i],                       <span class="comment">// task's name for the port</span></span><br><span class="line">            MACH_PORT_LIMITS_INFO,          <span class="comment">// information flavor desired</span></span><br><span class="line">            (<span class="keyword">mach_port_info_t</span>)&amp;port_limits, <span class="comment">// outcoming information</span></span><br><span class="line">            &amp;port_info_count);              <span class="comment">// size returned</span></span><br><span class="line">        <span class="keyword">if</span> (kr == KERN_SUCCESS)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%8d "</span>, port_limits.mpl_qlimit);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%8s "</span>, <span class="string">"-"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get miscellaneous information about associated rights and messages</span></span><br><span class="line">        port_info_count = MACH_PORT_RECEIVE_STATUS_COUNT;</span><br><span class="line">        kr = mach_port_get_attributes(task, names[i], MACH_PORT_RECEIVE_STATUS,</span><br><span class="line">                                      (<span class="keyword">mach_port_info_t</span>)&amp;port_status,</span><br><span class="line">                                      &amp;port_info_count);</span><br><span class="line">        <span class="keyword">if</span> (kr == KERN_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%8d %8d %8d "</span>,</span><br><span class="line">                   port_status.mps_seqno,     <span class="comment">// current sequence # for the port</span></span><br><span class="line">                   port_status.mps_msgcount,  <span class="comment">// # of messages currently queued</span></span><br><span class="line">                   port_status.mps_sorights); <span class="comment">// # of send-once rights</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%8s %8s %8s "</span>, <span class="string">"-"</span>, <span class="string">"-"</span>, <span class="string">"-"</span>);</span><br><span class="line">        print_mach_port_type(types[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm_deallocate(mytask, (<span class="keyword">vm_address_t</span>)names, ncount * <span class="keyword">sizeof</span>(<span class="keyword">mach_port_name_t</span>));</span><br><span class="line">    vm_deallocate(mytask, (<span class="keyword">vm_address_t</span>)types, tcount * <span class="keyword">sizeof</span>(<span class="keyword">mach_port_type_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例效果：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20211231141800537.png" alt="image-20211231141800537"></p>
<h4 id="c-mach-port-request-notification">c. mach_port_request_notification</h4>
<p>当某个 mach port 被销毁后，其他 task 所持有的 right 都将转变为 dead name，因此当发送信息时，发送者可以得知目标 mach port 被销毁。</p>
<p>但如果发送者希望目标 mach port 在被销毁时能<strong>立即通知发送者</strong>，而不是等到发送者<strong>发送数据时才得知</strong>，那么这就是 <code>mach_port_request_notification</code> 函数的作用。该函数指定目标 mach port 的事件请求通知。以下是该函数的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span>   mach_port_request_notification</span><br><span class="line">                (<span class="keyword">ipc_space_t</span>                               task,</span><br><span class="line">                 <span class="keyword">mach_port_name_t</span>                          name,</span><br><span class="line">                 <span class="keyword">mach_msg_id_t</span>                          variant,</span><br><span class="line">                 <span class="keyword">mach_port_mscount_t</span>                       sync,</span><br><span class="line">                 <span class="keyword">mach_port_send_once_t</span>                   notify,</span><br><span class="line">                 <span class="keyword">mach_msg_type_name_t</span>               notify_type,</span><br><span class="line">                 <span class="keyword">mach_port_send_once_t</span>                *previous);</span><br></pre></td></tr></table></figure>
<p>具体参数暂不说明，等实际应用到了再来补充。</p>
<h3 id="2-Kernel-Mode">2. Kernel Mode</h3>
<h4 id="a-ipc-entry-lookup">a. ipc_entry_lookup</h4>
<blockquote>
<p>注：ipc_right_lookup_write 是该函数的 Wrapper；而 ipc_right_lookup_read 又是 ipc_right_lookup_write 的宏。</p>
</blockquote>
<p>功能：在<strong>当前 task</strong> 的 <strong>IPC space</strong> 结构体中，根据传入的<strong>用户层 mach port name</strong>，获取到<strong>内核</strong>中对应的 <strong>ipc_entry_t 结构</strong>。</p>
<p>先上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ipc_entry_t</span></span><br><span class="line">ipc_entry_lookup(</span><br><span class="line">    <span class="keyword">ipc_space_t</span>        space,</span><br><span class="line">    <span class="keyword">mach_port_name_t</span>    name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mach_port_index_t</span> index;</span><br><span class="line">    <span class="keyword">ipc_entry_t</span> entry;</span><br><span class="line"></span><br><span class="line">    assert(is_active(space));</span><br><span class="line">    <span class="comment">// 获取 name 所对应的 index</span></span><br><span class="line">    index = MACH_PORT_INDEX(name);</span><br><span class="line">    <span class="keyword">if</span> (index &lt;  space-&gt;is_table_size) &#123;</span><br><span class="line">                entry = &amp;space-&gt;is_table[index];</span><br><span class="line">        <span class="keyword">if</span> (IE_BITS_GEN(entry-&gt;ie_bits) != MACH_PORT_GEN(name) ||</span><br><span class="line">            IE_BITS_TYPE(entry-&gt;ie_bits) == MACH_PORT_TYPE_NONE) &#123;</span><br><span class="line">            entry = IE_NULL;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        entry = IE_NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert((entry == IE_NULL) || IE_BITS_TYPE(entry-&gt;ie_bits));</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ipc_entry_lookup 函数中，我们可以看到，mach_port_name_t (aka unsigned int) 被分为了2个部分，分别是 MACH_PORT_INDEX 与 MACH_PORT_GEN。组装方式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_PORT_INDEX(name)       ((name) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_PORT_GEN(name)         (((name) &amp; 0xff) &lt;&lt; 24)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_PORT_MAKE(index, gen)  \</span></span><br><span class="line">        (((index) &lt;&lt; <span class="number">8</span>) | (gen) &gt;&gt; <span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>MACH_PORT_INDEX 用于在 <code>task-&gt;ipc_space-&gt;is_table</code> 中充当索引作用，有点类似于文件描述符。</li>
<li>MACH_PORT_GEN 说明当前 mach port 是第几代（generation）的。个人猜测这是为了将 mach port 与过去那些相同 index 但不同（且已经被释放）的 mach port 所区分开，防止混淆。</li>
</ul>
<p>还有个需要注意的地方是，在 mach_port_name_t 中，其32位数据的用途划分如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+-----+</span><br><span class="line">|   is_table index   | gen |</span><br><span class="line">+--------------------+-----+</span><br><span class="line">32                   8     0</span><br></pre></td></tr></table></figure>
<p>但在 ipc_entry 结构体中的 ie_bits 字段，其32位数据用途如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+-----+-----+------+----------------+</span><br><span class="line">| gen |     | type | user-reference |</span><br><span class="line">+-----+-----+------+----------------+</span><br><span class="line">32    24    21     16               0</span><br></pre></td></tr></table></figure>
<h4 id="b-ipc-right-copyin">b. ipc_right_copyin</h4>
<blockquote>
<p>先简单了解一下函数命名规则：</p>
<ul>
<li>xxx_copyin：发送方调用</li>
<li>xxx_copyout：接收方调用</li>
</ul>
</blockquote>
<p>ipc_right_copyin 会根据传入的 <strong>msgt_name</strong> (mach_msg_type_name_t) ，对<strong>目标 ipc_entry_t</strong> 中的 <strong>ipc_port 结构体</strong>上的某些字段进行修改操作，并<strong>返回对应的 ipc_port 结构体指针给上层调用者</strong>。</p>
<p>回顾一下上面 ipc_port 结构体的字段，该函数<strong>主要</strong>会对这三个字段进行增加操作：</p>
<blockquote>
<p>还有些其他的我没贴上来。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_port_mscount_t</span> ip_mscount; <span class="comment">// make send 的次数</span></span><br><span class="line"><span class="keyword">mach_port_rights_t</span> ip_srights;  <span class="comment">// send right 当前存在的发送权限的数量</span></span><br><span class="line"><span class="keyword">mach_port_rights_t</span> ip_sorights; <span class="comment">// send once right 数量</span></span><br></pre></td></tr></table></figure>
<p>该函数涉及到 mach port 的权限操作。port right 类型主要有以下几种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_MOVE_RECEIVE      16    <span class="comment">/* Must hold receive right */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_MOVE_SEND         17    <span class="comment">/* Must hold send right(s) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_MOVE_SEND_ONCE    18    <span class="comment">/* Must hold sendonce right */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_COPY_SEND         19    <span class="comment">/* Must hold send right(s) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_MAKE_SEND         20    <span class="comment">/* Must hold receive right */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_MAKE_SEND_ONCE    21    <span class="comment">/* Must hold receive right */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_COPY_RECEIVE      22    <span class="comment">/* NOT VALID */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_DISPOSE_RECEIVE   24    <span class="comment">/* must hold receive right */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_DISPOSE_SEND      25    <span class="comment">/* must hold send right(s) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_MSG_TYPE_DISPOSE_SEND_ONCE 26    <span class="comment">/* must hold sendonce right */</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数我们暂时不用深入了解，只需知道该函数除了做一些 right 处理以外，还会将 ipc_entry 中的 ipc_port 结构体返回给调用者即可。</p>
<h4 id="c-port-name-to-task">c. port_name_to_task</h4>
<p>功能：在<strong>内核空间</strong>中，根据用户传入的 <strong>task port name</strong> （一串数字表示的值），获取所实际引用的 task 结构体指针。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task_t</span></span><br><span class="line">port_name_to_task(</span><br><span class="line">    <span class="keyword">mach_port_name_t</span> name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ipc_port_t</span> kern_port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">task_t</span> task = TASK_NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MACH_PORT_VALID(name)) &#123;</span><br><span class="line">        kr = ipc_object_copyin(current_space(), name,</span><br><span class="line">                       MACH_MSG_TYPE_COPY_SEND,</span><br><span class="line">                       (<span class="keyword">ipc_object_t</span> *) &amp;kern_port);</span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS)</span><br><span class="line">            <span class="keyword">return</span> TASK_NULL;</span><br><span class="line"></span><br><span class="line">        task = convert_port_to_task(kern_port);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IP_VALID(kern_port))</span><br><span class="line">            ipc_port_release_send(kern_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数内部会将 task port name 传入 ipc_object_copyin 函数中，获取其对应的 task port 的 ipc_port 结构体。之后，在  convert_port_to_task 中，将 task port 对应的 ipc_port 结构体中的 ip_kobject 字段的值取出，并作为 目标 task 结构体指针。</p>
<h4 id="d-mach-msg-2">d. mach_msg</h4>
<p>mach_msg 是用户用于发送和接受 mach message 的 API。</p>
<p>上个完整的流程图：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20211231144049005.png" alt="image-20211231144049005"></p>
<p>mach_msg_overwrite_trap 是 mach msg 发送与接收消息的实际内核处理函数。该函数的实现分为两部分，分别是发送消息和接收消息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">mach_msg_overwrite_trap(</span><br><span class="line">    struct mach_msg_overwrite_trap_args *args)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">mach_vm_address_t</span>     msg_addr = args-&gt;msg;</span><br><span class="line">    <span class="keyword">mach_msg_option_t</span>       option = args-&gt;option;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>         send_size = args-&gt;send_size;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>         rcv_size = args-&gt;rcv_size;</span><br><span class="line">    <span class="keyword">mach_port_name_t</span>        rcv_name = args-&gt;rcv_name;</span><br><span class="line">    <span class="keyword">mach_msg_timeout_t</span>      msg_timeout = args-&gt;timeout;</span><br><span class="line">    <span class="keyword">mach_msg_priority_t</span>     <span class="keyword">override</span> = args-&gt;<span class="keyword">override</span>;</span><br><span class="line">    <span class="keyword">mach_vm_address_t</span>       rcv_msg_addr = args-&gt;rcv_msg;</span><br><span class="line">    __unused <span class="keyword">mach_port_seqno_t</span> temp_seqno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mach_msg_return_t</span>  mr = MACH_MSG_SUCCESS;</span><br><span class="line">    <span class="keyword">vm_map_t</span> <span class="built_in">map</span> = current_map();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only accept options allowed by the user */</span></span><br><span class="line">    option &amp;= MACH_MSG_OPTION_USER;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (option &amp; MACH_SEND_MSG) &#123; <span class="comment">/* ... ipc_kmsg_send(xxx) ... */</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> (option &amp; MACH_RCV_MSG) &#123; <span class="comment">/* ... ipc_mqueue_receive_on_thread(xxx) ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ipc_kmsg_t</code> 结构体即待发送的内核消息，结构体如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span> &#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>            ikm_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span>            *<span class="title">ikm_next</span>;</span>        <span class="comment">/* next message on port/discard queue */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span>            *<span class="title">ikm_prev</span>;</span>        <span class="comment">/* prev message on port/discard queue */</span></span><br><span class="line">    <span class="keyword">mach_msg_header_t</span>          *ikm_header;      <span class="comment">// 指向 Mach Message 的指针</span></span><br><span class="line">    <span class="keyword">ipc_port_t</span>                 ikm_prealloc;     <span class="comment">/* port we were preallocated from */</span></span><br><span class="line">    <span class="keyword">ipc_port_t</span>                 ikm_voucher;      <span class="comment">/* voucher port carried */</span></span><br><span class="line">    <span class="keyword">mach_msg_priority_t</span>        ikm_qos;          <span class="comment">/* qos of this kmsg */</span></span><br><span class="line">    <span class="keyword">mach_msg_priority_t</span>        ikm_qos_override; <span class="comment">/* qos override on this kmsg */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_importance_elem</span> *<span class="title">ikm_importance</span>;</span>  <span class="comment">/* inherited from */</span></span><br><span class="line">    <span class="keyword">queue_chain_t</span>              ikm_inheritance;  <span class="comment">/* inherited from link */</span></span><br><span class="line">    <span class="keyword">sync_qos_count_t</span> sync_qos[THREAD_QOS_LAST];  <span class="comment">/* sync qos counters for ikm_prealloc port */</span></span><br><span class="line">    <span class="keyword">sync_qos_count_t</span> special_port_qos;           <span class="comment">/* special port qos for ikm_prealloc port */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MACH_FLIPC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mach_node</span>           *<span class="title">ikm_node</span>;</span>        <span class="comment">/* Originating node - needed for ack */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体中包含了较多字段，其中存在一个指向待发送 Mach message 的指针。</p>
<p>受限于知识储备，内核中的具体细节留待更进一步的分析。</p>
<h2 id="八、MIG">八、MIG</h2>
<h3 id="1-概述">1. 概述</h3>
<p>一说到 Mach IPC 后，一个不得不提到的东西便是 <strong>MIG(Mach Interface Generator)</strong>。但这里我们不过多了解 MIG 中非常具体的使用方式与编写语法，只简单了解一下它的功能与意义等等。</p>
<p>通过上面的例子我们可以知道，Mach IPC 可以用与 **RPC（远程过程调用）**中。通俗的讲，它可以做到：<strong>当 Client ”调用“ 某个远程方法时，Server 将从 Mach IPC 中收到信息并实际执行该方法，最后将调用结果再通过 Mach IPC 返回给 Client，以实现 Client 的透明调用。</strong></p>
<p>那么如果 Client 需要调用的方法<strong>很多</strong>，那对于开发者而言，除了<strong>需要完成方法的实际实现</strong>以外，他们还得<strong>手工</strong>完成 <strong>Mach IPC 之间的信息处理与分发</strong>等等<strong>重复乏味且机械的工作</strong>，开发效率极低。</p>
<p>因此， MIG 的使用可以帮助我们完成后者，解放生产力，让开发人员更关注于方法的实现。</p>
<p>MIG 可以从<strong>用户编写的 RPC 规范文件</strong>（.defs 文件）中，生成出 CS 架构的代码。这些代码将自动完成 Mach Message 的准备、发送、接收、解包等等功能。同时由于代码是自动生成的，因此可以提高代码一致性，降低代码发生错误的可能。</p>
<p>MIG 将会生成三个文件，分别是</p>
<ol>
<li>用于用户 include 的一个头文件</li>
<li>client 端的一个源文件，用于和 client 的其他代码所链接。</li>
<li>server 端的一个源文件，用于和 server 端的其他代码所链接。这部分代码会自动完成消息接收，事件分发，函数调用，信息回复等操作。</li>
</ol>
<p>以下是一个示例：<br>
<img src="/2021/12/mach_ipc_intro/image-20220105175226555.png" alt="image-20220105175226555"></p>
<h3 id="2-CS-架构程序示例">2. CS 架构程序示例</h3>
<h4 id="a-概述">a. 概述</h4>
<p>这部分我们将简单了解一下如何使用 MIG 创建一个简单的 CS 程序。</p>
<p>在这个 CS 架构项目中，Server 程序会提供两个接口 ：</p>
<ul>
<li><code>string_length</code>：获取传入字符串的长度</li>
<li><code>factorial</code>：计算传入数字的阶乘</li>
</ul>
<blockquote>
<p>该示例来自于：*OS Internal Vol 1</p>
</blockquote>
<h4 id="b-杂项公共头文件">b. 杂项公共头文件</h4>
<p>首先，给出 Client 和 Server 的<strong>杂项</strong>公共头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// misc_types.h </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MISC_TYPES_H_ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MISC_TYPES_H_ </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;servers/bootstrap.h&gt; </span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// The server port will be registered under this name. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIG_MISC_SERVICE <span class="meta-string">"MIG-miscservice"</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Data representations </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">input_string_t</span>[<span class="number">64</span>]; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">xput_number_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> head; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The following fields do not represent the actual layout of the request </span></span><br><span class="line">    <span class="comment">// and reply messages that MIG will use. However, a request or reply </span></span><br><span class="line">    <span class="comment">// message will not be larger in size than the sum of the sizes of these </span></span><br><span class="line">    <span class="comment">// fields. We need the size to put an upper bound on the size of an </span></span><br><span class="line">    <span class="comment">// incoming message in a mach_msg() call. </span></span><br><span class="line">    NDR_record_t NDR; </span><br><span class="line">    <span class="keyword">union</span> &#123; </span><br><span class="line">        <span class="keyword">input_string_t</span> <span class="built_in">string</span>; </span><br><span class="line">        <span class="keyword">xput_number_t</span> number; </span><br><span class="line">    &#125; data; </span><br><span class="line">    <span class="keyword">kern_return_t</span>      RetCode; </span><br><span class="line">    <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">msg_misc_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">xput_number_t</span> <span class="title">misc_translate_int_to_xput_number_t</span><span class="params">(<span class="keyword">int</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span>           <span class="title">misc_translate_xput_number_t_to_int</span><span class="params">(<span class="keyword">xput_number_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span>          <span class="title">misc_remove_reference</span><span class="params">(<span class="keyword">xput_number_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">kern_return_t</span> <span class="title">string_length</span><span class="params">(<span class="keyword">mach_port_t</span>, <span class="keyword">input_string_t</span>, <span class="keyword">xput_number_t</span> *)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">kern_return_t</span> <span class="title">factorial</span><span class="params">(<span class="keyword">mach_port_t</span>, <span class="keyword">xput_number_t</span>, <span class="keyword">xput_number_t</span> *)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _MISC_TYPES_H_</span></span></span><br></pre></td></tr></table></figure>
<p>在这个头文件中，定义了两个类型 <code>input_string_t</code> 和 <code>xput_number_t</code>，并声明了一些函数。</p>
<p>在这些函数中，有两个是目标接口声明，另外3个是 MIG 生成的代码内部会调用到的，一会再说明。</p>
<p>其中的 <code>msg_misc_t</code> 结构体声明只用于 Server 调用 mach_msg_server 函数时指定最大 message 长度，不会实际实例化该结构体。</p>
<h4 id="c-RPC-defs">c. RPC defs</h4>
<p>之后，再给出 defs 文件：</p>
<blockquote>
<p>defs 文件中的一些符号说明，已经以注释的形式写入 defs 中，下面不再赘述。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * A "Miscellaneous" Mach Server </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * File:    misc.defs </span></span><br><span class="line"><span class="comment"> * Purpose: Miscellaneous Server subsystem definitions </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Subsystem identifier </span></span><br><span class="line"><span class="comment"> * 指定当前的 mig 中的接口ID 从 500 开始，同时该文件所生成的模块均以 `misc` 命名</span></span><br><span class="line"><span class="comment"> * 这里的字符串也会影响到输出的 `*Server.c`、 `*User.c` 等文件的命名</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">Subsystem misc <span class="number">500</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Type declarations </span></span><br><span class="line"><span class="comment"> * 类型规范部分：用于定义函数调用参数的数据类型</span></span><br><span class="line"><span class="comment"> *     MIG支持简单类型、结构化类型、指针类型和多态类型的声明。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/std_types.defs&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_types.defs&gt; </span></span></span><br><span class="line"></span><br><span class="line">type <span class="keyword">input_string_t</span> = <span class="built_in">array</span>[<span class="number">64</span>] of <span class="keyword">char</span>; </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 这里可能要稍微说明一下</span></span><br><span class="line"><span class="comment"> * 首先，设置 xput_number_it 的类型为 int</span></span><br><span class="line"><span class="comment"> * InTran 指定当函数传入 int 时，如果需要将其转换成 xput_number_t 类型，则调用 misc_translate_int_to_xput_number_t 函数转换</span></span><br><span class="line"><span class="comment"> * OutTran 指定当函数需要输出 int 时，如果需要将其从 xput_number_t 类型转换，则调用 misc_translate_xput_number_t_to_int 函数来转换</span></span><br><span class="line"><span class="comment"> * Destructor 指定当 xput_number_t 类型的变量需要析构时，执行该函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">type <span class="keyword">xput_number_t</span>  = <span class="keyword">int</span> </span><br><span class="line">         CType      : <span class="keyword">int</span> </span><br><span class="line">         InTran     : <span class="keyword">xput_number_t</span> <span class="keyword">misc_translate_int_to_xput_number_t</span>(<span class="keyword">int</span>) </span><br><span class="line">         OutTran    : <span class="keyword">int</span> misc_translate_xput_number_t_to_int(<span class="keyword">xput_number_t</span>) </span><br><span class="line">         Destructor : misc_remove_reference(<span class="keyword">xput_number_t</span>) </span><br><span class="line">    ; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Import declarations </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"misc_types.h"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Operation descriptions </span></span><br><span class="line"><span class="comment"> * 需要注意的是，每个函数声明中，至少要包含一个 mach_port_t 类型的参数。</span></span><br><span class="line"><span class="comment"> * 一方面，在 Client 中，这个参数指定了向哪个 Server 发起调用</span></span><br><span class="line"><span class="comment"> * 而另一方面，Server 中具体方法的实现也可以获取到一个 mach_port_t 类型的值，从而判断调用者</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This should be operation #500 */</span> </span><br><span class="line"><span class="function">routine <span class="title">string_length</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">                         server_port : <span class="keyword">mach_port_t</span>; </span></span></span><br><span class="line"><span class="function"><span class="params">                      in instring    : <span class="keyword">input_string_t</span>; </span></span></span><br><span class="line"><span class="function"><span class="params">                     out len         : <span class="keyword">xput_number_t</span>)</span></span>; </span><br><span class="line"><span class="comment">/* Create some holes in operation sequence */</span> </span><br><span class="line"><span class="comment">// 跳过序列中的 501、502、503，这里的 skip 操作可以保持接口的兼容性，有点类似于 protobuf</span></span><br><span class="line">Skip; </span><br><span class="line">Skip; </span><br><span class="line">Skip; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This should be operation #504, as there are three Skip's */</span> </span><br><span class="line"><span class="function">routine <span class="title">factorial</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">                     server_port : <span class="keyword">mach_port_t</span>; </span></span></span><br><span class="line"><span class="function"><span class="params">                  in num         : <span class="keyword">xput_number_t</span>; </span></span></span><br><span class="line"><span class="function"><span class="params">                 out fac         : <span class="keyword">xput_number_t</span>)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Option declarations </span></span><br><span class="line"><span class="comment"> * 这里设置了两个 Prefix，这些 Prefix 会分别作为所调用的/所实现的 IPC 操作函数名称前缀</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">ServerPrefix Server_; </span><br><span class="line">UserPrefix   Client_;</span><br></pre></td></tr></table></figure>
<p>更多 MIG defs 语法可以参照 <a href="https://www.nextop.de/NeXTstep_3.3_Developer_Documentation/OperatingSystem/Part1_Mach/02_Messages/Messages.htmld/index.html" target="_blank" rel="noopener">Using Mach Messages - NeXTstep 3.3 Developer Documentation</a>。</p>
<h4 id="d-Server">d. Server</h4>
<p>Server 源程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"misc_types.h"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">boolean_t</span> <span class="title">misc_server</span><span class="params">(<span class="keyword">mach_msg_header_t</span> *inhdr, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">mach_msg_header_t</span> *outhdr)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// InTran </span></span><br><span class="line"><span class="keyword">xput_number_t</span> </span><br><span class="line"><span class="keyword">misc_translate_int_to_xput_number_t</span>(<span class="keyword">int</span> param) &#123; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"misc_translate_incoming(%d)\n"</span>, param); </span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">xput_number_t</span>)param; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// OutTran </span></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">misc_translate_xput_number_t_to_int(<span class="keyword">xput_number_t</span> param) &#123; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"misc_translate_outgoing(%d)\n"</span>, (<span class="keyword">int</span>)param); </span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">int</span>)param; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// Destructor </span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">misc_remove_reference(<span class="keyword">xput_number_t</span> param) &#123; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"misc_remove_reference(%d)\n"</span>, (<span class="keyword">int</span>)param); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// an operation that we export </span></span><br><span class="line"><span class="keyword">kern_return_t</span> </span><br><span class="line">string_length(<span class="keyword">mach_port_t</span>     server_port, </span><br><span class="line">              <span class="keyword">input_string_t</span>  instring, </span><br><span class="line">              <span class="keyword">xput_number_t</span>  *len) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (!instring || !len) </span><br><span class="line">        <span class="keyword">return</span> KERN_INVALID_ADDRESS; </span><br><span class="line"> </span><br><span class="line">    *len = <span class="built_in">strlen</span>(instring);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> KERN_SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// an operation that we export </span></span><br><span class="line"><span class="keyword">kern_return_t</span> </span><br><span class="line">factorial(<span class="keyword">mach_port_t</span> server_port, <span class="keyword">xput_number_t</span> num, <span class="keyword">xput_number_t</span> *fac) &#123; </span><br><span class="line">    <span class="keyword">if</span> (!fac) </span><br><span class="line">        <span class="keyword">return</span> KERN_INVALID_ADDRESS; </span><br><span class="line"> </span><br><span class="line">    *fac = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= num; i++) </span><br><span class="line">        *fac *= i; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> KERN_SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">kern_return_t</span> kr; </span><br><span class="line">    <span class="keyword">mach_port_t</span> server_port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((kr = bootstrap_check_in(bootstrap_port, MIG_MISC_SERVICE, </span><br><span class="line">                                 &amp;server_port)) != BOOTSTRAP_SUCCESS) &#123; </span><br><span class="line">        mach_port_deallocate(mach_task_self(), server_port); </span><br><span class="line">        mach_error(<span class="string">"bootstrap_check_in:"</span>, kr); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    mach_msg_server(misc_server,            <span class="comment">// call the server-interface module </span></span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="keyword">msg_misc_t</span>),     <span class="comment">// maximum receive size </span></span><br><span class="line">                    server_port,            <span class="comment">// port to receive on </span></span><br><span class="line">                    MACH_MSG_TIMEOUT_NONE); <span class="comment">// options </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Server 端要做的事情稍微多一点：</p>
<ol>
<li>
<p>程序执行时，Server 将 server port 注册进 bootstrap 中。</p>
<p>初次之外，Server 还执行 <code>mach_msg_server</code> 函数，使当前进程一直循环处理 Mach Message。</p>
<p>mach_msg_server 函数的第一个参数指定了 MIG 生成的 <code>misc_server</code> 处理例程，该例程会根据传进的 Mach Message 执行指定的接口。</p>
</li>
<li>
<p><strong>Server 端实现了两个接口的具体实现</strong>。当 Server 接收到 Client 端发来的信息时，这两个方法将在 miscServer.c 中被调用。</p>
</li>
<li>
<p>除此之外，Server 还实现了其他 MIG 中会调用的函数。</p>
</li>
</ol>
<h4 id="e-Client">e. Client</h4>
<p>Client 源程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.c </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"misc_types.h"</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_STRING <span class="meta-string">"Hello, MIG!"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_NUMBER 5 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">kern_return_t</span> kr; </span><br><span class="line">    <span class="keyword">mach_port_t</span>   server_port; </span><br><span class="line">    <span class="keyword">int</span>           len, fac; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// look up the service to find the server's port </span></span><br><span class="line">    <span class="keyword">if</span> ((kr = bootstrap_look_up(bootstrap_port, MIG_MISC_SERVICE, </span><br><span class="line">                                &amp;server_port)) != BOOTSTRAP_SUCCESS) &#123; </span><br><span class="line">        mach_error(<span class="string">"bootstrap_look_up:"</span>, kr); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// call a procedure </span></span><br><span class="line">    <span class="keyword">if</span> ((kr = string_length(server_port, INPUT_STRING, &amp;len)) != KERN_SUCCESS) </span><br><span class="line">        mach_error(<span class="string">"string_length:"</span>, kr); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"length of \"%s\" is %d\n"</span>, INPUT_STRING, len); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// call another procedure </span></span><br><span class="line">    <span class="keyword">if</span> ((kr = factorial(server_port, INPUT_NUMBER, &amp;fac)) != KERN_SUCCESS) </span><br><span class="line">        mach_error(<span class="string">"factorial:"</span>, kr); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"factorial of %d is %d\n"</span>, INPUT_NUMBER, fac); </span><br><span class="line"> </span><br><span class="line">    mach_port_deallocate(mach_task_self(), server_port); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client 源码较短，只做了两件事：</p>
<ol>
<li>
<p>向 bootstrap 查询 Server 注册的 server port</p>
</li>
<li>
<p>向 server port 调用 <code>string_length</code>和 <code>factorial</code> 方法，需要注意到这两个方法的第一个参数均为 <code>mach_port_t</code> 类型，且方法的实现位于 <code>miscUser.c</code></p>
<blockquote>
<p>为什么这两个方法的实现位于 miscUser.c 中而不是 server.c 中？</p>
<p>因为对于 Client 端来说，两个方法的实际实现不归 Client 端来管，miscUser.c 中的两个同名函数最终会执行 mach IPC 向 Server 发起请求。</p>
</blockquote>
</li>
</ol>
<h4 id="f-编译与运行">f. 编译与运行</h4>
<p>使用以下命令编译并运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端1</span></span><br><span class="line">mig -v misc.defs </span><br><span class="line">gcc -Wall -g -o server server.c miscServer.c </span><br><span class="line">gcc -Wall -g -o client client.c miscUser.c </span><br><span class="line">./server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端2</span></span><br><span class="line">./client</span><br></pre></td></tr></table></figure>
<p>这是所有源文件的关联图：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20220106000421902.png" alt="image-20220106000421902"></p>
<p>运行结果：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20220105234905893.png" alt="image-20220105234905893"></p>
<p>这是 Client 和 Server 的关系：</p>
<p><img src="/2021/12/mach_ipc_intro/image-20220106000500793.png" alt="image-20220106000500793"></p>
<h2 id="九、参考">九、参考</h2>
<ul>
<li>*OS internal Vol 1, Vol2</li>
<li><a href="https://docs.darlinghq.org/internals/macos-specifics/mach-ports.html" target="_blank" rel="noopener">Mach ports - darling</a></li>
<li>dmcyk blog
<ul>
<li><a href="https://dmcyk.xyz/post/xnu_ipc_i_mach_messages/" target="_blank" rel="noopener">XNU IPC - Mach Message</a></li>
<li><a href="https://dmcyk.xyz/post/xnu_ipc_ii_message_apis/xnu_ipc_ii_message_apis/" target="_blank" rel="noopener">XNU IPC - bidirectional Mach messages</a></li>
<li><a href="https://dmcyk.xyz/post/xnu_ipc_iii_ool_data/" target="_blank" rel="noopener">XNU IPC - Introduction to OOL data</a></li>
</ul>
</li>
<li><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html" target="_blank" rel="noopener">Mach - Apple archive dev documentation</a></li>
<li><a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/" target="_blank" rel="noopener">XNU man: Mach IPC Interface - mit</a></li>
<li><a href="https://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html" target="_blank" rel="noopener">mach_msg - mit</a></li>
<li><a href="https://www.gnu.org/software/hurd/gnumach-doc/Message-Format.html" target="_blank" rel="noopener">4.2.2 Message Format - GNUMach-doc</a></li>
<li><a href="https://www.nextop.de/NeXTstep_3.3_Developer_Documentation/OperatingSystem/Part1_Mach/02_Messages/Messages.htmld/index.html" target="_blank" rel="noopener">Using Mach Messages - NeXTstep 3.3 Developer Documentation</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://kiprey.github.io/2021/12/mach_ipc_intro/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ipc/" rel="tag">ipc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mac/" rel="tag">mac</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mach/" rel="tag">mach</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/01/mach_xpc_intro/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            MacOSX XPC 入门
          
        </div>
      </a>
    
    
      <a href="/2021/12/vmware_macos/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Win10 Vmware Workstation 16 安装 macOS 记录</div>
      </a>
    
  </nav>

   
 
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '5f6c407f4cb8963d03ac',
    clientSecret: '1d6faa663a735dbfd671990187d6e62b32498560',
    repo: 'kiprey.github.io',
    owner: 'kiprey',
    admin: ['kiprey'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2025
        <i class="ri-heart-fill heart_icon"></i> Kiprey
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        <!-- <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
        <script>
            $(document).ready(function() {
                var int1 = setInterval(fixCount1, 100);
                var int2 = setInterval(fixCount2, 100);

                var busuanziValueSiteOffset = 100000000000;
                var busuanziValuePageOffset = 200000000000;
                function fixCount1() {
                    if ($("#busuanzi_value_site_uv").css("display") != "none") {
                        clearInterval(int1);
                        $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + busuanziValueSiteOffset);
                    }
                }
                function fixCount2() {
                    if ($("#busuanzi_value_page_pv").css("display") != "none") {
                        clearInterval(int2);
                        $("#busuanzi_value_page_pv").html(parseInt($("#busuanzi_value_page_pv").html()) + busuanziValuePageOffset);
                    }
                }
            });
        </script> -->
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Kiprey&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>


<!-- mermaid -->

  <script src='https://cdn.bootcdn.net/ajax/libs/mermaid/8.5.2/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

<!-- baiduSpider auto push -->

  <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>


    
  </div>
</body>

</html>